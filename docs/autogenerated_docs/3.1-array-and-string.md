# Array and String

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [std/assembly/array.ts](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/array.ts)
- [std/assembly/string.ts](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/string.ts)
- [tests/compiler/std/array.ts](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/tests/compiler/std/array.ts)
- [tests/compiler/std/string.ts](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/tests/compiler/std/string.ts)

</details>



This page documents the Array and String implementations in the AssemblyScript standard library, which provide fundamental data structures for collections and text manipulation. These classes are core building blocks for most AssemblyScript applications and are implemented with careful attention to memory efficiency and runtime safety.

## Memory Structure

Both Array and String have carefully designed memory layouts to optimize performance while ensuring type safety.

```mermaid
classDiagram
    class Array~T~ {
        buffer: ArrayBuffer
        dataStart: usize
        byteLength: i32
        length_: i32
        [key: number]: T
    }

    class String {
        <<final abstract>>
        +MAX_LENGTH: i32
        +length: i32
        +Various string methods...
    }

    note for Array~T~ "Memory layout mimics ArrayBufferView"
    note for String "Internally stores UTF-16 code units"
```

### Array Memory Layout

The Array class has a specific memory structure that intentionally mimics the ArrayBufferView interface:

```mermaid
flowchart LR
    subgraph "Array<T> Memory Structure"
        A["Array<T> Instance"] --> B["Header (OBJECT)"]
        A --> C["buffer: ArrayBuffer"]
        A --> D["dataStart: usize"]
        A --> E["byteLength: i32"]
        A --> F["length_: i32"]
        
        C --> G["ArrayBuffer"]
        G --> H["Element 0"]
        G --> I["Element 1"]
        G --> J["..."]
        G --> K["Element n-1"]
        
        D -.-> H
    end
```

Sources: [std/assembly/array.ts:41-56](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/array.ts:41-56#L41-L56)

Key characteristics:
- `buffer`: Points to an ArrayBuffer containing the actual data
- `dataStart`: Provides direct memory access to the start of the array data
- `byteLength`: Tracks the capacity of the array in bytes
- `length_`: Stores the actual number of elements

Arrays have a minimum capacity (8 elements) and grow by doubling their capacity when needed to amortize allocation costs.

### String Memory Layout

Strings in AssemblyScript are final abstract classes that store UTF-16 encoded text:

```mermaid
flowchart LR
    subgraph "String Memory Structure"
        A["String Instance"] --> B["Header (OBJECT)"]
        A --> C["UTF-16 Code Units"]
        C --> D["Code Unit 0"]
        C --> E["Code Unit 1"]
        C --> F["..."]
        C --> G["Code Unit n-1"]
    end
```

Sources: [std/assembly/string.ts:10-86](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/string.ts:10-86#L10-L86)

Key characteristics:
- Implemented as a final abstract class
- Internally stores a sequence of 16-bit code units (UTF-16)
- Provides the `length` property that returns the number of code units
- Defines a maximum length based on block size constraints
- All string operations create new instances (immutable design)

## Array Implementation

### Creation and Capacity Management

Arrays dynamically manage their capacity as elements are added:

```mermaid
flowchart TD
    subgraph "Array Capacity Management"
        A["Array Creation"] --> B["new Array<T>(length)"]
        A --> C["Array.create<T>(capacity)"]
        
        D["Growth Management"] --> E["push()/unshift()"]
        E --> F["ensureCapacity()"]
        F --> G["Current capacity sufficient?"]
        G -->|"Yes"| H["Use existing buffer"]
        G -->|"No"| I["Calculate new capacity"]
        I --> J["Allocate new buffer"]
        J --> K["Copy old elements"]
        K --> L["Update internal pointers"]
    end
```

Sources: [std/assembly/array.ts:15-38](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/array.ts:15-38#L15-L38), [std/assembly/array.ts:69-86](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/array.ts:69-86#L69-L86)

Key implementation details:
- Arrays start with a minimum capacity of 8 elements
- The `ensureCapacity` function handles dynamic resizing:
  - Checks if current capacity is sufficient
  - Typically doubles capacity when growing
  - Allocates new memory with `__new`/`__renew`
  - Copies existing elements to the new buffer
  - Updates internal pointers
- Capacity is constrained by `BLOCK_MAXSIZE`

### Element Access and Mutation

Array provides methods for accessing and manipulating elements:

```mermaid
flowchart TD
    subgraph "Array Element Operations"
        A["Element Access"] --> B["array[index]"]
        A --> C["array.at(index)"]
        
        D["Element Mutation"] --> E["array[index] = value"]
        
        F["Array Modification"] --> G["End Operations"]
        F --> H["Start Operations"]
        F --> I["Middle Operations"]
        
        G --> J["push()/pop()"]
        H --> K["unshift()/shift()"]
        I --> L["splice()"]
    end
```

Sources: [std/assembly/array.ts:113-151](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/array.ts:113-151#L113-L151), [std/assembly/array.ts:206-371](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/array.ts:206-371#L206-L371)

Implementation characteristics:
- Direct indexing (`array[index]`) includes bounds checking and throws a RangeError when out of bounds
- `at` method supports negative indices (counting from the end)
- For non-nullable reference types, accessing an uninitialized (null) element throws an error
- `push` ensures capacity before adding elements
- `shift`/`unshift` use `memory.copy` to move elements
- `splice` extracts elements and adjusts the array

### Iteration and Higher-Order Functions

Array implements numerous higher-order functions:

```mermaid
flowchart TD
    subgraph "Array Higher-Order Functions"
        A["Iteration"] --> B["forEach()"]
        
        C["Transformation"] --> D["map<U>()"]
        C --> E["filter()"]
        
        F["Reduction"] --> G["reduce<U>()"]
        F --> H["reduceRight<U>()"]
        
        I --> K["findLastIndex()"]
        
        L["Conditions"] --> M["every()"]
        L --> N["some()"]
    end
```

Sources: [std/assembly/array.ts:92-352](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/array.ts:92-352#L92-L352)

Key implementation patterns:
- Iterations are based on the initial length to prevent infinite loops if the array is modified during iteration
- Safe handling of reference types with proper runtime linking
- Optimization for common operation patterns
- Support for early termination in functions like `some` and `every`

### Transformation and Utilities

Arrays include methods for data transformation:

```mermaid
flowchart TD
    subgraph "Array Transformation"
        A["Transformation"] --> B["sort()"]
        A --> C["reverse()"]
        A --> D["concat()"]
        A --> E["slice()"]
        A --> F["flat()"]
        
        G["Utilities"] --> H["join()"]
        G --> I["includes()"]
        G --> J["indexOf()/lastIndexOf()"]
        G --> K["copyWithin()"]
    end
```

Sources: [std/assembly/array.ts:153-511](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/array.ts:153-511#L153-L511)

Implementation highlights:
- `sort` implements a stable sorting algorithm that handles various edge cases
- `reverse` modifies the array in place using efficient memory operations
- `concat` creates a new array with combined elements
- `slice` extracts a portion of the array into a new instance
- `flat` flattens nested arrays
- Special handling for floating-point types (e.g., `includes` treats NaN as equal to itself)

## String Implementation

### Creation and Character Access

Strings can be created and accessed through various methods:

```mermaid
flowchart TD
    subgraph "String Creation and Access"
        A["Creation"] --> B["String literal"]
        A --> C["String.fromCharCode()"]
        A --> D["String.fromCharCodes()"]
        A --> E["String.fromCodePoint()"]
        
        F["Character Access"] --> G["charAt()/at()"]
        F --> H["charCodeAt()"]
        F --> I["codePointAt()"]
    end
```

Sources: [std/assembly/string.ts:14-83](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/string.ts:14-83#L14-L83)

Implementation details:
- `fromCharCode` creates a string from UTF-16 code units
- `fromCharCodes` converts an array of code units to a string
- `fromCodePoint` handles surrogate pairs for Unicode code points above 0xFFFF
- Character access methods handle bounds checking appropriately
- `codePointAt` properly combines surrogate pairs

### String Operations

Strings provide comprehensive functionality for text manipulation:

```mermaid
flowchart TD
    subgraph "String Operations"
        A["Concatenation"] --> B["concat()"]
        A --> C["operator +"]
        
        D["Substring Extraction"] --> E["slice()"]
        D --> F["substring()"]
        D --> G["substr()"]
        
        H["Search"] --> I["indexOf()"]
        H --> J["lastIndexOf()"]
        H --> K["includes()"]
        H --> L["startsWith()/endsWith()"]
        
        M["Modification"] --> N["replace()"]
        M --> O["replaceAll()"]
        M --> P["trim()/trimStart()/trimEnd()"]
        M --> Q["padStart()/padEnd()"]
        M --> R["repeat()"]
        
        S["Splitting"] --> T["split()"]
        
        U["Case Conversion"] --> V["toLowerCase()"]
        U --> W["toUpperCase()"]
    end
```

Sources: [std/assembly/string.ts:89-646](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/string.ts:89-646#L89-L646)

Implementation characteristics:
- String operations create new string instances (immutability)
- Memory is explicitly managed using `__new` and `__renew`
- Operations optimize for common cases (e.g., empty strings)
- Case conversion handles:
  - ASCII as a fast path
  - Full Unicode case mapping
  - Special cases like Greek sigma at the end of words
  - Surrogate pairs and character expansion

### String Encoding and Decoding

The String class provides specialized namespaces for encoding/decoding:

```mermaid
flowchart LR
    subgraph "String Encoding Utilities"
        A["String"] --> B["UTF8 Namespace"]
        A --> C["UTF16 Namespace"]
        
        B --> D["encode()"]
        B --> E["decode()"]
        B --> F["byteLength()"]
        B --> G["encodeUnsafe()/decodeUnsafe()"]
        
        C --> H["encode()"]
        C --> I["decode()"]
        C --> J["byteLength()"]
        C --> K["encodeUnsafe()/decodeUnsafe()"]
    end
```

Sources: [std/assembly/string.ts:661-843](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/string.ts:661-843#L661-L843)

Key functionality:
- UTF-8 encoding handles proper code point conversion to 1-4 bytes
- Surrogate pair detection and handling
- Error modes for invalid sequences (WTF8, REPLACE, ERROR)
- Optimized encoding/decoding paths for common patterns
- Support for null termination

## Integration with Runtime

Both Array and String interact with AssemblyScript's runtime system:

```mermaid
flowchart LR
    subgraph "Runtime Integration"
        A["Array/String Implementation"] --> B["Memory Management"]
        A --> C["Reference Tracking"]
        A --> D["Garbage Collection"]
        
        B --> E["__new / __renew"]
        C --> F["__link"]
        D --> G["__visit"]
    end
```

Sources: [std/assembly/array.ts:514-525](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/std/assembly/array.ts:514-525#L514-L525)

Integration points:
- Memory allocation via `__new` and `__renew`
- Arrays use `__link` to establish ownership of references they contain
- The `__visit` method supports garbage collection
- Efficient memory operations with `memory.copy` and `memory.fill`

## Performance Considerations

### Array Performance

- Arrays start with a minimum capacity of 8 elements
- Capacity doubles on reallocation to amortize costs
- Operations at the end of the array (`push`/`pop`) are more efficient than operations at the beginning (`unshift`/`shift`)
- Arrays with non-nullable reference types include null checking for type safety
- Methods that mutate the array in place are generally more efficient than those creating new arrays

### String Performance

- Strings are immutable, so all operations create new instances
- Comparison operations optimize common cases (same instance, different lengths)
- Case transformations use ASCII fast paths when possible
- String methods balance correctness (Unicode handling) with performance
- For extensive string building, concatenating multiple strings at once is more efficient than sequential concatenation

## Common Usage Patterns

Arrays and strings are fundamental data structures used throughout most applications:

```mermaid
flowchart TD
    subgraph "Common Usage Patterns"
        A["Collection Management"] --> B["Arrays for data storage"]
        A --> C["Arrays for algorithm implementation"]
        
        D["Text Processing"] --> E["String parsing and validation"]
        D --> F["Text transformation"]
        D --> G["String searching"]
        
        H["Data Conversion"] --> I["Array.join() for serialization"]
        H --> J["String.split() for parsing"]
        H --> K["String.UTF8 for encoding/decoding"]
    end
```

Sources: [tests/compiler/std/array.ts](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/tests/compiler/std/array.ts), [tests/compiler/std/string.ts](https://github.com/AssemblyScript/assemblyscript/blob/4e7734b8/tests/compiler/std/string.ts)

## Summary

The Array and String implementations in AssemblyScript provide essential functionality while maintaining memory efficiency and type safety. They are designed with careful attention to memory management, offering comprehensive APIs for data manipulation and transformation.