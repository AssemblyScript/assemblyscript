{"version":3,"sources":["webpack://thread/webpack/universalModuleDefinition","webpack://thread/webpack/bootstrap","webpack://thread/../loader/index.js","webpack://thread/./src/index.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,6DAA6D;AAC7D;AACA,+BAA+B;AAC/B,6BAA6B;AAC7B,sCAAsC;AACtC,sCAAsC;AACtC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS,kBAAkB,YAAY,WAAW,EAAE,EAAE;AACtD,SAAS,kBAAkB,YAAY,WAAW,EAAE,EAAE;AACtD,UAAU,kBAAkB,YAAY,YAAY,EAAE,EAAE;AACxD,UAAU,kBAAkB,YAAY,YAAY,EAAE,EAAE;AACxD,UAAU,kBAAkB,YAAY,YAAY,EAAE,EAAE;AACxD,UAAU,kBAAkB,YAAY,YAAY,EAAE,EAAE;AACxD,UAAU,kBAAkB,YAAY,YAAY,EAAE,EAAE;AACxD,UAAU,kBAAkB,YAAY,YAAY,EAAE,EAAE;AACxD,UAAU,kBAAkB,YAAY,YAAY,EAAE,EAAE;AACxD,UAAU,kBAAkB,YAAY,YAAY,EAAE;AACtD,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,oCAAoC,EAAE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0BAA0B,EAAE;AACzD,kCAAkC,0BAA0B,EAAE;AAC9D;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;ACzTa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,wCAAc;AACrC;AACA;AACA;AACA;AACA,2BAA2B,iDAAiD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAiE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,kBAAkB,SAAS;AAC3B;AACA,iCAAiC,2CAA2C,EAAE;AAC9E;AACA,wDAAwD,YAAY;AACpE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,8DAA8D,SAAS;AACvE;AACA,oDAAoD,QAAQ,gBAAgB,IAAI;AAChF,iBAAiB;AACjB,6CAA6C,kDAAkD,EAAE;AACjG;AACA;AACA,8BAA8B,WAAW,UAAU,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"thread\"] = factory();\n\telse\n\t\troot[\"thread\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\"use strict\";\n\nconst hasBigInt64 = typeof BigUint64Array !== \"undefined\";\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(U32, U16, ptr) {\n  var dataLength = U32[ptr >>> 2];\n  var dataOffset = (ptr + 4) >>> 1;\n  var dataRemain = dataLength;\n  var parts = [];\n  const chunkSize = 1024;\n  while (dataRemain > chunkSize) {\n    let last = U16[dataOffset + chunkSize - 1];\n    let size = last >= 0xD800 && last < 0xDC00 ? chunkSize - 1 : chunkSize;\n    let part = U16.subarray(dataOffset, dataOffset += size);\n    parts.push(String.fromCharCode.apply(String, part));\n    dataRemain -= size;\n  }\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(dataOffset, dataOffset + dataRemain));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  var baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    var buffer = memory.buffer;\n    return getStringImpl(new Uint32Array(buffer), new Uint16Array(buffer), ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  var env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    var memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    var memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  var rawExports = instance.exports;\n  var memory = rawExports.memory;\n  var memory_allocate = rawExports[\"memory.allocate\"];\n  var memory_fill = rawExports[\"memory.fill\"];\n  var memory_free = rawExports[\"memory.free\"];\n  var table = rawExports.table;\n  var setargc = rawExports._setargc || function() {};\n\n  // Provide views for all sorts of basic values\n  var buffer, I8, U8, I16, U16, I32, U32, F32, F64, I64, U64;\n\n  /** Updates memory views if memory has grown meanwhile. */\n  function checkMem() {\n    // see: https://github.com/WebAssembly/design/issues/1210\n    if (buffer !== memory.buffer) {\n      buffer = memory.buffer;\n      I8  = new Int8Array(buffer);\n      U8  = new Uint8Array(buffer);\n      I16 = new Int16Array(buffer);\n      U16 = new Uint16Array(buffer);\n      I32 = new Int32Array(buffer);\n      U32 = new Uint32Array(buffer);\n      if (hasBigInt64) {\n        I64 = new BigInt64Array(buffer);\n        U64 = new BigUint64Array(buffer);\n      }\n      F32 = new Float32Array(buffer);\n      F64 = new Float64Array(buffer);\n    }\n  }\n  checkMem();\n\n  /** Allocates a new string in the module's memory and returns its pointer. */\n  function newString(str) {\n    var dataLength = str.length;\n    var ptr = memory_allocate(4 + (dataLength << 1));\n    var dataOffset = (4 + ptr) >>> 1;\n    checkMem();\n    U32[ptr >>> 2] = dataLength;\n    for (let i = 0; i < dataLength; ++i) U16[dataOffset + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.newString = newString;\n\n  /** Gets a string from the module's memory by its pointer. */\n  function getString(ptr) {\n    checkMem();\n    return getStringImpl(U32, U16, ptr);\n  }\n\n  baseModule.getString = getString;\n\n  function computeBufferSize(byteLength) {\n    const HEADER_SIZE = 8;\n    return 1 << (32 - Math.clz32(byteLength + HEADER_SIZE - 1));\n  }\n\n  /** Creates a new typed array in the module's memory and returns its pointer. */\n  function newArray(view, length, unsafe) {\n    var ctor = view.constructor;\n    if (ctor === Function) { // TypedArray constructor created in memory\n      ctor = view;\n      view = null;\n    } else { // TypedArray instance copied into memory\n      if (length === undefined) length = view.length;\n    }\n    var elementSize = ctor.BYTES_PER_ELEMENT;\n    if (!elementSize) throw Error(\"not a typed array\");\n    var byteLength = elementSize * length;\n    var ptr = memory_allocate(12); // TypedArray header\n    var buf = memory_allocate(computeBufferSize(byteLength)); // ArrayBuffer\n    checkMem();\n    U32[ ptr      >>> 2] = buf;        // .buffer\n    U32[(ptr + 4) >>> 2] = 0;          // .byteOffset\n    U32[(ptr + 8) >>> 2] = byteLength; // .byteLength\n    U32[ buf      >>> 2] = byteLength; // .byteLength\n    U32[(buf + 4) >>> 2] = 0;          // 0\n    if (view) {\n      new ctor(buffer, buf + 8, length).set(view);\n      if (view.length < length && !unsafe) {\n        let setLength = elementSize * view.length;\n        memory_fill(buf + 8 + setLength, 0, byteLength - setLength);\n      }\n    } else if (!unsafe) {\n      memory_fill(buf + 8, 0, byteLength);\n    }\n    return ptr;\n  }\n\n  baseModule.newArray = newArray;\n\n  /** Gets a view on a typed array in the module's memory by its pointer. */\n  function getArray(ctor, ptr) {\n    var elementSize = ctor.BYTES_PER_ELEMENT;\n    if (!elementSize) throw Error(\"not a typed array\");\n    checkMem();\n    var buf        = U32[ ptr      >>> 2];\n    var byteOffset = U32[(ptr + 4) >>> 2];\n    var byteLength = U32[(ptr + 8) >>> 2];\n    return new ctor(buffer, buf + 8 + byteOffset, (byteLength - byteOffset) / elementSize);\n  }\n\n  baseModule.getArray = getArray;\n\n  /** Frees a typed array in the module's memory. Must not be accessed anymore afterwards. */\n  function freeArray(ptr) {\n    checkMem();\n    var buf = U32[ptr >>> 2];\n    memory_free(buf);\n    memory_free(ptr);\n  }\n\n  baseModule.freeArray = freeArray;\n\n  /**\n   * Creates a new function in the module's table and returns its pointer. Note that only actual\n   * WebAssembly functions, i.e. as exported by the module, are supported.\n   */\n  function newFunction(fn) {\n    if (typeof fn.original === \"function\") fn = fn.original;\n    var index = table.length;\n    table.grow(1);\n    table.set(index, fn);\n    return index;\n  }\n\n  baseModule.newFunction = newFunction;\n\n  /** Gets a function by its pointer. */\n  function getFunction(ptr) {\n    return wrapFunction(table.get(ptr), setargc);\n  }\n\n  baseModule.getFunction = getFunction;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table = baseModule.table || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, Object.defineProperties(baseModule, {\n    I8: { get: function() { checkMem(); return I8; } },\n    U8: { get: function() { checkMem(); return U8; } },\n    I16: { get: function() { checkMem(); return I16; } },\n    U16: { get: function() { checkMem(); return U16; } },\n    I32: { get: function() { checkMem(); return I32; } },\n    U32: { get: function() { checkMem(); return U32; } },\n    I64: { get: function() { checkMem(); return I64; } },\n    U64: { get: function() { checkMem(); return U64; } },\n    F32: { get: function() { checkMem(); return F32; } },\n    F64: { get: function() { checkMem(); return F64; } }\n  }));\n}\n\n/** Wraps a WebAssembly function while also taking care of variable arguments. */\nfunction wrapFunction(fn, setargc) {\n  var wrap = (...args) => {\n    setargc(args.length);\n    return fn(...args);\n  }\n  // adding a function to the table with `newFunction` is limited to actual WebAssembly functions,\n  // hence we can't use the wrapper and instead need to provide a reference to the original\n  wrap.original = fn;\n  return wrap;\n}\n\n/** Instantiates an AssemblyScript module using the specified imports. */\nfunction instantiate(module, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(module, imports)\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Instantiates an AssemblyScript module from a buffer using the specified imports. */\nfunction instantiateBuffer(buffer, imports) {\n  return instantiate(new WebAssembly.Module(buffer), imports);\n}\n\nexports.instantiateBuffer = instantiateBuffer;\n\n/** Instantiates an AssemblyScript module from a response using the specified imports. */\nasync function instantiateStreaming(response, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(response, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setargc = exports._setargc || function() {};\n  function hasOwnProperty(elem, prop) {\n    return Object.prototype.hasOwnProperty.call(elem, prop);\n  }\n  for (let internalName in exports) {\n    if (!hasOwnProperty(exports, internalName)) continue;\n    let elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!hasOwnProperty(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(...args));\n        };\n        ctor.prototype = {};\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { \"this\": { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!hasOwnProperty(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this.this); },\n            set: function(value) { setter(this.this, value); },\n            enumerable: true\n          });\n        }\n      } else {\n        curr[name] = wrapFunction(elem, setargc);\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!hasOwnProperty(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\") {\n        curr[name] = wrapFunction(elem, setargc);\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n\n  return module;\n}\n\nexports.demangle = demangle;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst loader = require(\"../../loader\");\n/** Cached compiled parser. */\nvar compiled = null;\nasync function fork(parent, worker) {\n    let newWorker = new Worker(\"./webworker.js\");\n    newWorker.postMessage({ command: \"fork\", memory: parent.memory, worker });\n    return newWorker;\n}\nlet notify = Atomics.wake;\nclass Thread {\n    constructor(address, wasm) {\n        this.address = address;\n        this.wasm = wasm;\n        Thread.thread = this;\n    }\n    static async create(address, memory = Thread.defaultMemory) {\n        let buf = await fetch(address);\n        let wasm = await WebAssembly.compile(await buf.arrayBuffer());\n        let thread = new Thread(address, wasm);\n        thread.instance = await thread.load(memory, wasm);\n        return thread;\n    }\n    static defaultMemory() {\n        return new WebAssembly.Memory({\n            initial: 256,\n            shared: true,\n            maximum: 256\n        });\n    }\n    fork(worker) {\n        let newWorker = new Worker(\"./webworker.js\");\n        let address = this.address;\n        let lastdot = address.lastIndexOf(\".\");\n        address = address.slice(0, lastdot) + \".wasm\";\n        newWorker.postMessage({ command: \"fork\", address: address, memory: this.memory, worker });\n        return newWorker;\n    }\n    async load(memory, mod) {\n        var wasm;\n        let instance;\n        if (typeof mod === \"string\") {\n            let buf = await fetch(mod);\n            wasm = await WebAssembly.compile(await buf.arrayBuffer());\n        }\n        else {\n            wasm = mod;\n        }\n        // var w = new Worker('worker.js'); // Standard API\n        var imports = {\n            env: { memory },\n            index: {\n                log_str: (x) => { return console.log(instance.getString(x)); },\n                fork: (worker) => {\n                    console.log(`Worker is located at ${worker >> 2}`);\n                    return this.fork(worker);\n                },\n                log: (type, x) => console.log(x),\n                wait: (ptr, value, timeout) => {\n                    if (timeout === -1) {\n                        timeout = Infinity;\n                    }\n                    console.log(`About to wait on location: ${ptr >> 2}`);\n                    let res = Atomics.wait(instance.I32, ptr >> 2, value, timeout);\n                    console.log(`Woken waiting on ${ptr / 4} with result: ${res}`);\n                },\n                notify: (ptr, numAgents) => { return notify(instance.I32, ptr >> 2, numAgents); },\n                print: console.log,\n                printMemory: (start = 0) => console.log(instance.I32.slice(start)),\n                debug: () => { let x = 1; debugger; },\n                loc: (x) => {\n                    console.log(\"getting location: \" + x);\n                    return x;\n                }\n            }\n        };\n        instance = await loader.instantiate(wasm, imports);\n        return instance;\n    }\n    start() {\n        this.instance.myStart();\n    }\n    startChild(id) {\n        this.id = id;\n        this.instance.startChild(id);\n    }\n    static onMessageReceived(e) {\n        try {\n            const data = e.data;\n            debugger;\n            switch (data.command) {\n                case \"start\": {\n                    (async (address) => {\n                        let thread = await Thread.create(address);\n                        thread.start();\n                        debugger;\n                    })(data.address);\n                    break;\n                }\n                case \"fork\": {\n                    (async function (address, memory, worker) {\n                        debugger;\n                        let thread = await Thread.create(address, memory);\n                        thread.startChild(worker);\n                    })(data.address, data.memory, data.worker);\n                    break;\n                }\n            }\n        }\n        catch (e) {\n            console.log(e);\n        }\n    }\n    get memory() {\n        return this.instance.memory;\n    }\n}\nexports.default = Thread;\naddEventListener(\"message\", Thread.onMessageReceived, false);\n"],"sourceRoot":""}