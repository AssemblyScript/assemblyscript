<<<<<<< master

=======
{"version":3,"sources":["webpack://asparse/webpack/universalModuleDefinition","webpack://asparse/webpack/bootstrap","webpack://asparse/./src/index.ts","webpack://asparse/./src/common.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","common_1","Type","SectionId","ExternalKind","compiled","parse","binary","options","WebAssembly","Module","string","length","charCodeAt","Math","ceil","buffer","Uint8Array","j","k","undefined","s64","Error","base64_decode","nBytes","nPages","memory","Memory","initial","set","readString","offset","start","end","parts","chunk","push","String","fromCharCode","apply","slice","join","utf8_read","readUint32","index","imports","env","forEach","Instance","Array","NameType","MAX_PAGES","MAX_ELEMS","Opcode"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"asparse\"] = factory();\n\telse\n\t\troot[\"asparse\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\"use strict\";\nexports.__esModule = true;\nvar common_1 = require(\"./common\");\nexports.Type = common_1.Type;\nexports.SectionId = common_1.SectionId;\nexports.ExternalKind = common_1.ExternalKind;\n/** Cached compiled parser. */\nvar compiled = null;\nif (typeof WASM_DATA !== \"string\")\n    WASM_DATA = require(\"fs\").readFileSync(__dirname + \"/../build/index.wasm\", \"base64\");\n/** Parses the contents of a WebAssembly binary according to the specified options. */\nfunction parse(binary, options) {\n    if (!options)\n        options = {};\n    // compile the parser if not yet compiled\n    if (!compiled)\n        compiled = new WebAssembly.Module(base64_decode(WASM_DATA));\n    // use the binary as the parser's memory\n    var nBytes = binary.length;\n    var nPages = ((nBytes + 0xffff) & ~0xffff) >> 16;\n    var memory = new WebAssembly.Memory({ initial: nPages });\n    var buffer = new Uint8Array(memory.buffer);\n    buffer.set(binary);\n    // provide a way to read strings from memory\n    parse.readString = function (offset, length) { return utf8_read(buffer, offset, offset + length); };\n    parse.readUint32 = function (index) {\n        return buffer[index];\n    };\n    // instantiate the parser and return its exports\n    var imports = {\n        env: {\n            memory: memory\n        },\n        options: {}\n    };\n    [\"onSection\",\n        \"onType\",\n        \"onTypeParam\",\n        \"onTypeReturn\",\n        \"onImport\",\n        \"onFunctionImport\",\n        \"onTableImport\",\n        \"onMemoryImport\",\n        \"onGlobalImport\",\n        \"onMemory\",\n        \"onFunction\",\n        \"onTable\",\n        \"onGlobal\",\n        \"onExport\",\n        \"onStart\",\n        \"onSourceMappingURL\",\n        \"onModuleName\",\n        \"onFunctionName\",\n        \"onLocalName\"\n    ].forEach(function (name) { return imports.options[name] = options[name] || function () { }; });\n    var instance = new WebAssembly.Instance(compiled, imports);\n    instance.exports.parse(0, nBytes);\n}\nexports.parse = parse;\n// see: https://github.com/dcodeIO/protobuf.js/tree/master/lib/utf8\nfunction utf8_read(buffer, start, end) {\n    var len = end - start;\n    if (len < 1)\n        return \"\";\n    var parts = null, chunk = [], i = 0, // char offset\n    t = 0; // temporary\n    while (start < end) {\n        t = buffer[start++];\n        if (t < 128) {\n            chunk[i++] = t;\n        }\n        else if (t > 191 && t < 224) {\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        }\n        else if (t > 239 && t < 365) {\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n            chunk[i++] = 0xD800 + (t >> 10);\n            chunk[i++] = 0xDC00 + (t & 1023);\n        }\n        else {\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        }\n        if (i > 8191) {\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n            i = 0;\n        }\n    }\n    if (parts) {\n        if (i)\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n    }\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\n}\n// see: https://github.com/dcodeIO/protobuf.js/tree/master/lib/base64\nfunction base64_decode(string) {\n    var length = string.length;\n    if (length) {\n        var n = 0, p = length;\n        while (--p % 4 > 1 && string.charCodeAt(p) === 61)\n            ++n;\n        length = Math.ceil(length * 3) / 4 - n;\n    }\n    var buffer = new Uint8Array(length);\n    var j = 0, o = 0, t = 0;\n    for (var i = 0, k = string.length; i < k;) {\n        var c = string.charCodeAt(i++);\n        if (c === 61 && j > 1)\n            break;\n        if ((c = s64[c]) === undefined)\n            throw Error();\n        switch (j) {\n            case 0: {\n                t = c;\n                j = 1;\n                break;\n            }\n            case 1: {\n                buffer[o++] = t << 2 | (c & 48) >> 4;\n                t = c;\n                j = 2;\n                break;\n            }\n            case 2: {\n                buffer[o++] = (t & 15) << 4 | (c & 60) >> 2;\n                t = c;\n                j = 3;\n                break;\n            }\n            case 3: {\n                buffer[o++] = (t & 3) << 6 | c;\n                j = 0;\n                break;\n            }\n        }\n    }\n    if (j === 1)\n        throw Error();\n    return buffer;\n}\nvar s64 = new Array(123);\nfor (var i = 0; i < 64;)\n    s64[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n","\"use strict\";\n/** Common constants shared between AssemblyScript and TypeScript. */\nexports.__esModule = true;\n/** WebAssembly types. */\nvar Type;\n(function (Type) {\n    Type[Type[\"i32\"] = 127] = \"i32\";\n    Type[Type[\"i64\"] = 126] = \"i64\";\n    Type[Type[\"f32\"] = 125] = \"f32\";\n    Type[Type[\"f64\"] = 124] = \"f64\";\n    Type[Type[\"anyfunc\"] = 112] = \"anyfunc\";\n    Type[Type[\"func\"] = 96] = \"func\";\n    Type[Type[\"none\"] = 64] = \"none\";\n})(Type = exports.Type || (exports.Type = {}));\n/** WebAssembly section ids. */\nvar SectionId;\n(function (SectionId) {\n    SectionId[SectionId[\"Custom\"] = 0] = \"Custom\";\n    SectionId[SectionId[\"Type\"] = 1] = \"Type\";\n    SectionId[SectionId[\"Import\"] = 2] = \"Import\";\n    SectionId[SectionId[\"Function\"] = 3] = \"Function\";\n    SectionId[SectionId[\"Table\"] = 4] = \"Table\";\n    SectionId[SectionId[\"Memory\"] = 5] = \"Memory\";\n    SectionId[SectionId[\"Global\"] = 6] = \"Global\";\n    SectionId[SectionId[\"Export\"] = 7] = \"Export\";\n    SectionId[SectionId[\"Start\"] = 8] = \"Start\";\n    SectionId[SectionId[\"Element\"] = 9] = \"Element\";\n    SectionId[SectionId[\"Code\"] = 10] = \"Code\";\n    SectionId[SectionId[\"Data\"] = 11] = \"Data\";\n})(SectionId = exports.SectionId || (exports.SectionId = {}));\n/** WebAssembly external kinds. */\nvar ExternalKind;\n(function (ExternalKind) {\n    ExternalKind[ExternalKind[\"Function\"] = 0] = \"Function\";\n    ExternalKind[ExternalKind[\"Table\"] = 1] = \"Table\";\n    ExternalKind[ExternalKind[\"Memory\"] = 2] = \"Memory\";\n    ExternalKind[ExternalKind[\"Global\"] = 3] = \"Global\";\n})(ExternalKind = exports.ExternalKind || (exports.ExternalKind = {}));\n/** Name section types. */\nvar NameType;\n(function (NameType) {\n    NameType[NameType[\"Module\"] = 0] = \"Module\";\n    NameType[NameType[\"Function\"] = 1] = \"Function\";\n    NameType[NameType[\"Local\"] = 2] = \"Local\";\n})(NameType = exports.NameType || (exports.NameType = {}));\n/** Maximum number of memory pages. */\nexports.MAX_PAGES = 0xffff;\n/** Maximum number of table elements. */\nexports.MAX_ELEMS = 0xffffffff;\n/** WebAssembly opcodes. */\nvar Opcode;\n(function (Opcode) {\n    // unreachable = 0x00,\n    // nop = 0x01,\n    // block = 0x02,\n    // loop = 0x03,\n    // if_ = 0x04,\n    // else_ = 0x05,\n    Opcode[Opcode[\"end\"] = 11] = \"end\";\n    // br = 0x0c,\n    // br_if = 0x0d,\n    // br_table = 0x0e,\n    // return_ = 0x0f,\n    // call = 0x10,\n    // call_indirect = 0x11,\n    // drop = 0x1a,\n    // select = 0x1b,\n    // get_local = 0x20,\n    // set_local = 0x21,\n    // tee_local = 0x22,\n    Opcode[Opcode[\"get_global\"] = 35] = \"get_global\";\n    // set_global = 0x24,\n    // i32_load = 0x28,\n    // i64_load = 0x29,\n    // f32_load = 0x2a,\n    // f64_load = 0x2b,\n    // i32_load8_s = 0x2c,\n    // i32_load8_u = 0x2d,\n    // i32_load16_s = 0x2e,\n    // i32_load16_u = 0x2f,\n    // i64_load8_s = 0x30,\n    // i64_load8_u = 0x31,\n    // i64_load16_s = 0x32,\n    // i64_load16_u = 0x33,\n    // i64_load32_s = 0x34,\n    // i64_load32_u = 0x35,\n    // i32_store = 0x36,\n    // i64_store = 0x37,\n    // f32_store = 0x38,\n    // f64_store = 0x39,\n    // i32_store8 = 0x3a,\n    // i32_store16 = 0x3b,\n    // i64_store8 = 0x3c,\n    // i64_store16 = 0x3d,\n    // i64_store32 = 0x3e,\n    // current_memory = 0x3f,\n    // grow_memory = 0x40,\n    Opcode[Opcode[\"i32_const\"] = 65] = \"i32_const\";\n    Opcode[Opcode[\"i64_const\"] = 66] = \"i64_const\";\n    Opcode[Opcode[\"f32_const\"] = 67] = \"f32_const\";\n    Opcode[Opcode[\"f64_const\"] = 68] = \"f64_const\";\n    // i32_eqz = 0x45,\n    // i32_eq = 0x46,\n    // i32_ne = 0x47,\n    // i32_lt_s = 0x48,\n    // i32_lt_u = 0x49,\n    // i32_gt_s = 0x4a,\n    // i32_gt_u = 0x4b,\n    // i32_le_s = 0x4c,\n    // i32_le_u = 0x4d,\n    // i32_ge_s = 0x4e,\n    // i32_ge_u = 0x4f,\n    // i64_eqz = 0x50,\n    // i64_eq = 0x51,\n    // i64_ne = 0x52,\n    // i64_lt_s = 0x53,\n    // i64_lt_u = 0x54,\n    // i64_gt_s = 0x55,\n    // i64_gt_u = 0x56,\n    // i64_le_s = 0x57,\n    // i64_le_u = 0x58,\n    // i64_ge_s = 0x59,\n    // i64_ge_u = 0x5a,\n    // f32_eq = 0x5b,\n    // f32_ne = 0x5c,\n    // f32_lt = 0x5d,\n    // f32_gt = 0x5e,\n    // f32_le = 0x5f,\n    // f32_ge = 0x60,\n    // f64_eq = 0x61,\n    // f64_ne = 0x62,\n    // f64_lt = 0x63,\n    // f64_gt = 0x64,\n    // f64_le = 0x65,\n    // f64_ge = 0x66,\n    // i32_clz = 0x67,\n    // i32_ctz = 0x68,\n    // i32_popcnt = 0x69,\n    // i32_add = 0x6a,\n    // i32_sub = 0x6b,\n    // i32_mul = 0x6c,\n    // i32_div_s = 0x6d,\n    // i32_div_u = 0x6e,\n    // i32_rem_s = 0x6f,\n    // i32_rem_u = 0x70,\n    // i32_and = 0x71,\n    // i32_or = 0x72,\n    // i32_xor = 0x73,\n    // i32_shl = 0x74,\n    // i32_shr_s = 0x75,\n    // i32_shr_u = 0x76,\n    // i32_rotl = 0x77,\n    // i32_rotr = 0x78,\n    // i64_clz = 0x79,\n    // i64_ctz = 0x7a,\n    // i64_popcnt = 0x7b,\n    // i64_add = 0x7c,\n    // i64_sub = 0x7d,\n    // i64_mul = 0x7e,\n    // i64_div_s = 0x7f,\n    // i64_div_u = 0x80,\n    // i64_rem_s = 0x81,\n    // i64_rem_u = 0x82,\n    // i64_and = 0x83,\n    // i64_or = 0x84,\n    // i64_xor = 0x85,\n    // i64_shl = 0x86,\n    // i64_shr_s = 0x87,\n    // i64_shr_u = 0x88,\n    // i64_rotl = 0x89,\n    // i64_rotr = 0x8a,\n    // f32_abs = 0x8b,\n    // f32_neg = 0x8c,\n    // f32_ceil = 0x8d,\n    // f32_floor = 0x8e,\n    // f32_trunc = 0x8f,\n    // f32_nearest = 0x90,\n    // f32_sqrt = 0x91,\n    // f32_add = 0x92,\n    // f32_sub = 0x93,\n    // f32_mul = 0x94,\n    // f32_div = 0x95,\n    // f32_min = 0x96,\n    // f32_max = 0x97,\n    // f32_copysign = 0x98,\n    // f64_abs = 0x99,\n    // f64_neg = 0x9a,\n    // f64_ceil = 0x9b,\n    // f64_floor = 0x9c,\n    // f64_trunc = 0x9d,\n    // f64_nearest = 0x9e,\n    // f64_sqrt = 0x9f,\n    // f64_add = 0xa0,\n    // f64_sub = 0xa1,\n    // f64_mul = 0xa2,\n    // f64_div = 0xa3,\n    // f64_min = 0xa4,\n    // f64_max = 0xa5,\n    // f64_copysign = 0xa6,\n    // i32_wrap_i64 = 0xa7,\n    // i32_trunc_s_f32 = 0xa8,\n    // i32_trunc_u_f32 = 0xa9,\n    // i32_trunc_s_f64 = 0xaa,\n    // i32_trunc_u_f64 = 0xab,\n    // i64_extend_s_i32 = 0xac,\n    // i64_extend_u_i32 = 0xad,\n    // i64_trunc_s_f32 = 0xae,\n    // i64_trunc_u_f32 = 0xaf,\n    // i64_trunc_s_f64 = 0xb0,\n    // i64_trunc_u_f64 = 0xb1,\n    // f32_convert_s_i32 = 0xb2,\n    // f32_convert_u_i32 = 0xb3,\n    // f32_convert_s_i64 = 0xb4,\n    // f32_convert_u_i64 = 0xb5,\n    // f32_demote_f64 = 0xb6,\n    // f64_convert_s_i32 = 0xb7,\n    // f64_convert_u_i32 = 0xb8,\n    // f64_convert_s_i64 = 0xb9,\n    // f64_convert_u_i64 = 0xba,\n    // f64_promote_f32 = 0xbb,\n    // i32_reinterpret_f32 = 0xbc,\n    // i64_reinterpret_f64 = 0xbd,\n    // f32_reinterpret_i32 = 0xbe,\n    // f64_reinterpret_i64 = 0xbf\n})(Opcode = exports.Opcode || (exports.Opcode = {}));\n"],"sourceRoot":""}
>>>>>>> new Branch for parser

=======
{"version":3,"sources":["webpack://asparse/webpack/universalModuleDefinition","webpack://asparse/webpack/bootstrap","webpack://asparse/./src/index.ts","webpack://asparse/./src/common.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","common_1","Type","SectionId","ExternalKind","compiled","parse","binary","options","WebAssembly","Module","string","length","charCodeAt","Math","ceil","buffer","Uint8Array","j","k","undefined","s64","Error","base64_decode","nBytes","nPages","memory","Memory","initial","set","readString","offset","start","end","parts","chunk","push","String","fromCharCode","apply","slice","join","utf8_read","readUint32","index","imports","env","forEach","Instance","Array","NameType","MAX_PAGES","MAX_ELEMS","Opcode"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"asparse\"] = factory();\n\telse\n\t\troot[\"asparse\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\"use strict\";\nexports.__esModule = true;\nvar common_1 = require(\"./common\");\nexports.Type = common_1.Type;\nexports.SectionId = common_1.SectionId;\nexports.ExternalKind = common_1.ExternalKind;\n/** Cached compiled parser. */\nvar compiled = null;\nif (typeof WASM_DATA !== \"string\")\n    WASM_DATA = require(\"fs\").readFileSync(__dirname + \"/../build/index.wasm\", \"base64\");\n/** Parses the contents of a WebAssembly binary according to the specified options. */\nfunction parse(binary, options) {\n    if (!options)\n        options = {};\n    // compile the parser if not yet compiled\n    if (!compiled)\n        compiled = new WebAssembly.Module(base64_decode(WASM_DATA));\n    // use the binary as the parser's memory\n    var nBytes = binary.length;\n    var nPages = ((nBytes + 0xffff) & ~0xffff) >> 16;\n    var memory = new WebAssembly.Memory({ initial: nPages });\n    var buffer = new Uint8Array(memory.buffer);\n    buffer.set(binary);\n    // provide a way to read strings from memory\n    parse.readString = function (offset, length) { return utf8_read(buffer, offset, offset + length); };\n    parse.readUint32 = function (index) {\n        return buffer[index];\n    };\n    // instantiate the parser and return its exports\n    var imports = {\n        env: {\n            memory: memory\n        },\n        options: {}\n    };\n    [\"onSection\",\n        \"onType\",\n        \"onTypeParam\",\n        \"onTypeReturn\",\n        \"onImport\",\n        \"onFunctionImport\",\n        \"onTableImport\",\n        \"onMemoryImport\",\n        \"onGlobalImport\",\n        \"onMemory\",\n        \"onFunction\",\n        \"onTable\",\n        \"onGlobal\",\n        \"onExport\",\n        \"onStart\",\n        \"onSourceMappingURL\",\n        \"onModuleName\",\n        \"onFunctionName\",\n        \"onLocalName\"\n    ].forEach(function (name) { return imports.options[name] = options[name] || function () { }; });\n    var instance = new WebAssembly.Instance(compiled, imports);\n    instance.exports.parse(0, nBytes);\n}\nexports.parse = parse;\n// see: https://github.com/dcodeIO/protobuf.js/tree/master/lib/utf8\nfunction utf8_read(buffer, start, end) {\n    var len = end - start;\n    if (len < 1)\n        return \"\";\n    var parts = null, chunk = [], i = 0, // char offset\n    t = 0; // temporary\n    while (start < end) {\n        t = buffer[start++];\n        if (t < 128) {\n            chunk[i++] = t;\n        }\n        else if (t > 191 && t < 224) {\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        }\n        else if (t > 239 && t < 365) {\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n            chunk[i++] = 0xD800 + (t >> 10);\n            chunk[i++] = 0xDC00 + (t & 1023);\n        }\n        else {\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        }\n        if (i > 8191) {\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n            i = 0;\n        }\n    }\n    if (parts) {\n        if (i)\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n    }\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\n}\n// see: https://github.com/dcodeIO/protobuf.js/tree/master/lib/base64\nfunction base64_decode(string) {\n    var length = string.length;\n    if (length) {\n        var n = 0, p = length;\n        while (--p % 4 > 1 && string.charCodeAt(p) === 61)\n            ++n;\n        length = Math.ceil(length * 3) / 4 - n;\n    }\n    var buffer = new Uint8Array(length);\n    var j = 0, o = 0, t = 0;\n    for (var i = 0, k = string.length; i < k;) {\n        var c = string.charCodeAt(i++);\n        if (c === 61 && j > 1)\n            break;\n        if ((c = s64[c]) === undefined)\n            throw Error();\n        switch (j) {\n            case 0: {\n                t = c;\n                j = 1;\n                break;\n            }\n            case 1: {\n                buffer[o++] = t << 2 | (c & 48) >> 4;\n                t = c;\n                j = 2;\n                break;\n            }\n            case 2: {\n                buffer[o++] = (t & 15) << 4 | (c & 60) >> 2;\n                t = c;\n                j = 3;\n                break;\n            }\n            case 3: {\n                buffer[o++] = (t & 3) << 6 | c;\n                j = 0;\n                break;\n            }\n        }\n    }\n    if (j === 1)\n        throw Error();\n    return buffer;\n}\nvar s64 = new Array(123);\nfor (var i = 0; i < 64;)\n    s64[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n","\"use strict\";\n/** Common constants shared between AssemblyScript and TypeScript. */\nexports.__esModule = true;\n/** WebAssembly types. */\nvar Type;\n(function (Type) {\n    Type[Type[\"i32\"] = 127] = \"i32\";\n    Type[Type[\"i64\"] = 126] = \"i64\";\n    Type[Type[\"f32\"] = 125] = \"f32\";\n    Type[Type[\"f64\"] = 124] = \"f64\";\n    Type[Type[\"anyfunc\"] = 112] = \"anyfunc\";\n    Type[Type[\"func\"] = 96] = \"func\";\n    Type[Type[\"none\"] = 64] = \"none\";\n})(Type = exports.Type || (exports.Type = {}));\n/** WebAssembly section ids. */\nvar SectionId;\n(function (SectionId) {\n    SectionId[SectionId[\"Custom\"] = 0] = \"Custom\";\n    SectionId[SectionId[\"Type\"] = 1] = \"Type\";\n    SectionId[SectionId[\"Import\"] = 2] = \"Import\";\n    SectionId[SectionId[\"Function\"] = 3] = \"Function\";\n    SectionId[SectionId[\"Table\"] = 4] = \"Table\";\n    SectionId[SectionId[\"Memory\"] = 5] = \"Memory\";\n    SectionId[SectionId[\"Global\"] = 6] = \"Global\";\n    SectionId[SectionId[\"Export\"] = 7] = \"Export\";\n    SectionId[SectionId[\"Start\"] = 8] = \"Start\";\n    SectionId[SectionId[\"Element\"] = 9] = \"Element\";\n    SectionId[SectionId[\"Code\"] = 10] = \"Code\";\n    SectionId[SectionId[\"Data\"] = 11] = \"Data\";\n})(SectionId = exports.SectionId || (exports.SectionId = {}));\n/** WebAssembly external kinds. */\nvar ExternalKind;\n(function (ExternalKind) {\n    ExternalKind[ExternalKind[\"Function\"] = 0] = \"Function\";\n    ExternalKind[ExternalKind[\"Table\"] = 1] = \"Table\";\n    ExternalKind[ExternalKind[\"Memory\"] = 2] = \"Memory\";\n    ExternalKind[ExternalKind[\"Global\"] = 3] = \"Global\";\n})(ExternalKind = exports.ExternalKind || (exports.ExternalKind = {}));\n/** Name section types. */\nvar NameType;\n(function (NameType) {\n    NameType[NameType[\"Module\"] = 0] = \"Module\";\n    NameType[NameType[\"Function\"] = 1] = \"Function\";\n    NameType[NameType[\"Local\"] = 2] = \"Local\";\n})(NameType = exports.NameType || (exports.NameType = {}));\n/** Maximum number of memory pages. */\nexports.MAX_PAGES = 0xffff;\n/** Maximum number of table elements. */\nexports.MAX_ELEMS = 0xffffffff;\n/** WebAssembly opcodes. */\nvar Opcode;\n(function (Opcode) {\n    // unreachable = 0x00,\n    // nop = 0x01,\n    // block = 0x02,\n    // loop = 0x03,\n    // if_ = 0x04,\n    // else_ = 0x05,\n    Opcode[Opcode[\"end\"] = 11] = \"end\";\n    // br = 0x0c,\n    // br_if = 0x0d,\n    // br_table = 0x0e,\n    // return_ = 0x0f,\n    // call = 0x10,\n    // call_indirect = 0x11,\n    // drop = 0x1a,\n    // select = 0x1b,\n    // get_local = 0x20,\n    // set_local = 0x21,\n    // tee_local = 0x22,\n    Opcode[Opcode[\"get_global\"] = 35] = \"get_global\";\n    // set_global = 0x24,\n    // i32_load = 0x28,\n    // i64_load = 0x29,\n    // f32_load = 0x2a,\n    // f64_load = 0x2b,\n    // i32_load8_s = 0x2c,\n    // i32_load8_u = 0x2d,\n    // i32_load16_s = 0x2e,\n    // i32_load16_u = 0x2f,\n    // i64_load8_s = 0x30,\n    // i64_load8_u = 0x31,\n    // i64_load16_s = 0x32,\n    // i64_load16_u = 0x33,\n    // i64_load32_s = 0x34,\n    // i64_load32_u = 0x35,\n    // i32_store = 0x36,\n    // i64_store = 0x37,\n    // f32_store = 0x38,\n    // f64_store = 0x39,\n    // i32_store8 = 0x3a,\n    // i32_store16 = 0x3b,\n    // i64_store8 = 0x3c,\n    // i64_store16 = 0x3d,\n    // i64_store32 = 0x3e,\n    // current_memory = 0x3f,\n    // grow_memory = 0x40,\n    Opcode[Opcode[\"i32_const\"] = 65] = \"i32_const\";\n    Opcode[Opcode[\"i64_const\"] = 66] = \"i64_const\";\n    Opcode[Opcode[\"f32_const\"] = 67] = \"f32_const\";\n    Opcode[Opcode[\"f64_const\"] = 68] = \"f64_const\";\n    // i32_eqz = 0x45,\n    // i32_eq = 0x46,\n    // i32_ne = 0x47,\n    // i32_lt_s = 0x48,\n    // i32_lt_u = 0x49,\n    // i32_gt_s = 0x4a,\n    // i32_gt_u = 0x4b,\n    // i32_le_s = 0x4c,\n    // i32_le_u = 0x4d,\n    // i32_ge_s = 0x4e,\n    // i32_ge_u = 0x4f,\n    // i64_eqz = 0x50,\n    // i64_eq = 0x51,\n    // i64_ne = 0x52,\n    // i64_lt_s = 0x53,\n    // i64_lt_u = 0x54,\n    // i64_gt_s = 0x55,\n    // i64_gt_u = 0x56,\n    // i64_le_s = 0x57,\n    // i64_le_u = 0x58,\n    // i64_ge_s = 0x59,\n    // i64_ge_u = 0x5a,\n    // f32_eq = 0x5b,\n    // f32_ne = 0x5c,\n    // f32_lt = 0x5d,\n    // f32_gt = 0x5e,\n    // f32_le = 0x5f,\n    // f32_ge = 0x60,\n    // f64_eq = 0x61,\n    // f64_ne = 0x62,\n    // f64_lt = 0x63,\n    // f64_gt = 0x64,\n    // f64_le = 0x65,\n    // f64_ge = 0x66,\n    // i32_clz = 0x67,\n    // i32_ctz = 0x68,\n    // i32_popcnt = 0x69,\n    // i32_add = 0x6a,\n    // i32_sub = 0x6b,\n    // i32_mul = 0x6c,\n    // i32_div_s = 0x6d,\n    // i32_div_u = 0x6e,\n    // i32_rem_s = 0x6f,\n    // i32_rem_u = 0x70,\n    // i32_and = 0x71,\n    // i32_or = 0x72,\n    // i32_xor = 0x73,\n    // i32_shl = 0x74,\n    // i32_shr_s = 0x75,\n    // i32_shr_u = 0x76,\n    // i32_rotl = 0x77,\n    // i32_rotr = 0x78,\n    // i64_clz = 0x79,\n    // i64_ctz = 0x7a,\n    // i64_popcnt = 0x7b,\n    // i64_add = 0x7c,\n    // i64_sub = 0x7d,\n    // i64_mul = 0x7e,\n    // i64_div_s = 0x7f,\n    // i64_div_u = 0x80,\n    // i64_rem_s = 0x81,\n    // i64_rem_u = 0x82,\n    // i64_and = 0x83,\n    // i64_or = 0x84,\n    // i64_xor = 0x85,\n    // i64_shl = 0x86,\n    // i64_shr_s = 0x87,\n    // i64_shr_u = 0x88,\n    // i64_rotl = 0x89,\n    // i64_rotr = 0x8a,\n    // f32_abs = 0x8b,\n    // f32_neg = 0x8c,\n    // f32_ceil = 0x8d,\n    // f32_floor = 0x8e,\n    // f32_trunc = 0x8f,\n    // f32_nearest = 0x90,\n    // f32_sqrt = 0x91,\n    // f32_add = 0x92,\n    // f32_sub = 0x93,\n    // f32_mul = 0x94,\n    // f32_div = 0x95,\n    // f32_min = 0x96,\n    // f32_max = 0x97,\n    // f32_copysign = 0x98,\n    // f64_abs = 0x99,\n    // f64_neg = 0x9a,\n    // f64_ceil = 0x9b,\n    // f64_floor = 0x9c,\n    // f64_trunc = 0x9d,\n    // f64_nearest = 0x9e,\n    // f64_sqrt = 0x9f,\n    // f64_add = 0xa0,\n    // f64_sub = 0xa1,\n    // f64_mul = 0xa2,\n    // f64_div = 0xa3,\n    // f64_min = 0xa4,\n    // f64_max = 0xa5,\n    // f64_copysign = 0xa6,\n    // i32_wrap_i64 = 0xa7,\n    // i32_trunc_s_f32 = 0xa8,\n    // i32_trunc_u_f32 = 0xa9,\n    // i32_trunc_s_f64 = 0xaa,\n    // i32_trunc_u_f64 = 0xab,\n    // i64_extend_s_i32 = 0xac,\n    // i64_extend_u_i32 = 0xad,\n    // i64_trunc_s_f32 = 0xae,\n    // i64_trunc_u_f32 = 0xaf,\n    // i64_trunc_s_f64 = 0xb0,\n    // i64_trunc_u_f64 = 0xb1,\n    // f32_convert_s_i32 = 0xb2,\n    // f32_convert_u_i32 = 0xb3,\n    // f32_convert_s_i64 = 0xb4,\n    // f32_convert_u_i64 = 0xb5,\n    // f32_demote_f64 = 0xb6,\n    // f64_convert_s_i32 = 0xb7,\n    // f64_convert_u_i32 = 0xb8,\n    // f64_convert_s_i64 = 0xb9,\n    // f64_convert_u_i64 = 0xba,\n    // f64_promote_f32 = 0xbb,\n    // i32_reinterpret_f32 = 0xbc,\n    // i64_reinterpret_f64 = 0xbd,\n    // f32_reinterpret_i32 = 0xbe,\n    // f64_reinterpret_i64 = 0xbf\n})(Opcode = exports.Opcode || (exports.Opcode = {}));\n"],"sourceRoot":""}
>>>>>>> new Branch for parser
