(function(e,t){'object'==typeof exports&&'object'==typeof module?module.exports=t(function(){try{return require('assemblyscript')}catch(t){}}(),require('./assemblyscript')):'function'==typeof define&&define.amd?define(['assemblyscript'],t):'object'==typeof exports?exports.asc=t(function(){try{return require('assemblyscript')}catch(t){}}(),require('./assemblyscript')):e.asc=t(e._,e[void 0])})('undefined'==typeof self?this:self,function(t,e){var r=Math.floor,o=Math.pow,s=Math.min;return function(e){function t(r){if(i[r])return i[r].exports;var s=i[r]={i:r,l:!1,exports:{}};return e[r].call(s.exports,s,s.exports,t),s.l=!0,s.exports}var i={};return t.m=e,t.c=i,t.d=function(e,i,r){t.o(e,i)||Object.defineProperty(e,i,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var i=e&&e.__esModule?function(){return e['default']}:function(){return e};return t.d(i,'a',i),i},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p='',t(t.s=3)}([function(e,t,i){t.nextTick=function(e){setTimeout(e,0)},t.platform=t.arch=t.execPath=t.title='browser',t.pid=1,t.browser=!0,t.env={},t.argv=[],t.binding=function(){throw new Error('No such module. (Possibly not yet loaded)')},function(){var e,r='/';t.cwd=function(){return r},t.chdir=function(t){e||(e=i(1)),r=e.resolve(t,r)}}(),t.exit=t.kill=t.umask=t.dlopen=t.uptime=t.memoryUsage=t.uvCounters=function(){},t.features={}},function(e,t,i){(function(e){function r(e,t){for(var r,s=0,o=e.length-1;0<=o;o--)r=e[o],'.'===r?e.splice(o,1):'..'===r?(e.splice(o,1),s++):s&&(e.splice(o,1),s--);if(t)for(;s--;s)e.unshift('..');return e}function o(e,t){if(e.filter)return e.filter(t);for(var r=[],s=0;s<e.length;s++)t(e[s],s,e)&&r.push(e[s]);return r}var i=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,n=function(e){return i.exec(e).slice(1)};t.resolve=function(){for(var t,s='',n=!1,a=arguments.length-1;-1<=a&&!n;a--){if(t=0<=a?arguments[a]:e.cwd(),'string'!=typeof t)throw new TypeError('Arguments to path.resolve must be strings');else if(!t)continue;s=t+'/'+s,n='/'===t.charAt(0)}return s=r(o(s.split('/'),function(e){return!!e}),!n).join('/'),(n?'/':'')+s||'.'},t.normalize=function(e){var i=t.isAbsolute(e),s='/'===a(e,-1);return e=r(o(e.split('/'),function(e){return!!e}),!i).join('/'),e||i||(e='.'),e&&s&&(e+='/'),(i?'/':'')+e},t.isAbsolute=function(e){return'/'===e.charAt(0)},t.join=function(){var e=Array.prototype.slice.call(arguments,0);return t.normalize(o(e,function(e){if('string'!=typeof e)throw new TypeError('Arguments to path.join must be strings');return e}).join('/'))},t.relative=function(e,r){function o(e){for(var t=0;t<e.length&&''===e[t];t++);for(var i=e.length-1;0<=i&&''===e[i];i--);return t>i?[]:e.slice(t,i-t+1)}e=t.resolve(e).substr(1),r=t.resolve(r).substr(1);for(var n=o(e.split('/')),a=o(r.split('/')),l=s(n.length,a.length),u=l,c=0;c<l;c++)if(n[c]!==a[c]){u=c;break}for(var i=[],c=u;c<n.length;c++)i.push('..');return i=i.concat(a.slice(u)),i.join('/')},t.sep='/',t.delimiter=':',t.dirname=function(e){var t=n(e),i=t[0],r=t[1];return i||r?(r&&(r=r.substr(0,r.length-1)),i+r):'.'},t.basename=function(e,t){var i=n(e)[2];return t&&i.substr(-1*t.length)===t&&(i=i.substr(0,i.length-t.length)),i},t.extname=function(e){return n(e)[3]};var a=function(e,t,i){return e.substr(t,i)}}).call(t,i(0))},function(e){var t=function(){return this}();try{t=t||Function('return this')()||(1,eval)('this')}catch(i){'object'==typeof window&&(t=window)}e.exports=t},function(e,t,i){e.exports=i(4)},function(e,t,i){(function(e,r){function s(e){const r={};return Object.keys(t.options).forEach((e)=>{const i=t.options[e];i.aliases&&((r.alias||(r.alias={}))[e]=i.aliases),void 0!==i.default&&((r.default||(r.default={}))[e]=i.default),'string'===i.type?(r.string||(r.string=[])).push(e):'boolean'===i.type&&(r.boolean||(r.boolean=[])).push(e)}),i(14)(e,r)}function o(e,t){for(var i,r=!1;null!=(i=d.nextDiagnostic(e));)t.write(d.formatDiagnostic(i,t.isTTY,!0)+f.EOL+f.EOL),d.isError(i)&&(r=!0);return r}function n(){return{readTime:0,readCount:0,writeTime:0,writeCount:0,parseTime:0,parseCount:0,compileTime:0,compileCount:0,emitTime:0,emitCount:0,validateTime:0,validateCount:0,optimizeTime:0,optimizeCount:0}}function a(t){const i=e.hrtime();t();const r=e.hrtime(i);return 1e9*r[0]+r[1]}function l(t,i){function r(e){return e?(e/1e6).toFixed(3)+' ms':'N/A'}(i||e.stdout).write(['I/O Read  : '+r(t.readTime,t.readCount),'I/O Write : '+r(t.writeTime,t.writeCount),'Parse     : '+r(t.parseTime,t.parseCount),'Compile   : '+r(t.compileTime,t.compileCount),'Emit      : '+r(t.emitTime,t.emitCount),'Validate  : '+r(t.validateTime,t.validateCount),'Optimize  : '+r(t.optimizeTime,t.optimizeCount)].join(f.EOL)+f.EOL)}const u=i(9),c=i(1),f=i(10);var d,p;try{d=i(11),p=!1;try{i(!function(){var t=new Error('Cannot find module "source-map-support"');throw t.code='MODULE_NOT_FOUND',t}()).install()}catch(t){}}catch(t){try{i(!function(){var t=new Error('Cannot find module "ts-node"');throw t.code='MODULE_NOT_FOUND',t}()).register({project:c.join('.','..','src')}),i(!function(){var t=new Error('Cannot find module "../src/glue/js"');throw t.code='MODULE_NOT_FOUND',t}()),d=i(!function(){var t=new Error('Cannot find module "../src"');throw t.code='MODULE_NOT_FOUND',t}()),p=!0}catch(t){d=i(12),p=!1}}t.isBundle=!0,t.isDev=p,t.version=t.isBundle?'0.5.0':i(!function(){var t=new Error('Cannot find module "../package.json"');throw t.code='MODULE_NOT_FOUND',t}()).version,t.options=i(13),t.sourceMapRoot='assemblyscript:///',t.libraryPrefix=d.LIBRARY_PREFIX,t.defaultOptimizeLevel=2,t.defaultShrinkLevel=1,t.libraryFiles=t.isBundle?{"(lib)/allocator/arena":'/////////////// A simple yet effective Arena Memory Allocator /////////////////\n\n// Provides a `reset_memory` function to reset the heap to its initial state. A\n// user has to make sure that there are no more references to cleared memory\n// afterwards. Always aligns to 8 bytes.\n\nconst ALIGN_LOG2: usize = 3;\nconst ALIGN_SIZE: usize = 1 << ALIGN_LOG2;\nconst ALIGN_MASK: usize = ALIGN_SIZE - 1;\n\nvar HEAP_OFFSET: usize = HEAP_BASE;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  if (!size) return 0;\n  var ptr = HEAP_OFFSET;\n  var off = (ptr + size + ALIGN_MASK) & ~ALIGN_MASK;\n  var avail = <usize>current_memory() << 16;\n  if (off > avail && grow_memory(\n    max(\n      (((off + 0xffff) & ~0xffff) - avail) >> 16, // minimum required pages\n      avail                                >> 16  // at least double memory\n    )\n  ) < 0) unreachable(); // out of memory\n  HEAP_OFFSET = off;\n  return ptr;\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  // nop\n}\n\n@global\nexport function reset_memory(): void {\n  HEAP_OFFSET = HEAP_BASE;\n}\n',"(lib)/allocator/emscripten":'///////////////////////// Emscripten Memory Allocator //////////////////////////\n\n// Uses Emscripten\'s exported _malloc and _free implementations, i.e., when\n// linking with Emscripten-compiled programs that already provide these.\n// Differs from \'system\' in that their names are prefixed with an underscore.\n\ndeclare function _malloc(size: usize): usize;\ndeclare function _free(ptr: usize): void;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  return _malloc(size);\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  _free(ptr);\n}\n\n@global\nexport { reset_memory } from "./none";\n',"(lib)/allocator/none":'export function allocate_memory(size: usize): usize {\n  throw new Error("not supported");\n}\n\nexport function free_memory(ptr: usize): void {\n  throw new Error("not supported");\n}\n\nexport function reset_memory(): void {\n  throw new Error("not supported");\n}\n',"(lib)/allocator/system":'/////////////////////////// System Memory Allocator ////////////////////////////\n\n// Uses the environment\'s malloc and free implementations, i.e., when linking\n// with other C-like programs that already provide these.\n\ndeclare function malloc(size: usize): usize;\ndeclare function free(ptr: usize): void;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  return malloc(size);\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  free(ptr);\n}\n\n@global\nexport { reset_memory } from "./none";\n',"(lib)/allocator/tlsf":'////////////// TLSF (Two-Level Segregate Fit) Memory Allocator ////////////////\n\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Block size interpretation (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u253C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u256B\u2500\u2534\u2500\u2534\u2500\u2524\n// \u2502 |                    FL                       \u2502 SB = SL + AL  \u2502 \u25C4\u2500 usize\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2500\u2518\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\nconst AL_BITS: u32 = sizeof<usize>() == sizeof<u32>() ? 2 : 3;\nconst AL_SIZE: usize = 1 << <usize>AL_BITS;\nconst AL_MASK: usize = AL_SIZE - 1;\n\nconst SL_BITS: u32 = 5;\nconst SL_SIZE: usize = 1 << <usize>SL_BITS;\n\nconst SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\nconst SB_SIZE: usize = 1 << <usize>SB_BITS;\nconst SB_MASK: usize = SB_SIZE - 1;\n\nconst FL_BITS: u32 = (sizeof<usize>() == sizeof<u32>()\n  ? 30 // ^= up to 1GB per block\n  : 32 // ^= up to 4GB per block\n) - SB_BITS;\n\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Block structure layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u253C\u2500\u253C\u2500\u2524\n// \u2502                          size                             \u2502L\u2502F\u2502 \u25C4\u2500\u2510\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2567\u2550\u2561   \u2502      \u2510\n// \u2502                        if free: \u25C4 prev                        \u2502 \u25C4\u2500\u2524 usize\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\n// \u2502                        if free: next \u25BA                        \u2502 \u25C4\u2500\u2524\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\n// \u2502                ... unused free space >= 0 ...                 \u2502   \u2502    = 0\n// \u251C \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2524   \u2502\n// \u2502                        if free: jump \u25B2                        \u2502 \u25C4\u2500\u2518\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 MIN SIZE \u2518\n// F: FREE, L: LEFT_FREE\n\n/** Tag indicating that this block is free. */\nconst FREE: usize = 1 << 0;\n/** Tag indicating that this block\'s left block is free. */\nconst LEFT_FREE: usize = 1 << 1;\n/** Mask to obtain all tags. */\nconst TAGS: usize = FREE | LEFT_FREE;\n\nassert(AL_BITS >= 2); // alignment must be large enough to store all tags\n\n/** Block structure. */\n@unmanaged\nclass Block {\n\n  /** Info field holding this block\'s size and tags. */\n  info: usize;\n\n  /** End offset of the {@link Block#info} field. User data starts here. */\n  static readonly INFO: usize = sizeof<usize>();\n\n  /** Previous free block, if any. Only valid if free. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free. */\n  next: Block | null;\n\n  /** Minimum size of a block, excluding {@link Block#info}. */\n  static readonly MIN_SIZE: usize = 3 * sizeof<usize>(); // prev + next + jump\n\n  /** Maximum size of a used block, excluding {@link Block#info}. */\n  static readonly MAX_SIZE: usize = 1 << (FL_BITS + SB_BITS);\n\n  /** Gets this block\'s left (free) block in memory. */\n  get left(): Block {\n    assert(this.info & LEFT_FREE); // must be free to contain a jump\n    return assert(\n      load<Block>(changetype<usize>(this) - sizeof<usize>())\n    ); // can\'t be null\n  }\n\n  /** Gets this block\'s right block in memory. */\n  get right(): Block {\n    assert(this.info & ~TAGS); // can\'t skip beyond the tail block\n    return assert(\n      changetype<Block>(\n        changetype<usize>(this) + Block.INFO + (this.info & ~TAGS)\n      )\n    ); // can\'t be null\n  }\n}\n\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Root structure layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524          \u2510\n// \u2502        0        |           flMap                            S\u2502 \u25C4\u2500\u2500\u2500\u2500\u2510\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u2502\n// \u2502                           slMap[0] S                          \u2502 \u25C4\u2500\u2510  \u2502\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502  \u2502\n// \u2502                           slMap[1]                            \u2502 \u25C4\u2500\u2524  \u2502\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  u32 \u2502\n// \u2502                              ...                              \u2502 \u25C4\u2500\u2524  \u2502\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502  \u2502\n// \u2502                           slMap[22] P                         \u2502 \u25C4\u2500\u2518  \u2502\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561    usize\n// \u2502                            head[0]                            \u2502 \u25C4\u2500\u2500\u2500\u2500\u2524\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2502\n// \u2502                              ...                              \u2502 \u25C4\u2500\u2500\u2500\u2500\u2524\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2502\n// \u2502                           head[736]                           \u2502 \u25C4\u2500\u2500\u2500\u2500\u2524\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u2502\n// \u2502                            tailRef                            \u2502 \u25C4\u2500\u2500\u2500\u2500\u2518\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   SIZE   \u2518\n// S: Small blocks map, P: Possibly padded if 64-bit\n\nassert((1 << SL_BITS) <= 32); // second level must fit into 32 bits\n\n/** Root structure. */\n@unmanaged\nclass Root {\n\n  /** First level bitmap. */\n  flMap: usize = 0;\n\n  /** Start offset of second level maps. */\n  private static readonly SL_START: usize = sizeof<usize>();\n\n  // Using *one* SL map per *FL bit*\n\n  /** Gets the second level map for the specified first level. */\n  getSLMap(fl: usize): u32 {\n    assert(fl < FL_BITS); // fl out of range\n    return load<u32>(changetype<usize>(this) + fl * 4, Root.SL_START);\n  }\n\n  /** Sets the second level map for the specified first level. */\n  setSLMap(fl: usize, value: u32): void {\n    assert(fl < FL_BITS); // fl out of range\n    store<u32>(changetype<usize>(this) + fl * 4, value, Root.SL_START);\n  }\n\n  /** End offset of second level maps. */\n  private static readonly SL_END: usize = Root.SL_START + FL_BITS * 4;\n\n  // Using *number bits per SL* heads per *FL bit*\n\n  /** Start offset of FL/SL heads. */\n  private static readonly HL_START: usize = (Root.SL_END + AL_MASK) & ~AL_MASK;\n\n  /** Gets the head of the specified first and second level index. */\n  getHead(fl: usize, sl: u32): Block | null {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    return changetype<Block>(load<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , Root.HL_START));\n  }\n\n  /** Sets the head of the specified first and second level index. */\n  setHead(fl: usize, sl: u32, value: Block | null): void {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    store<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , changetype<usize>(value)\n    , Root.HL_START);\n  }\n\n  /** End offset of FL/SL heads. */\n  private static readonly HL_END: usize = (\n    Root.HL_START + FL_BITS * SL_SIZE * sizeof<usize>()\n  );\n\n  get tailRef(): usize { return load<usize>(0, Root.HL_END); }\n  set tailRef(value: usize) { store<usize>(0, value, Root.HL_END); }\n\n  /** Total size of the {@link Root} structure. */\n  static readonly SIZE: usize = Root.HL_END + sizeof<usize>();\n\n  /** Inserts a previously used block back into the free list. */\n  insert(block: Block): void {\n    // check as much as possible here to prevent invalid free blocks\n    assert(block); // cannot be null\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size: usize;\n    assert(\n      (size = block.info & ~TAGS) >= Block.MIN_SIZE && size < Block.MAX_SIZE\n    ); // must be valid, not necessary to compute yet if noAssert=true\n\n    var right: Block = assert(block.right); // can\'t be null\n    var rightInfo = right.info;\n\n    // merge with right block if also free\n    if (rightInfo & FREE) {\n      this.remove(right);\n      block.info = (blockInfo += Block.INFO + (rightInfo & ~TAGS));\n      right = block.right;\n      rightInfo = right.info;\n      // jump is set below\n    }\n\n    // merge with left block if also free\n    if (blockInfo & LEFT_FREE) {\n      var left: Block = assert(block.left); // can\'t be null\n      var leftInfo = left.info;\n      assert(leftInfo & FREE); // must be free according to tags\n      this.remove(left);\n      left.info = (leftInfo += Block.INFO + (blockInfo & ~TAGS));\n      block = left;\n      blockInfo = leftInfo;\n      // jump is set below\n    }\n\n    right.info = rightInfo | LEFT_FREE;\n    this.setJump(block, right);\n    // right is no longer used now, hence rightInfo is not synced\n\n    size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // perform insertion\n    var head = this.getHead(fl, sl);\n    block.prev = null;\n    block.next = head;\n    if (head) head.prev = block;\n    this.setHead(fl, sl, block);\n\n    // update first and second level maps\n    this.flMap |= (1 << fl);\n    this.setSLMap(fl, this.getSLMap(fl) | (1 << sl));\n  }\n\n  /**\n   * Removes a free block from FL/SL maps. Does not alter left/jump because it\n   * is likely that splitting is performed afterwards, invalidating any changes\n   * again.\n   */\n  private remove(block: Block): void {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // link previous and next free block\n    var prev = block.prev;\n    var next = block.next;\n    if (prev)\n      prev.next = next;\n    if (next)\n      next.prev = prev;\n\n    // update head if we are removing it\n    if (block == this.getHead(fl, sl)) {\n      this.setHead(fl, sl, next);\n\n      // clear second level map if head is empty now\n      if (!next) {\n        var slMap = this.getSLMap(fl);\n        this.setSLMap(fl, slMap &= ~(1 << sl));\n\n        // clear first level map if second level is empty now\n        if (!slMap)\n          this.flMap &= ~(1 << fl);\n      }\n    }\n  }\n\n  /** Searches for a free block of at least the specified size. */\n  search(size: usize): Block | null {\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE);\n\n    // mapping_search\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      // (*) size += (1 << (fls<usize>(size) - SL_BITS)) - 1;\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n      // (*) instead of rounding up, use next second level list for better fit\n      if (sl < SL_SIZE - 1) ++sl;\n      else ++fl, sl = 0;\n    }\n\n    // search second level\n    var slMap = this.getSLMap(fl) & (~0 << sl);\n    var head: Block | null;\n    if (!slMap) {\n      // search next larger first level\n      var flMap = this.flMap & (~0 << (fl + 1));\n      if (!flMap) {\n        head = null;\n      } else {\n        fl = ffs<usize>(flMap);\n        slMap = assert(this.getSLMap(fl)); // can\'t be zero if fl points here\n        head = this.getHead(fl, ffs<u32>(slMap));\n      }\n    } else\n      head = this.getHead(fl, ffs<u32>(slMap));\n\n      return head;\n  }\n\n  /** Links a free left with its right block in memory. */\n  private setJump(left: Block, right: Block): void {\n    assert(left.info & FREE);       // must be free\n    assert(left.right == right);    // right block must match\n    assert(right.info & LEFT_FREE); // right block must be tagged as LEFT_FREE\n    store<Block>(\n      changetype<usize>(right) - sizeof<usize>()\n    , left); // last word in left block\'s (free) data region\n  }\n\n  /**\n   * Uses the specified free block, removing it from internal maps and\n   * splitting it if possible, and returns its data pointer.\n   */\n  use(block: Block, size: usize): usize {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free so we can use it\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n    assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n    this.remove(block);\n\n    // split if the block can hold another MIN_SIZE block\n    var remaining = (blockInfo & ~TAGS) - size;\n    if (remaining >= Block.INFO + Block.MIN_SIZE) {\n      block.info = size | (blockInfo & LEFT_FREE); // also discards FREE\n\n      var spare = changetype<Block>(\n        changetype<usize>(block) + Block.INFO + size\n      );\n      spare.info = (remaining - Block.INFO) | FREE; // not LEFT_FREE\n      this.insert(spare); // also sets jump\n\n    // otherwise tag block as no longer FREE and right as no longer LEFT_FREE\n    } else {\n      block.info = blockInfo & ~FREE;\n      var right: Block = assert(block.right); // can\'t be null (tail)\n      right.info &= ~LEFT_FREE;\n    }\n\n    return changetype<usize>(block) + Block.INFO;\n  }\n\n  /** Adds more memory to the pool. */\n  addMemory(start: usize, end: usize): bool {\n    assert(start <= end);\n    assert(!(start & AL_MASK)); // must be aligned\n    assert(!(end & AL_MASK)); // must be aligned\n\n    var tailRef = this.tailRef;\n    var tailInfo: usize = 0;\n    if (tailRef) {\n      assert(start >= tailRef + sizeof<usize>()); // starts after tail\n\n      // merge with current tail if adjacent\n      if (start - Block.INFO == tailRef) {\n        start -= Block.INFO;\n        tailInfo = changetype<Block>(tailRef).info;\n      }\n\n    } else\n      assert(start >= changetype<usize>(this) + Root.SIZE); // starts after root\n\n    // check if size is large enough for a free block and the tail block\n    var size = end - start;\n    if (size < Block.INFO + Block.MIN_SIZE + Block.INFO)\n      return false;\n\n    // left size is total minus its own and the zero-length tail\'s header\n    var leftSize = size - 2 * Block.INFO;\n    var left = changetype<Block>(start);\n    left.info = leftSize | FREE | (tailInfo & LEFT_FREE);\n    left.prev = null;\n    left.next = null;\n\n    // tail is a zero-length used block\n    var tail = changetype<Block>(start + size - Block.INFO);\n    tail.info = 0 | LEFT_FREE;\n    this.tailRef = changetype<usize>(tail);\n\n    this.insert(left); // also merges with free left before tail / sets jump\n\n    return true;\n  }\n}\n\n/** Determines the first (LSB to MSB) set bit\'s index of a word. */\nfunction ffs<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  return ctz<T>(word);  // differs from ffs only for 0\n}\n\n/** Determines the last (LSB to MSB) set bit\'s index of a word. */\nfunction fls<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  const inv: T = (sizeof<T>() << 3) - 1;\n  return inv - clz<T>(word);\n}\n\n/** Reference to the initialized {@link Root} structure, once initialized. */\nvar ROOT: Root = changetype<Root>(0);\n\n// External interface\n\n/** Allocates a chunk of memory. */\n@global\nexport function allocate_memory(size: usize): usize {\n\n  // initialize if necessary\n  var root = ROOT;\n  if (!root) {\n    var rootOffset = (HEAP_BASE + AL_MASK) & ~AL_MASK;\n    ROOT = root = changetype<Root>(rootOffset);\n    root.tailRef = 0;\n    root.flMap = 0;\n    for (var fl: usize = 0; fl < FL_BITS; ++fl) {\n      root.setSLMap(fl, 0);\n      for (var sl: u32 = 0; sl < SL_SIZE; ++sl)\n        root.setHead(fl, sl, null);\n    }\n    root.addMemory(rootOffset + Root.SIZE, current_memory() << 16);\n  }\n\n  // search for a suitable block\n  var data: usize = 0;\n  if (size && size < Block.MAX_SIZE) {\n    size = max<usize>((size + AL_MASK) & ~AL_MASK, Block.MIN_SIZE);\n\n    var block = root.search(size);\n    if (!block) {\n\n      // request more memory\n      var pagesBefore = current_memory();\n      var pagesWanted = max(pagesBefore, ((size + 0xffff) & ~0xffff) >>> 16);\n      if (grow_memory(pagesWanted) < 0)\n        unreachable(); // out of memory\n      var pagesAfter = current_memory();\n      root.addMemory(<usize>pagesBefore << 16, <usize>pagesAfter << 16);\n      block = assert(root.search(size)); // must be found now\n    }\n\n    assert((block.info & ~TAGS) >= size);\n    data = root.use(block, size);\n  }\n\n  return data;\n}\n\n/** Frees the chunk of memory at the specified address. */\n@global\nexport function free_memory(data: usize): void {\n  if (data) {\n    var root = ROOT;\n    if (root) {\n      var block = changetype<Block>(data - Block.INFO);\n      var blockInfo = block.info;\n      assert(!(blockInfo & FREE)); // must be used\n      block.info = blockInfo | FREE;\n      root.insert(changetype<Block>(data - Block.INFO));\n    }\n  }\n}\n\nexport { reset_memory } from "./none";\n',"(lib)/array":'export class Array<T> {\n\n  private __memory: usize;\n  private __capacity: i32;  // capped to [0, 0x7fffffff]\n  private __length: i32;    // capped to [0, __capacity]\n\n  private __grow(newCapacity: i32): void {\n    assert(newCapacity > this.__capacity);\n    var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\n    if (this.__memory) {\n      move_memory(newMemory, this.__memory, this.__capacity * sizeof<T>());\n      free_memory(this.__memory);\n    }\n    this.__memory = newMemory;\n    this.__capacity = newCapacity;\n  }\n\n  constructor(capacity: i32 = 0) {\n    if (capacity < 0)\n      throw new RangeError("Invalid array length");\n    this.__memory = capacity ? allocate_memory(<usize>capacity * sizeof<T>()) : 0;\n    this.__capacity = this.__length = capacity;\n  }\n\n  get length(): i32 {\n    return this.__length;\n  }\n\n  set length(length: i32) {\n    if (length < 0)\n      throw new RangeError("Invalid array length");\n    if (length > this.__capacity)\n      this.__grow(max(length, this.__capacity << 1));\n    this.__length = length;\n  }\n\n  @operator("[]")\n  private __get(index: i32): T {\n    if (<u32>index >= this.__capacity)\n      throw new Error("Index out of bounds"); // return changetype<T>(0) ?\n    return load<T>(this.__memory + <usize>index * sizeof<T>());\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: T): void {\n    if (index < 0)\n      throw new Error("Index out of bounds");\n    if (index >= this.__capacity)\n      this.__grow(max(index + 1, this.__capacity << 1));\n    store<T>(this.__memory + <usize>index * sizeof<T>(), value);\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    if (fromIndex < 0)\n      fromIndex = this.__length + fromIndex;\n    while (<u32>fromIndex < this.__length) {\n      if (load<T>(this.__memory + fromIndex * sizeof<T>()) == searchElement)\n        return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    if (fromIndex < 0)\n      fromIndex = this.__length + fromIndex;\n    else if (fromIndex >= this.__length)\n      fromIndex = this.__length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(this.__memory + fromIndex * sizeof<T>()) == searchElement)\n        return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(element: T): i32 {\n    if (this.__length == this.__capacity)\n      this.__grow(this.__capacity ? this.__capacity << 1 : 1);\n    store<T>(this.__memory + this.__length * sizeof<T>(), element);\n    return ++this.__length;\n  }\n\n  pop(): T {\n    if (this.__length < 1)\n      throw new RangeError("Array is empty"); // return changetype<T>(0) ?\n    return load<T>(this.__memory + --this.__length * sizeof<T>());\n  }\n\n  shift(): T {\n    if (this.__length < 1)\n      throw new RangeError("Array is empty"); // return changetype<T>(0) ?\n    var element = load<T>(this.__memory);\n    move_memory(this.__memory, this.__memory + sizeof<T>(), (this.__capacity - 1) * sizeof<T>());\n    set_memory(this.__memory + (this.__capacity - 1) * sizeof<T>(), 0, sizeof<T>());\n    --this.__length;\n    return element;\n  }\n\n  unshift(element: T): i32 {\n    var oldCapacity = this.__capacity;\n    if (this.__length == oldCapacity) {\n      // inlined __grow (avoids moving twice)\n      var newCapacity: i32 = oldCapacity ? oldCapacity << 1 : 1;\n      assert(newCapacity > this.__capacity);\n      var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\n      if (this.__memory) {\n        move_memory(newMemory + sizeof<T>(), this.__memory, oldCapacity * sizeof<T>());\n        free_memory(this.__memory);\n      }\n      this.__memory = newMemory;\n      this.__capacity = newCapacity;\n    } else\n      move_memory(this.__memory + sizeof<T>(), this.__memory, oldCapacity * sizeof<T>());\n    store<T>(this.__memory, element);\n    return ++this.__length;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (begin < 0) {\n      begin = this.__length + begin;\n      if (begin < 0)\n        begin = 0;\n    } else if (begin > this.__length)\n      begin = this.__length;\n    if (end < 0)\n      end = this.__length + end;\n    else if (end > this.__length)\n      end = this.__length;\n    if (end < begin)\n      end = begin;\n    var capacity = end - begin;\n    assert(capacity >= 0);\n    var sliced = new Array<T>(capacity);\n    if (capacity)\n      move_memory(sliced.__memory, this.__memory + <usize>begin * sizeof<T>(), <usize>capacity * sizeof<T>());\n    return sliced;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): void {\n    if (deleteCount < 1)\n      return;\n    if (start < 0) {\n      start = this.__length + start;\n      if (start < 0)\n        start = 0;\n      else if (start >= this.__length)\n        return;\n    } else if (start >= this.__length)\n      return;\n    deleteCount = min(deleteCount, this.__length - start);\n    move_memory(this.__memory + <usize>start * sizeof<T>(), this.__memory + <usize>(start + deleteCount) * sizeof<T>(), deleteCount * sizeof<T>());\n    this.__length -= deleteCount;\n  }\n\n  reverse(): Array<T> {\n    for (var front: usize = 0, back: usize = <usize>this.__length - 1; front < back; ++front, --back) {\n      var temp = load<T>(this.__memory + front * sizeof<T>());\n      store<T>(this.__memory + front * sizeof<T>(), load<T>(this.__memory + back * sizeof<T>()));\n      store<T>(this.__memory + back * sizeof<T>(), temp);\n    }\n    return this;\n  }\n}\n\n@unmanaged\nexport class CArray<T> {\n\n  private constructor() {}\n\n  @operator("[]")\n  private __get(index: i32): T {\n    if (index < 0)\n      throw new RangeError("Index out of range");\n    return load<T>(changetype<usize>(this) + <usize>index * sizeof<T>());\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: T): void {\n    if (index < 0)\n      throw new RangeError("Index out of range");\n    store<T>(changetype<usize>(this) + <usize>index * sizeof<T>(), value);\n  }\n}\n',"(lib)/builtins":'@builtin\nexport declare const NaN: f64; // | f32\n\n@builtin\nexport declare const Infinity: f64; // | f32\n\n@builtin\nexport declare function isNaN<T>(value: T): bool;\n\n@builtin\nexport declare function isFinite<T>(value: T): bool;\n\n@builtin\nexport declare function clz<T>(value: T): T;\n\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n@builtin\nexport declare function abs<T>(value: T): T;\n\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n@builtin\nexport declare function floor<T>(value: T): T;\n\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n@builtin\nexport declare function nearest<T>(left: T, right: T): T;\n\n@builtin\nexport declare function reinterpret<T>(value: void): T;\n\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n@builtin\nexport declare function load<T>(offset: usize, constantOffset?: usize): T;\n\n@builtin\nexport declare function store<T>(offset: usize, value: void, constantOffset?: usize): T;\n\n@builtin\nexport declare function sizeof<T>(): usize;\n\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n@builtin\nexport declare function unreachable(): void;\n\n@builtin\nexport declare function current_memory(): i32;\n\n@builtin\nexport declare function grow_memory(pages: i32): i32;\n\n// @builtin\n// export declare function move_memory(dest: usize, src: usize: n: usize): void;\n\n// @builtin\n// export declare function set_memory(dest: usize, value: u32, n: usize): void;\n\n@builtin\nexport declare function changetype<T>(value: void): T;\n\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n@builtin\nexport declare function abort(message?: string | null, fileName?: string | null, lineNumber?: u32, columnNumber?: u32): void;\n\n@builtin\ndeclare function i8(value: void): i8;\nnamespace i8 {\n  export const MIN_VALUE: i8 = -128;\n  export const MAX_VALUE: i8 = 127;\n}\nexport { i8 };\n\n@builtin\ndeclare function i16(value: void): i16;\nnamespace i16 {\n  export const MIN_VALUE: i16 = -32768;\n  export const MAX_VALUE: i16 = 32767;\n}\nexport { i16 };\n\n@builtin\ndeclare function i32(value: void): i32;\nnamespace i32 {\n  export const MIN_VALUE: i32 = -2147483648;\n  export const MAX_VALUE: i32 = 2147483647;\n}\nexport { i32 };\n\n@builtin\ndeclare function i64(value: void): i64;\nnamespace i64 {\n  export const MIN_VALUE: i64 = -9223372036854775808;\n  export const MAX_VALUE: i64 = 9223372036854775807;\n}\nexport { i64 };\n\n@builtin\ndeclare function isize(value: void): isize;\nnamespace isize {\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>() ? -2147483648 : <usize>-9223372036854775808;\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>() ? 2147483647 : <usize>9223372036854775807;\n}\nexport { isize };\n\n@builtin\ndeclare function u8(value: void): u8;\nnamespace u8 {\n  export const MIN_VALUE: u8 = 0;\n  export const MAX_VALUE: u8 = 255;\n}\nexport { u8 };\n\n@builtin\ndeclare function u16(value: void): u16;\nnamespace u16 {\n  export const MIN_VALUE: u16 = 0;\n  export const MAX_VALUE: u16 = 65535;\n}\nexport { u16 };\n\n@builtin\ndeclare function u32(value: void): u32;\nnamespace u32 {\n  export const MIN_VALUE: u32 = 0;\n  export const MAX_VALUE: u32 = 4294967295;\n}\nexport { u32 };\n\n@builtin\ndeclare function u64(value: void): u64;\nnamespace u64 {\n  export const MIN_VALUE: u64 = 0;\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\nexport { u64 };\n\n@builtin\ndeclare function usize(value: void): usize;\nnamespace usize {\n  export const MIN_VALUE: usize = 0;\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>() ? 4294967295 : <usize>18446744073709551615;\n}\nexport { usize };\n\n@builtin\ndeclare function bool(value: void): bool;\nnamespace bool {\n  export const MIN_VALUE: bool = 0;\n  export const MAX_VALUE: bool = 1;\n}\nexport { bool };\n\n@builtin\ndeclare function f32(value: void): f32;\nnamespace f32 {\n  export const MIN_VALUE: f32 = -3.40282347e+38;\n  export const MAX_VALUE: f32 = 3.40282347e+38;\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n  export const MAX_SAFE_INTEGER: f32 = 16777215;\n  export const EPSILON: f32 = 1.19209290e-07;\n}\nexport { f32 };\n\n@builtin\ndeclare function f64(value: void): f64;\nnamespace f64 {\n  export const MIN_VALUE: f64 = -1.7976931348623157e+308;\n  export const MAX_VALUE: f64 = 1.7976931348623157e+308;\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n  export const MAX_SAFE_INTEGER: f64 = 9007199254740991;\n  export const EPSILON: f64 = 2.2204460492503131e-16;\n}\nexport{ f64 };\n\n@builtin\nexport declare const HEAP_BASE: usize;\n\n@builtin\nexport declare function start(): void;\n',"(lib)/error":'export class Error {\n\n  name: string = "Error";\n  message: string;\n  stack: string = ""; // TODO\n\n  constructor(message: string = "") {\n    this.message = message;\n  }\n}\n\nexport class RangeError extends Error {\n  name: string = "RangeError";\n}\n',"(lib)/iterator":'// export abstract class Iterator<T> {\n//   abstract get done(): bool;\n//   abstract next(): T;\n// }\n',"(lib)/map":'export class Map<K,V> {\n\n  private __keys: K[] = [];\n  private __values: V[] = [];\n\n  // FIXME: not a proper map implementation, just a filler\n\n  get size(): i32 {\n    return this.__keys.length;\n  }\n\n  get(key: K): V | null {\n    var keys = this.__keys;\n    for (var i = 0, k = keys.length; i < k; ++i)\n      if (keys[i] == key)\n        return this.__values[i];\n    return null;\n  }\n\n  has(key: K): bool {\n    var keys = this.__keys;\n    for (var i = 0, k = keys.length; i < k; ++i)\n      if (keys[i] == key)\n        return true;\n    return false;\n  }\n\n  set(key: K, value: V): void {\n    this.__keys.push(key);\n    this.__values.push(value);\n  }\n\n  clear(): void {\n    this.__keys.length = 0;\n    this.__values.length = 0;\n  }\n}\n',"(lib)/memory":'function copy_memory(dest: usize, src: usize, n: usize): void {\n  // based on musl\'s implementation of memcpy\n  // not a future instruction and sufficiently covered by the upcoming move_memory intrinsic\n\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1:\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      case 2:\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      case 3:\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\nexport function move_memory(dest: usize, src: usize, n: usize): void {\n  // based on musl\'s implementation of memmove\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\n\n  if (dest == src)\n    return;\n  if (src + n <= dest || dest + n <= src) {\n    copy_memory(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n)\n          return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n)\n          return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\nexport function set_memory(dest: usize, c: u8, n: usize): void {\n  // based on musl\'s implementation of memset\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\n\n  // fill head and tail with minimal branching\n  if (!n)\n    return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2)\n    return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6)\n    return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8)\n    return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8)\n    return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24)\n    return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function compare_memory(vl: usize, vr: usize, n: usize): i32 {\n  // based on musl\'s implementation of memcmp\n  // provided because there\'s no proposed alternative\n  if (vl == vr)\n    return 0;\n  while (n && load<u8>(vl) == load<u8>(vr)) {\n    n--;\n    vl++;\n    vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n',"(lib)/regexp":'export class RegExp {\n\n  // @binding(CALL_NEW, [ STRING, STRING], OBJECT_HANDLE)\n  constructor(pattern: string, flags: string = "") { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [ STRING ], PASS_THRU)\n  test(search: string): bool { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [], STRING)\n  toString(): string { throw new Error("unreachable"); }\n\n}\n',"(lib)/set":'// const prime1: u32 = 73;\n// const prime2: u32 = 5009;\n\nexport class Set<T> {\n\n  private __memory: usize;\n  private __capacity: u32;\n  private __size: u32;\n\n  constructor() {\n    this.__memory = 0;\n    this.__capacity = this.__size = 0;\n  }\n\n  get size(): i32 {\n    return this.__size;\n  }\n\n  // FIXME: not a proper set implementation, just a filler\n\n  has(value: T): bool {\n    assert(this != null);\n\n    for (var index: usize = 0, limit: usize = this.__size; index < limit; ++index)\n      if (load<T>(this.__memory + index * sizeof<T>()) == value)\n        return true;\n    return false;\n  }\n\n  add(value: T): Set<T> {\n    assert(this != null);\n\n    if (this.__size >= this.__capacity) {\n      var newCapacity = max(this.__capacity << 1, 8);\n      var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\n      if (this.__memory) {\n        move_memory(newMemory, this.__memory, <usize>this.__capacity * sizeof<T>());\n        free_memory(this.__memory);\n      }\n      this.__capacity = newCapacity;\n      this.__memory = newMemory;\n    }\n    store<T>(this.__memory + <usize>this.__size * sizeof<T>(), value);\n    ++this.__size;\n    return this;\n  }\n\n  delete(value: T): bool {\n    assert(this != null);\n\n    for (var index: usize = 0, limit: usize = this.__size; index < limit; ++index)\n      if (load<T>(this.__memory + index * sizeof<T>()) == value) {\n        if (index + 1 < this.__size)\n          move_memory(this.__memory + index * sizeof<T>(), this.__memory + (index + 1) * sizeof<T>(), this.__size - index - 1);\n        --this.__size;\n        return true;\n      }\n    return false;\n  }\n\n  clear(): void {\n    assert(this != null);\n\n    this.__size = 0;\n  }\n\n  // TODO: think about iterators\n}\n\n// class SetIterator<T> extends Iterator<T> {\n\n//   get done(): bool {\n//     throw new Error("not implemented");\n//   }\n\n//   next(): T {\n//     throw new Error("not implemented");\n//   }\n// }\n',"(lib)/string":'// singleton empty string\nconst EMPTY: String = changetype<String>("");\n\n// number of bytes preceeding string data\nconst HEAD: usize = 4;\n\nfunction allocate(length: i32): String {\n  assert(length > 0); // 0 -> EMPTY\n  var ptr = allocate_memory(HEAD + (<usize>length << 1));\n  store<i32>(ptr, length);\n  return changetype<String>(ptr);\n}\n\nexport class String {\n\n  readonly length: i32;\n\n  @operator("[]")\n  charAt(pos: i32): String {\n    assert(this != null);\n\n    if (<u32>pos >= this.length)\n      return EMPTY;\n\n    var out = allocate(1);\n    store<u16>(\n      changetype<usize>(out),\n      load<u16>(\n        changetype<usize>(this) + (<usize>pos << 1),\n        HEAD\n      ),\n      HEAD\n    );\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    assert(this != null);\n\n    if (<u32>pos >= this.length)\n      return -1; // (NaN)\n\n    return load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEAD\n    );\n  }\n\n  codePointAt(pos: i32): i32 {\n    assert(this != null);\n\n    if (<u32>pos >= this.length)\n      return -1; // (undefined)\n    var first = <i32>load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEAD\n    );\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length)\n      return first;\n    var second = <i32>load<u16>(\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\n      HEAD\n    );\n    if (second < 0xDC00 || second > 0xDFFF)\n      return first;\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator("+")\n  private static __concat(left: String, right: String): String {\n    if (left == null)\n      left = changetype<String>("null");\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    assert(this != null);\n\n    if (other == null)\n      other = changetype<String>("null");\n\n    var thisLen: isize = this.length;\n    var otherLen: isize = other.length;\n    var outLen: usize = thisLen + otherLen;\n    if (outLen == 0)\n      return EMPTY;\n\n    var out = allocate(outLen);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD,\n      thisLen << 1\n    );\n    move_memory(\n      changetype<usize>(out) + HEAD + (thisLen << 1),\n      changetype<usize>(other) + HEAD,\n      otherLen << 1\n    );\n    return out;\n  }\n\n  endsWith(searchString: String, endPosition: i32 = 0x7fffffff): bool {\n    assert(this != null);\n\n    if (searchString == null)\n      return false;\n\n    var end: isize = <isize>min(max(endPosition, 0), this.length);\n    var searchLength: isize = searchString.length;\n    var start: isize = end - searchLength;\n    if (start < 0)\n      return false;\n\n    return !compare_memory(\n      changetype<usize>(this) + HEAD + (start << 1),\n      changetype<usize>(searchString) + HEAD,\n      searchLength << 1\n    );\n  }\n\n  @operator("==")\n  private static __eq(left: String, right: String): bool {\n    if (left == null)\n      return right == null;\n    else if (right == null)\n      return false;\n\n    var leftLength = left.length;\n    if (leftLength != right.length)\n      return false;\n\n    return !compare_memory(\n      changetype<usize>(left) + HEAD,\n      changetype<usize>(right) + HEAD,\n      (<usize>leftLength << 1)\n    );\n  }\n\n  includes(searchString: String, position: i32 = 0): bool {\n    return this.indexOf(searchString, position) != -1;\n  }\n\n  indexOf(searchString: String, position: i32 = 0): i32 {\n    assert(this != null);\n\n    if (searchString == null)\n      searchString = changetype<String>("null");\n\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start: isize = min<isize>(max<isize>(pos, 0), len);\n    var searchLen: isize = <isize>searchString.length;\n\n    // TODO: two-way, multiple char codes\n    for (var k: usize = start; <isize>k + searchLen <= len; ++k)\n      if (!compare_memory(\n        changetype<usize>(this) + HEAD + (k << 1),\n        changetype<usize>(searchString) + HEAD,\n        searchLen << 1)\n      )\n        return <i32>k;\n    return -1;\n  }\n\n  startsWith(searchString: String, position: i32 = 0): bool {\n    assert(this != null);\n\n    if (searchString == null)\n      searchString = changetype<String>("null");\n\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start: isize = min<isize>(max<isize>(position, 0), len);\n    var searchLength: isize = <isize>searchString.length;\n    if (searchLength + start > len)\n      return false;\n\n    return !compare_memory(\n      changetype<usize>(this) + HEAD + (start << 1),\n      changetype<usize>(searchString) + HEAD,\n      searchLength << 1\n    );\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\n    assert(this != null);\n\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0)\n      intStart = max<isize>(size + intStart, 0);\n\n    var resultLength: isize = min<isize>(max<isize>(end, 0), size - intStart);\n    if (resultLength <= 0)\n      return EMPTY;\n\n    var out = allocate(resultLength);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD + (intStart << 1),\n      <usize>resultLength << 1\n    );\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    assert(this != null);\n\n    var len = this.length;\n    var finalStart = min<i32>(max<i32>(start, 0), len);\n    var finalEnd = min<i32>(max<i32>(end, 0), len);\n    var from = min<i32>(finalStart, finalEnd);\n    var to = max<i32>(finalStart, finalEnd);\n    len = to - from;\n    if (!len)\n      return EMPTY;\n\n    if (!from && to == this.length)\n      return this;\n\n    var out = allocate(len);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD + (from << 1),\n      len << 1\n    );\n    return out;\n  }\n\n  trim(): String {\n    assert(this != null);\n\n    var length: usize = this.length;\n    while (length && isWhiteSpaceOrLineTerminator(load<u16>(changetype<usize>(this) + (length << 1), HEAD)))\n      --length;\n\n    var start: usize = 0;\n    while (start < length && isWhiteSpaceOrLineTerminator(load<u16>(changetype<usize>(this) + (start << 1), HEAD)))\n      ++start, --length;\n\n    if (!length)\n      return EMPTY;\n\n    if (!start && length == this.length)\n      return this;\n\n    var out = allocate(length);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD + (start << 1),\n      length << 1\n    );\n    return out;\n  }\n\n  trimLeft(): String {\n    assert(this != null);\n\n    var start: isize = 0;\n    var len: isize = this.length;\n    while (start < len && isWhiteSpaceOrLineTerminator(load<u16>(changetype<usize>(this) + (start << 1), HEAD)))\n      ++start;\n\n    if (!start)\n      return this;\n\n    var outLen = len - start;\n    if (!outLen)\n      return EMPTY;\n\n    var out = allocate(outLen);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD + (start << 1),\n      outLen << 1\n    );\n    return out;\n  }\n\n  trimRight(): String {\n    assert(this != null);\n\n    var len: isize = this.length;\n    while (len > 0 && isWhiteSpaceOrLineTerminator(load<u16>(changetype<usize>(this) + (len << 1), HEAD)))\n      --len;\n\n    if (len <= 0)\n      return EMPTY;\n\n    if (<i32>len == this.length)\n      return this;\n\n    var out = allocate(len);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD,\n      len << 1\n    );\n    return out;\n  }\n}\n\nfunction isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n\n    case 10:    // <LF>\n    case 13:    // <CR>\n    case 8232:  // <LS>\n    case 8233:  // <PS>\n\n    case 9:     // <TAB>\n    case 11:    // <VT>\n    case 12:    // <FF>\n    case 32:    // <SP>\n    case 160:   // <NBSP>\n    case 65279: // <ZWNBSP>\n\n      return true;\n    default:\n      return false;\n  }\n}\n\nconst enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function parseInt(str: String, radix: i32 = 0): f64 {\n  return parse<f64>(str, radix);\n}\n\nexport function parseI32(str: String, radix: i32 = 0): i32 {\n  return parse<i32>(str, radix);\n}\n\nexport function parseI64(str: String, radix: i32 = 0): i64 {\n  return parse<i64>(str, radix);\n}\n\nfunction parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len)\n    return <T>NaN;\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEAD);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len)\n      return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEAD);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len)\n      return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEAD);\n    sign = 1;\n  } else\n    sign = 1;\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEAD)) {\n\n        case CharCode.B:\n        case CharCode.b:\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n\n        case CharCode.O:\n        case CharCode.o:\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n\n        case CharCode.X:\n        case CharCode.x:\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n\n        default:\n          radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36)\n    return <T>NaN;\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEAD);\n    if (code >= CharCode._0 && code <= CharCode._9)\n      code -= CharCode._0;\n    else if (code >= CharCode.A && code <= CharCode.Z)\n      code -= CharCode.A - 10;\n    else if (code >= CharCode.a && code <= CharCode.z)\n      code -= CharCode.a - 10;\n    else\n      break;\n    if (code >= radix)\n      break;\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n\nexport function parseFloat(str: String): f64 {\n  var len: i32 = str.length;\n  if (!len)\n    return NaN;\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEAD);\n\n  // determine sign\n  var sign: f64;\n  if (code == CharCode.MINUS) {\n    if (!--len)\n      return NaN;\n    code = <i32>load<u16>(ptr += 2, HEAD);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len)\n      return NaN;\n    code = <i32>load<u16>(ptr += 2, HEAD);\n    sign = 1;\n  } else\n    sign = 1;\n\n  // calculate value\n  var num: f64 = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEAD);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      var fac: f64 = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr, HEAD);\n        if (code == CharCode.E || code == CharCode.e)\n          assert(false); // TODO\n        code -= CharCode._0;\n        if (<u32>code > 9)\n          break;\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10)\n      break;\n    num = (num * 10) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n'}:{},t.definitionFiles=t.isBundle?{assembly:'// Definitions for the "AssemblyScript" subset.\n\n// Types\n\n/** An 8-bit signed integer. */\ndeclare type i8 = number;\n/** A 16-bit signed integer. */\ndeclare type i16 = number;\n/** A 32-bit signed integer. */\ndeclare type i32 = number;\n/** A 64-bit signed integer. */\ndeclare type i64 = number;\n/** A 32-bit signed integer when targeting 32-bit WebAssembly or a 64-bit signed integer when targeting 64-bit WebAssembly. */\ndeclare type isize = number;\n/** An 8-bit unsigned integer. */\ndeclare type u8 = number;\n/** A 16-bit unsigned integer. */\ndeclare type u16 = number;\n/** A 32-bit unsigned integer. */\ndeclare type u32 = number;\n/** A 64-bit unsigned integer. */\ndeclare type u64 = number;\n/** A 32-bit unsigned integer when targeting 32-bit WebAssembly or a 64-bit unsigned integer when targeting 64-bit WebAssembly. */\ndeclare type usize = number;\n/** A 1-bit unsigned integer. */\ndeclare type bool = any; // sic\n/** A 32-bit float. */\ndeclare type f32 = number;\n/** A 64-bit float. */\ndeclare type f64 = number;\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace i8 {\n  export const MIN_VALUE: i8;\n  export const MAX_VALUE: i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace i16 {\n  export const MIN_VALUE: i16;\n  export const MAX_VALUE: i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i32;\ndeclare namespace i32 {\n  export const MIN_VALUE: i32;\n  export const MAX_VALUE: i32;\n}\n/** Converts any other numeric value to a 64-bit signed integer. */\ndeclare function i64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i64;\ndeclare namespace i64 {\n  export const MIN_VALUE: i64;\n  export const MAX_VALUE: i64;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare function isize(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): isize;\ndeclare namespace isize {\n  export const MIN_VALUE: isize;\n  export const MAX_VALUE: isize;\n}\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace u8 {\n  export const MIN_VALUE: u8;\n  export const MAX_VALUE: u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace u16 {\n  export const MIN_VALUE: u16;\n  export const MAX_VALUE: u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i32;\ndeclare namespace u32 {\n  export const MIN_VALUE: u32;\n  export const MAX_VALUE: u32;\n}\n/** Converts any other numeric value to a 64-bit unsigned integer. */\ndeclare function u64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i64;\ndeclare namespace u64 {\n  export const MIN_VALUE: u64;\n  export const MAX_VALUE: u64;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare function usize(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): isize;\ndeclare namespace usize {\n  export const MIN_VALUE: usize;\n  export const MAX_VALUE: usize;\n}\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): bool;\ndeclare namespace bool {\n  export const MIN_VALUE: bool;\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): f32;\ndeclare namespace f32 {\n  export const MIN_VALUE: f32;\n  export const MAX_VALUE: f32;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): f64;\ndeclare namespace f64 {\n  export const MIN_VALUE: f64;\n  export const MAX_VALUE: f64;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n}\n\n// Built-ins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered trailing if the value is zero. */\ndeclare function ctz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit or 64-bit integer. */\ndeclare function popcnt<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic rotate left operation on a 32-bit or 64-bit integer. */\ndeclare function rotl<T = i32 | i64>(value: T, shift: T): T;\n/** Performs the sign-agnostic rotate right operation on a 32-bit or 64-bit integer. */\ndeclare function rotr<T = i32 | i64>(value: T, shift: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | i64 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\ndeclare function copysign<T = f32 | f64>(x: T, y: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\ndeclare function nearest<T = f32 | f64>(value: T): T;\n/** Reinterprets the bits of the specified value as type `T`. Valid reinterpretations are u32/i32 to/from f32 and u64/i64 to/from f64. */\ndeclare function reinterpret<T = i32 | i64 | f32 | f64>(value: number): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Loads a value of the specified type from memory. Equivalent to dereferncing a pointer in other languages. */\ndeclare function load<T>(ptr: usize, constantOffset?: usize): any;\n/** Stores a value of the specified type to memory. Equivalent to dereferencing a pointer in other languages when assigning a value. */\ndeclare function store<T>(ptr: usize, value: any, constantOffset?: usize): void;\n/** Returns the current memory size in units of pages. One page is 64kb. */\ndeclare function current_memory(): i32;\n/** Grows linear memory by a given unsigned delta of pages. One page is 64kb. Returns the previous memory size in units of pages or `-1` on failure. */\ndeclare function grow_memory(value: i32): i32;\n/** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\ndeclare function move_memory(destination: usize, source: usize, n: usize): void;\n/** Sets n bytes beginning at the specified destination in memory to the specified byte value. */\ndeclare function set_memory(destination: usize, value: u8, count: usize): void;\n/** Compares two chunks of memory. Returns `0` if equal, otherwise the difference of the first differing bytes. */\ndeclare function compare_memory(vl: usize, vr: usize, n: usize): i32;\n/** Allocates a chunk of memory of the specified size and returns a pointer to it. */\ndeclare function allocate_memory(size: usize): usize;\n/** Disposes a chunk of memory by its pointer. */\ndeclare function free_memory(ptr: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. Both a statement and an expression of any type. */\ndeclare function unreachable(): any; // sic\n\n/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */\ndeclare const NaN: f32 | f64;\n/** Positive infinity as a 32-bit or 64-bit float depending on context. */\ndeclare const Infinity: f32 | f64;\n/** Heap base offset. */\ndeclare const HEAP_BASE: usize;\n/** Determines the byte size of the specified core or class type. Compiles to a constant. */\ndeclare function sizeof<T>(): usize;\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Tests if a 32-bit or 64-bit float is `NaN`. */\ndeclare function isNaN<T = f32 | f64>(value: T): bool;\n/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */\ndeclare function isFinite<T = f32 | f64>(value: T): bool;\n/** Traps if the specified value is not true-ish, otherwise returns the (non-nullable) value. */\ndeclare function assert<T>(isTrueish: T, message?: string): T & object; // any better way to model `: T != null`?\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses an integer string to a 32-bit integer. */\ndeclare function parseI32(str: string, radix?: i32): i32;\n/** Parses an integer string to a 64-bit integer. */\ndeclare function parseI64(str: string, radix?: i32): i64;\n/** Parses a string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n\n// Standard library (not yet implemented)\n\n/** Class representing a sequence of values of type `T`. */\ndeclare class Array<T> {\n  [key: number]: T;\n  /** Current length of the array. */\n  length: i32;\n  /** Constructs a new array. */\n  constructor(capacity?: i32);\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): void;\n  pop(): T;\n  shift(): T;\n  unshift(element: T): i32;\n  slice(from: i32, to?: i32): T[];\n  splice(start: i32, deleteCount?: i32): void;\n  reverse(): T[];\n}\n\n/** Class representing a C-like array of values of type `T` with limited capabilities. */\ndeclare class CArray<T> {\n  [key: number]: T;\n  private constructor();\n}\n\n/** Class representing a sequence of characters. */\ndeclare class String {\n\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(cp: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n\n  readonly length: u32;\n\n  charAt(index: u32): string;\n  charCodeAt(index: u32): u16;\n  concat(other: string): string;\n  endsWith(other: string): bool;\n  indexOf(other: string): u32;\n  includes(other: string): bool;\n  startsWith(other: string): bool;\n  substr(start: u32, length?: u32): string;\n  substring(start: u32, end?: u32): string;\n  trim(): string;\n  trimLeft(): string;\n  trimRight(): string;\n}\n\n/** Class for representing a runtime error. Base class of all errors. */\ndeclare class Error {\n\n  /** Error name. */\n  name: string;\n\n  /** Message provided on construction. */\n  message: string;\n\n  /** Stack trace. */\n  stack: string;\n\n  /** Constructs a new error, optionally with a message. */\n  constructor(message?: string);\n}\n\n/** Class for indicating an error when a value is not in the set or range of allowed values. */\ndeclare class RangeError extends Error { }\n\ninterface Boolean {}\ninterface Function {}\ninterface IArguments {}\ninterface Number {}\ninterface Object {}\ninterface RegExp {}\n\ndeclare class Set<T> {\n  readonly size: i32;\n  has(value: T): bool;\n  add(value: T): void;\n  delete(value: T): bool;\n  clear(): void;\n}\n\n// Internal decorators\n\n/** Annotates an element as a program global. */\ndeclare function global(target: Function): any;\n\n/** Annotates a method as an operator overload. */\ndeclare function operator(token: string): any;\n\n/** Annotates a class as being unmanaged with limited capabilities. */\ndeclare function unmanaged(target: Function): any;\n\n/** Annotates a class field with an explicit offset. */\ndeclare function offset(offset: usize): any;\n\n/** Annotates an element as begin built-in. */\ndeclare function builtin(target: Function): any;\n',portable:'// Definitions for the "portable AssemblyScript" subset.\n\n// Portable types\n\n// Note that semantic differences require additional explicit conversions for full compatibility.\n// For example, when casting an i32 to an u8, doing `<u8>(someI32 & 0xff)` will yield the same\n// result when compiling to WebAssembly or JS while `<u8>someI32` alone does nothing in JS.\n\n// Note that i64\'s are not portable (JS numbers are IEEE754 doubles with a maximum safe integer value\n// of 2^53-1) and instead require a compatibility layer to work in JS as well. See: src/util/i64.ts\n\ndeclare type i8 = number;\ndeclare type i16 = number;\ndeclare type i32 = number;\ndeclare type isize = number;\ndeclare type u8 = number;\ndeclare type u16 = number;\ndeclare type u32 = number;\ndeclare type bool = boolean;\ndeclare type usize = number;\ndeclare type f32 = number;\ndeclare type f64 = number;\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace i8 {\n  export const MIN_VALUE: i8;\n  export const MAX_VALUE: i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace i16 {\n  export const MIN_VALUE: i16;\n  export const MAX_VALUE: i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i32;\ndeclare namespace i32 {\n  export const MIN_VALUE: i32;\n  export const MAX_VALUE: i32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare function isize(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): isize;\ndeclare namespace isize {\n  export const MIN_VALUE: isize;\n  export const MAX_VALUE: isize;\n}\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace u8 {\n  export const MIN_VALUE: u8;\n  export const MAX_VALUE: u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace u16 {\n  export const MIN_VALUE: u16;\n  export const MAX_VALUE: u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i32;\ndeclare namespace u32 {\n  export const MIN_VALUE: u32;\n  export const MAX_VALUE: u32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare function usize(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): isize;\ndeclare namespace usize {\n  export const MIN_VALUE: usize;\n  export const MAX_VALUE: usize;\n}\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): bool;\ndeclare namespace bool {\n  export const MIN_VALUE: bool;\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): f32;\ndeclare namespace f32 {\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): f64;\ndeclare namespace f64 {\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n}\n\n// Portable built-ins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32>(value: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Allocates a chunk of memory of the specified size and returns a pointer to it. */\ndeclare function allocate_memory(size: usize): usize;\n/** Disposes a chunk of memory by its pointer. */\ndeclare function free_memory(ptr: usize): void;\n/** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\ndeclare function move_memory(destination: usize, source: usize, n: usize): void;\n/** Loads a value of the specified type from memory. Type must be `u8`. */\ndeclare function load<T = u8>(ptr: usize, constantOffset?: usize): T;\n/** Stores a value of the specified type to memory. Type must be `u8`. */\ndeclare function store<T = u8>(ptr: usize, value: T, constantOffset?: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. */\ndeclare function unreachable(): any; // sic\n\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Traps if the specified value is not true-ish, otherwise returns the value. */\ndeclare function assert<T>(isTrueish: T, message?: string): T & object; // any better way to model `: T != null`?\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses an integer string to a 32-bit integer. */\ndeclare function parseI32(str: string, radix?: i32): i32;\n/** Parses a floating point string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n\n// Portable standard library\n// Everything marked @deprecated is a temporary filler. Do not use.\n\ndeclare const NaN: f32 | f64;\ndeclare const Infinity: f32 | f64;\n\ndeclare class Array<T> {\n  [key: number]: T;\n  length: i32;\n  constructor(capacity?: i32);\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): void;\n  pop(): T;\n  shift(): T;\n  unshift(element: T): i32;\n  slice(from: i32, to?: i32): T[];\n  splice(start: i32, deleteCount?: i32): void;\n  reverse(): T[];\n\n  join(delim: string): string;\n}\n\ndeclare class Uint8Array extends Array<u8> {}\ndeclare class Uint16Array extends Array<u16> {}\ndeclare class Uint32Array extends Array<u32> {}\ndeclare class Int8Array extends Array<i8> {}\ndeclare class Int16Array extends Array<i16> {}\ndeclare class Int32Array extends Array<i32> {}\ndeclare class Float32Array extends Array<f32> {}\ndeclare class Float64Array extends Array<f64> {}\n\ndeclare class String {\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(cp: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n  readonly length: i32;\n  private constructor();\n  indexOf(subject: string, position?: i32): i32;\n  includes(other: string): bool;\n  lastIndexOf(subject: string, position?: i32): i32;\n  charAt(index: i32): string;\n  charCodeAt(index: i32): i32;\n  substring(from: i32, to?: i32): string;\n  startsWith(subject: string): bool;\n  endsWith(subject: string): bool;\n  replace(search: string, replacement: string): string;\n  toString(): string;\n}\n\ninterface Boolean {}\n\ndeclare class Number {\n  private constructor();\n  toString(radix?: i32): string;\n}\n\ninterface Object {}\n\ninterface Function {}\n\ninterface RegExp {}\n\ninterface IArguments {}\n\ndeclare class Error {\n  constructor(message: string);\n  message: string;\n  stack: string | null;\n}\n\ndeclare class Symbol {\n  private constructor();\n  static readonly iterator: symbol;\n}\n\ndeclare class Set<T> {\n  constructor(entries?: T[]);\n  has(value: T): bool;\n  add(value: T): void;\n  delete(value: T): bool;\n  clear(): void;\n  [Symbol.iterator](): Iterator<T>;\n}\n\ndeclare class Map<K,V> {\n  constructor(entries?: [K, V][]);\n  readonly size: i32;\n  set(key: K, value: V): void;\n  has(key: K): bool;\n  get(key: K): V | null;\n  clear(): void;\n  entries(): Iterable<[K, V]>;\n  keys(): Iterable<K>;\n  values(): Iterable<V>;\n  [Symbol.iterator](): Iterator<[K,V]>;\n}\n\ninterface Iterable<T> {\n  [Symbol.iterator](): Iterator<T>;\n}\n\ninterface Iterator<T> {}\n\ndeclare namespace console {\n  /** @deprecated */\n  function log(message: string): void;\n}\n'}:{},t.main=function(r,h,m){function g(e){try{var t;return A.readCount++,A.readTime+=a(()=>{t=u.readFileSync(e,{encoding:'utf8'})}),t}catch(t){return null}}function b(e,t){try{return A.writeCount++,A.writeTime+=a(()=>{'string'==typeof t?u.writeFileSync(e,t,{encoding:'utf8'}):u.writeFileSync(e,t)}),!0}catch(t){return!1}}function y(e){var t;try{return A.readTime+=a(()=>{t=i(!function(){var t=new Error('Cannot find module "glob"');throw t.code='MODULE_NOT_FOUND',t}()).sync('*.ts',{cwd:e})}),t}catch(t){return[]}}function _(e){_.used||(A.writeCount++,_.used=!0),A.writeTime+=a(()=>{'string'==typeof e?v.write(e,{encoding:'utf8'}):v.write(e)})}'function'==typeof h?(m=h,h={}):!h&&(h={});const v=h.stdout||e.stdout,z=h.stderr||e.stderr,T=h.readFile||g,E=h.writeFile||b,x=h.listFiles||y,A=h.stats||n();if(!v)throw Error('\'options.stdout\' must be specified');if(!z)throw Error('\'options.stderr\' must be specified');if(!u.readFileSync){if(T===g)throw Error('\'options.readFile\' must be specified');if(E===b)throw Error('\'options.writeFile\' must be specified');if(x===y)throw Error('\'options.listFiles\' must be specified')}const S=s(r),k=24;if(m||(m=function(e){var t=0;return e&&(z.write(e.stack+f.EOL),t=1),t}),S.version)return v.write('Version '+t.version+(p?'-dev':'')+f.EOL),m(null);if(S.help||1>S._.length){const e=[];return Object.keys(t.options).forEach((i)=>{var r=t.options[i],s=' ';for(s+='--'+i,r.aliases&&1===r.aliases[0].length&&(s+=', -'+r.aliases[0]);s.length<k;)s+=' ';Array.isArray(r.desc)?e.push(s+r.desc[0]+r.desc.slice(1).map((e)=>{for(let t=0;t<k;++t)e=' '+e;return f.EOL+e}).join('')):e.push(s+r.desc)}),(S.help?v:z).write(['Version '+t.version+(p?'-dev':''),'Syntax:   asc [entryFile ...] [options]','','Examples: asc hello.ts','          asc hello.ts -b hello.wasm -t hello.wat','          asc hello1.ts hello2.ts -b -O > hello.wasm','','Options:'].concat(e).join(f.EOL)+f.EOL),m(null)}const I=S.baseDir?c.resolve(S.baseDir):e.cwd(),L=c.join('.','..','std','assembly'),w=S.noLib?[]:[L];S.lib&&('string'==typeof S.lib&&(S.lib=S.lib.split(',')),Array.prototype.push.apply(w,S.lib.map(trim)));var M=null;for(let e=0,i=S._.length;e<i;++e){const i=S._[e];let r=i.replace(/\\/g,'/').replace(/(\.ts|\/)$/,''),s=T(c.join(I,r)+'.ts');if(null===s){if(s=T(c.join(I,r,'index.ts')),null===s)return m(Error('Entry file \''+r+'.ts\' not found.'));r+='/index.ts'}else r+='.ts';for(A.parseCount++,A.parseTime+=a(()=>{M=d.parseFile(s,r,!0,M)});null!=(r=M.nextFile());){if(r.startsWith(t.libraryPrefix)){for(let e=0,i=w.length;e<i;++e)if(t.libraryFiles.hasOwnProperty(r))s=t.libraryFiles[r];else if(s=T(c.join(w[e],r.substring(t.libraryPrefix.length)+'.ts')),null!==s){r+='.ts';break}}else if(s=T(c.join(I,r+'.ts')),null!==s)r+='.ts';else if(s=T(c.join(I,r,'index.ts')),null===s){for(let e=0,i=w.length;e<i;++e){const i=w[e],o=t.libraryPrefix+r;if(t.libraryFiles.hasOwnProperty(o))s=t.libraryFiles[o];else if(s=T(c.join(i,r+'.ts')),null!==s){r=t.libraryPrefix+r+'.ts';break}}if(null===s)return m(Error('Import file \''+r+'.ts\' not found.'))}else r+='/index.ts';A.parseCount++,A.parseTime+=a(()=>{d.parseFile(s,r,!1,M)})}if(o(M,z))return m(Error('Parse error'))}var C=!1;S.noLib||Object.keys(t.libraryFiles).forEach((e)=>{e.lastIndexOf('/')>=t.libraryPrefix.length||(A.parseCount++,A.parseTime+=a(()=>{M=d.parseFile(t.libraryFiles[e],e+'.ts',!1,M)}),C=!0)});for(let e=0,i=w.length;e<i;++e){if(0===e&&C)continue;let i=w[e],r=x(i);for(let e=0,s=r.length;e<s;++e){let s=r[e],o=T(c.join(i,s));if(null===o)return m(Error('Library file \''+s+'\' not found.'));A.parseCount++,A.parseTime+=a(()=>{M=d.parseFile(o,t.libraryPrefix+s,!1,M)})}}const B=d.createOptions();d.setTarget(B,0),d.setNoTreeShaking(B,!!S.noTreeShaking),d.setNoAssert(B,!!S.noAssert),d.setNoMemory(B,!!S.noMemory),d.setMemoryBase(B,S.memoryBase>>>0),d.setSourceMap(B,null!=S.sourceMap);var F;A.compileCount++;try{A.compileTime+=a(()=>{F=d.compile(M,B)})}catch(t){return m(t)}if(o(M,z))return F&&F.dispose(),m(Error('Compile error'));if(S.validate&&(A.validateCount++,A.validateTime+=a(()=>{if(!F.validate())return F.dispose(),m(Error('Validate error'))})),'clamp'===S.trapMode)A.optimizeCount++,A.optimizeTime+=a(()=>{F.runPasses(['trap-mode-clamp'])});else if('js'===S.trapMode)A.optimizeCount++,A.optimizeTime+=a(()=>{F.runPasses(['trap-mode-js'])});else if('allow'!==S.trapMode)return F.dispose(),m(Error('Unsupported trap mode'));var N=-1,R=0,O=!S.noDebug;!1!==S.optimize&&('number'==typeof S.optimize?N=S.optimize:S[0]?N=0:S[1]?N=1:S[2]?N=2:S[3]?N=3:!0===S.optimize?(N=t.defaultOptimizeLevel,R=t.defaultShrinkLevel):N=0),S.s?R=1:S.z&&(R=2),'number'==typeof S.optimizeLevel&&(N=S.optimizeLevel),'number'==typeof S.shrinkLevel?R=S.shrinkLevel:'s'===S.shrinkLevel?R=1:'z'===S.shrinkLevel&&(R=2),F.setOptimizeLevel(0<N?N:0),F.setShrinkLevel(R),F.setDebugInfo(O);var P=[];if(S.runPasses&&('string'==typeof S.runPasses&&(S.runPasses=S.runPasses.split(',')),S.runPasses.length&&S.runPasses.forEach((e)=>{0>P.indexOf(e)&&P.push(e)})),0<=N&&(A.optimizeCount++,A.optimizeTime+=a(()=>{F.optimize()})),P.length&&(A.optimizeCount++,A.optimizeTime+=a(()=>{F.runPasses(P.map((e)=>e.trim()))})),!S.noEmit){let e=!1;if(null!=S.outFile&&(/\.was?t$/.test(S.outFile)&&null==S.textFile?S.textFile=S.outFile:/\.js$/.test(S.outFile)&&null==S.asmjsFile?S.asmjsFile=S.outFile:null==S.binaryFile&&(S.binaryFile=S.outFile)),null!=S.binaryFile){let i,r=null==S.sourceMap?null:S.sourceMap.length?S.sourceMap:c.basename(S.binaryFile)+'.map';if(A.emitCount++,A.emitTime+=a(()=>{i=F.toBinary(r)}),S.binaryFile.length?E(c.join(I,S.binaryFile),i.output):(_(i.output),e=!0),null!=i.sourceMap)if(S.binaryFile.length){let e=JSON.parse(i.sourceMap);e.sourceRoot=t.sourceMapRoot,e.sources.forEach((r,i)=>{let s=null;if(r.startsWith(t.libraryPrefix))for(let e=0,i=w.length;e<i&&(s=T(c.join(w[e],r.substring(t.libraryPrefix.length))),null===s);++e);else s=T(c.join(I,r));return null===s?m(Error('Source file \''+r+'\' not found.')):void(!e.sourceContents&&(e.sourceContents=[]),e.sourceContents[i]=s)}),E(c.join(I,c.dirname(S.binaryFile),c.basename(r)),JSON.stringify(e))}else z.write('Skipped source map (stdout already occupied)'+f.EOL)}if(null!=S.textFile||null==S.binaryFile&&null==S.asmjsFile){let t;S.textFile&&S.textFile.length?(A.emitCount++,A.emitTime+=a(()=>{t=F.toText()}),E(c.join(I,S.textFile),t)):!e&&(A.emitCount++,A.emitTime+=a(()=>{t=F.toText()}),_(t),e=!0)}if(null!=S.asmjsFile&&S.asmjsFile.length){let t;S.asmjsFile.length?(A.emitCount++,A.emitTime+=a(()=>{t=F.toAsmjs()}),E(c.join(I,S.asmjsFile),t)):!e&&(A.emitCount++,A.emitTime+=a(()=>{t=F.toAsmjs()}),_(t),e=!0)}}return F.dispose(),S.measure&&l(A,z),m(null)},t.parseArguments=s,t.checkDiagnostics=o,t.createStats=n,e.hrtime||(e.hrtime=i(15)),t.measure=a,t.printStats=l,t.createMemoryStream=function(e){var t=[];return t.write=function(t){'string'==typeof t?this.push(r.from(t,'utf8')):this.push(t),e&&e(t)},t.toBuffer=function(){return r.concat(this)},t.toString=function(){return this.toBuffer().toString('utf8')},t},t.tscOptions={alwaysStrict:!0,noImplicitAny:!0,noImplicitReturns:!0,noImplicitThis:!0,noEmitOnError:!0,strictNullChecks:!0,experimentalDecorators:!0,target:'esnext',module:'commonjs',noLib:!0,types:[],allowJs:!1}}).call(t,i(0),i(5).Buffer)},function(e,t,i){'use strict';(function(e){function n(){return l.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(e,t){if(n()<t)throw new RangeError('Invalid typed array length');return l.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t),e.__proto__=l.prototype):(null===e&&(e=new l(t)),e.length=t),e}function l(e,t,i){if(!l.TYPED_ARRAY_SUPPORT&&!(this instanceof l))return new l(e,t,i);if('number'==typeof e){if('string'==typeof t)throw new Error('If encoding is specified then the first argument must be a string');return d(this,e)}return u(this,e,t,i)}function u(e,t,i,r){if('number'==typeof t)throw new TypeError('"value" argument must not be a number');return'undefined'!=typeof ArrayBuffer&&t instanceof ArrayBuffer?m(e,t,i,r):'string'==typeof t?p(e,t,i):g(e,t)}function c(e){if('number'!=typeof e)throw new TypeError('"size" argument must be a number');else if(0>e)throw new RangeError('"size" argument must not be negative')}function f(e,t,i,r){return c(t),0>=t?a(e,t):void 0===i?a(e,t):'string'==typeof r?a(e,t).fill(i,r):a(e,t).fill(i)}function d(e,t){if(c(t),e=a(e,0>t?0:0|b(t)),!l.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function p(e,t,i){if(('string'!=typeof i||''===i)&&(i='utf8'),!l.isEncoding(i))throw new TypeError('"encoding" must be a valid string encoding');var r=0|y(t,i);e=a(e,r);var s=e.write(t,i);return s!==r&&(e=e.slice(0,s)),e}function h(e,t){var r=0>t.length?0:0|b(t.length);e=a(e,r);for(var s=0;s<r;s+=1)e[s]=255&t[s];return e}function m(e,t,i,r){if(t.byteLength,0>i||t.byteLength<i)throw new RangeError('\'offset\' is out of bounds');if(t.byteLength<i+(r||0))throw new RangeError('\'length\' is out of bounds');return t=void 0===i&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,i):new Uint8Array(t,i,r),l.TYPED_ARRAY_SUPPORT?(e=t,e.__proto__=l.prototype):e=h(e,t),e}function g(e,t){if(l.isBuffer(t)){var i=0|b(t.length);return(e=a(e,i),0===e.length)?e:(t.copy(e,0,0,i),e)}if(t){if('undefined'!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||'length'in t)return'number'!=typeof t.length||J(t.length)?a(e,0):h(e,t);if('Buffer'===t.type&&te(t.data))return h(e,t.data)}throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')}function b(e){if(e>=n())throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x'+n().toString(16)+' bytes');return 0|e}function y(e,t){if(l.isBuffer(e))return e.length;if('undefined'!=typeof ArrayBuffer&&'function'==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;'string'!=typeof e&&(e=''+e);var i=e.length;if(0===i)return 0;for(var r=!1;;)switch(t){case'ascii':case'latin1':case'binary':return i;case'utf8':case'utf-8':case void 0:return Z(e).length;case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return 2*i;case'hex':return i>>>1;case'base64':return K(e).length;default:if(r)return Z(e).length;t=(''+t).toLowerCase(),r=!0;}}function _(e,t,i){var r=!1;if((void 0===t||0>t)&&(t=0),t>this.length)return'';if((void 0===i||i>this.length)&&(i=this.length),0>=i)return'';if(i>>>=0,t>>>=0,i<=t)return'';for(e||(e='utf8');;)switch(e){case'hex':return F(this,t,i);case'utf8':case'utf-8':return w(this,t,i);case'ascii':return C(this,t,i);case'latin1':case'binary':return B(this,t,i);case'base64':return L(this,t,i);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return N(this,t,i);default:if(r)throw new TypeError('Unknown encoding: '+e);e=(e+'').toLowerCase(),r=!0;}}function v(e,t,r){var s=e[t];e[t]=e[r],e[r]=s}function z(e,t,i,r,s){if(0===e.length)return-1;if('string'==typeof i?(r=i,i=0):2147483647<i?i=2147483647:-2147483648>i&&(i=-2147483648),i=+i,isNaN(i)&&(i=s?0:e.length-1),0>i&&(i=e.length+i),i>=e.length){if(s)return-1;i=e.length-1}else if(0>i)if(s)i=0;else return-1;if('string'==typeof t&&(t=l.from(t,r)),l.isBuffer(t))return 0===t.length?-1:T(e,t,i,r,s);if('number'==typeof t)return t&=255,l.TYPED_ARRAY_SUPPORT&&'function'==typeof Uint8Array.prototype.indexOf?s?Uint8Array.prototype.indexOf.call(e,t,i):Uint8Array.prototype.lastIndexOf.call(e,t,i):T(e,[t],i,r,s);throw new TypeError('val must be string, number or Buffer')}function T(e,t,r,s,o){function n(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}var a=1,l=e.length,u=t.length;if(void 0!==s&&(s=(s+'').toLowerCase(),'ucs2'===s||'ucs-2'===s||'utf16le'===s||'utf-16le'===s)){if(2>e.length||2>t.length)return-1;a=2,l/=2,u/=2,r/=2}var c;if(o){var i=-1;for(c=r;c<l;c++)if(n(e,c)!==n(t,-1==i?0:c-i))-1!=i&&(c-=c-i),i=-1;else if(-1==i&&(i=c),c-i+1===u)return i*a}else for(r+u>l&&(r=l-u),c=r;0<=c;c--){for(var f=!0,d=0;d<u;d++)if(n(e,c+d)!==n(t,d)){f=!1;break}if(f)return c}return-1}function E(e,t,r,s){r=+r||0;var o=e.length-r;s?(s=+s,s>o&&(s=o)):s=o;var n=t.length;if(0!=n%2)throw new TypeError('Invalid hex string');s>n/2&&(s=n/2);for(var a,l=0;l<s;++l){if(a=parseInt(t.substr(2*l,2),16),isNaN(a))return l;e[r+l]=a}return l}function x(e,t,i,r){return q(Z(t,e.length-i),e,i,r)}function A(e,t,i,r){return q(G(t),e,i,r)}function S(e,t,i,r){return A(e,t,i,r)}function k(e,t,i,r){return q(K(t),e,i,r)}function I(e,t,i,r){return q(W(t,e.length-i),e,i,r)}function L(e,t,i){return 0===t&&i===e.length?$.fromByteArray(e):$.fromByteArray(e.slice(t,i))}function w(e,t,r){r=s(e.length,r);for(var o=[],n=t;n<r;){var i=e[n],a=null,l=239<i?4:223<i?3:191<i?2:1;if(n+l<=r){var u,c,f,d;1==l?128>i&&(a=i):2==l?(u=e[n+1],128==(192&u)&&(d=(31&i)<<6|63&u,127<d&&(a=d))):3==l?(u=e[n+1],c=e[n+2],128==(192&u)&&128==(192&c)&&(d=(15&i)<<12|(63&u)<<6|63&c,2047<d&&(55296>d||57343<d)&&(a=d))):4==l?(u=e[n+1],c=e[n+2],f=e[n+3],128==(192&u)&&128==(192&c)&&128==(192&f)&&(d=(15&i)<<18|(63&u)<<12|(63&c)<<6|63&f,65535<d&&1114112>d&&(a=d))):void 0}null===a?(a=65533,l=1):65535<a&&(a-=65536,o.push(55296|1023&a>>>10),a=56320|1023&a),o.push(a),n+=l}return M(o)}function M(e){var t=e.length;if(t<=ie)return Q.apply(String,e);for(var r='',s=0;s<t;)r+=Q.apply(String,e.slice(s,s+=ie));return r}function C(e,t,r){var o='';r=s(e.length,r);for(var n=t;n<r;++n)o+=Q(127&e[n]);return o}function B(e,t,r){var o='';r=s(e.length,r);for(var n=t;n<r;++n)o+=Q(e[n]);return o}function F(e,t,r){var s=e.length;(!t||0>t)&&(t=0),(!r||0>r||r>s)&&(r=s);for(var o='',n=t;n<r;++n)o+=Y(e[n]);return o}function N(e,t,r){for(var s=e.slice(t,r),o='',n=0;n<s.length;n+=2)o+=Q(s[n]+256*s[n+1]);return o}function R(e,t,i){if(0!=e%1||0>e)throw new RangeError('offset is not uint');if(e+t>i)throw new RangeError('Trying to access beyond buffer length')}function O(e,t,i,r,s,o){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>s||t<o)throw new RangeError('"value" argument is out of bounds');if(i+r>e.length)throw new RangeError('Index out of range')}function P(e,t,r,o){0>t&&(t=65535+t+1);for(var n=0,i=s(e.length-r,2);n<i;++n)e[r+n]=(t&255<<8*(o?n:1-n))>>>8*(o?n:1-n)}function U(e,t,r,o){0>t&&(t=4294967295+t+1);for(var n=0,i=s(e.length-r,4);n<i;++n)e[r+n]=255&t>>>8*(o?n:3-n)}function D(e,t,i,r){if(i+r>e.length)throw new RangeError('Index out of range');if(0>i)throw new RangeError('Index out of range')}function V(e,t,i,r,s){return s||D(e,t,i,4,34028234663852886e22,-34028234663852886e22),ee.write(e,t,i,r,23,4),i+4}function j(e,t,i,r,s){return s||D(e,t,i,8,17976931348623157e292,-17976931348623157e292),ee.write(e,t,i,r,52,8),i+8}function H(e){if(e=X(e).replace(re,''),2>e.length)return'';for(;0!=e.length%4;)e+='=';return e}function X(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,'')}function Y(e){return 16>e?'0'+e.toString(16):e.toString(16)}function Z(e,t){t=t||Infinity;for(var r,s=e.length,o=null,n=[],a=0;a<s;++a){if(r=e.charCodeAt(a),55295<r&&57344>r){if(!o){if(56319<r){-1<(t-=3)&&n.push(239,191,189);continue}else if(a+1===s){-1<(t-=3)&&n.push(239,191,189);continue}o=r;continue}if(56320>r){-1<(t-=3)&&n.push(239,191,189),o=r;continue}r=(o-55296<<10|r-56320)+65536}else o&&-1<(t-=3)&&n.push(239,191,189);if(o=null,128>r){if(0>(t-=1))break;n.push(r)}else if(2048>r){if(0>(t-=2))break;n.push(192|r>>6,128|63&r)}else if(65536>r){if(0>(t-=3))break;n.push(224|r>>12,128|63&r>>6,128|63&r)}else if(1114112>r){if(0>(t-=4))break;n.push(240|r>>18,128|63&r>>12,128|63&r>>6,128|63&r)}else throw new Error('Invalid code point')}return n}function G(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}function W(e,t){for(var r,s,o,n=[],a=0;a<e.length&&!(0>(t-=2));++a)r=e.charCodeAt(a),s=r>>8,o=r%256,n.push(o),n.push(s);return n}function K(e){return $.toByteArray(H(e))}function q(e,t,r,s){for(var o=0;o<s&&!(o+r>=t.length||o>=e.length);++o)t[o+r]=e[o];return o}function J(e){return e!==e}var Q=String.fromCharCode,$=i(6),ee=i(7),te=i(8);/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */t.Buffer=l,t.SlowBuffer=function(e){return+e!=e&&(e=0),l.alloc(+e)},t.INSPECT_MAX_BYTES=50,l.TYPED_ARRAY_SUPPORT=e.TYPED_ARRAY_SUPPORT===void 0?function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&'function'==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(t){return!1}}():e.TYPED_ARRAY_SUPPORT,t.kMaxLength=n(),l.poolSize=8192,l._augment=function(e){return e.__proto__=l.prototype,e},l.from=function(e,t,i){return u(null,e,t,i)},l.TYPED_ARRAY_SUPPORT&&(l.prototype.__proto__=Uint8Array.prototype,l.__proto__=Uint8Array,'undefined'!=typeof Symbol&&Symbol.species&&l[Symbol.species]===l&&Object.defineProperty(l,Symbol.species,{value:null,configurable:!0})),l.alloc=function(e,t,i){return f(null,e,t,i)},l.allocUnsafe=function(e){return d(null,e)},l.allocUnsafeSlow=function(e){return d(null,e)},l.isBuffer=function(e){return!!(null!=e&&e._isBuffer)},l.compare=function(e,t){if(!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError('Arguments must be Buffers');if(e===t)return 0;for(var r=e.length,o=t.length,n=0,i=s(r,o);n<i;++n)if(e[n]!==t[n]){r=e[n],o=t[n];break}return r<o?-1:o<r?1:0},l.isEncoding=function(e){switch((e+'').toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'latin1':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return!0;default:return!1;}},l.concat=function(e,t){if(!te(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);var r;if(t===void 0)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var i=l.allocUnsafe(t),s=0;for(r=0;r<e.length;++r){var o=e[r];if(!l.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(i,s),s+=o.length}return i},l.byteLength=y,l.prototype._isBuffer=!0,l.prototype.swap16=function(){var e=this.length;if(0!=e%2)throw new RangeError('Buffer size must be a multiple of 16-bits');for(var t=0;t<e;t+=2)v(this,t,t+1);return this},l.prototype.swap32=function(){var e=this.length;if(0!=e%4)throw new RangeError('Buffer size must be a multiple of 32-bits');for(var t=0;t<e;t+=4)v(this,t,t+3),v(this,t+1,t+2);return this},l.prototype.swap64=function(){var e=this.length;if(0!=e%8)throw new RangeError('Buffer size must be a multiple of 64-bits');for(var t=0;t<e;t+=8)v(this,t,t+7),v(this,t+1,t+6),v(this,t+2,t+5),v(this,t+3,t+4);return this},l.prototype.toString=function(){var e=0|this.length;return 0==e?'':0===arguments.length?w(this,0,e):_.apply(this,arguments)},l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError('Argument must be a Buffer');return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){var e='',i=t.INSPECT_MAX_BYTES;return 0<this.length&&(e=this.toString('hex',0,i).match(/.{2}/g).join(' '),this.length>i&&(e+=' ... ')),'<Buffer '+e+'>'},l.prototype.compare=function(e,t,r,o,n){if(!l.isBuffer(e))throw new TypeError('Argument must be a Buffer');if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===o&&(o=0),void 0===n&&(n=this.length),0>t||r>e.length||0>o||n>this.length)throw new RangeError('out of range index');if(o>=n&&t>=r)return 0;if(o>=n)return-1;if(t>=r)return 1;if(t>>>=0,r>>>=0,o>>>=0,n>>>=0,this===e)return 0;for(var a=n-o,u=r-t,c=s(a,u),f=this.slice(o,n),d=e.slice(t,r),p=0;p<c;++p)if(f[p]!==d[p]){a=f[p],u=d[p];break}return a<u?-1:u<a?1:0},l.prototype.includes=function(e,t,i){return-1!==this.indexOf(e,t,i)},l.prototype.indexOf=function(e,t,i){return z(this,e,t,i,!0)},l.prototype.lastIndexOf=function(e,t,i){return z(this,e,t,i,!1)},l.prototype.write=function(e,t,i,r){if(void 0===t)r='utf8',i=this.length,t=0;else if(void 0===i&&'string'==typeof t)r=t,i=this.length,t=0;else if(isFinite(t))t|=0,isFinite(i)?(i|=0,void 0===r&&(r='utf8')):(r=i,i=void 0);else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');var s=this.length-t;if((void 0===i||i>s)&&(i=s),0<e.length&&(0>i||0>t)||t>this.length)throw new RangeError('Attempt to write outside buffer bounds');r||(r='utf8');for(var o=!1;;)switch(r){case'hex':return E(this,e,t,i);case'utf8':case'utf-8':return x(this,e,t,i);case'ascii':return A(this,e,t,i);case'latin1':case'binary':return S(this,e,t,i);case'base64':return k(this,e,t,i);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return I(this,e,t,i);default:if(o)throw new TypeError('Unknown encoding: '+r);r=(''+r).toLowerCase(),o=!0;}},l.prototype.toJSON=function(){return{type:'Buffer',data:Array.prototype.slice.call(this._arr||this,0)}};var ie=4096;l.prototype.slice=function(e,t){var r=this.length;e=~~e,t=t===void 0?r:~~t,0>e?(e+=r,0>e&&(e=0)):e>r&&(e=r),0>t?(t+=r,0>t&&(t=0)):t>r&&(t=r),t<e&&(t=e);var s;if(l.TYPED_ARRAY_SUPPORT)s=this.subarray(e,t),s.__proto__=l.prototype;else{var o=t-e;s=new l(o,void 0);for(var n=0;n<o;++n)s[n]=this[n+e]}return s},l.prototype.readUIntLE=function(e,t,r){e|=0,t|=0,r||R(e,t,this.length);for(var s=this[e],o=1,n=0;++n<t&&(o*=256);)s+=this[e+n]*o;return s},l.prototype.readUIntBE=function(e,t,i){e|=0,t|=0,i||R(e,t,this.length);for(var r=this[e+--t],s=1;0<t&&(s*=256);)r+=this[e+--t]*s;return r},l.prototype.readUInt8=function(e,t){return t||R(e,1,this.length),this[e]},l.prototype.readUInt16LE=function(e,t){return t||R(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUInt16BE=function(e,t){return t||R(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUInt32LE=function(e,t){return t||R(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUInt32BE=function(e,t){return t||R(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readIntLE=function(e,t,r){e|=0,t|=0,r||R(e,t,this.length);for(var s=this[e],n=1,a=0;++a<t&&(n*=256);)s+=this[e+a]*n;return n*=128,s>=n&&(s-=o(2,8*t)),s},l.prototype.readIntBE=function(e,t,r){e|=0,t|=0,r||R(e,t,this.length);for(var s=t,i=1,n=this[e+--s];0<s&&(i*=256);)n+=this[e+--s]*i;return i*=128,n>=i&&(n-=o(2,8*t)),n},l.prototype.readInt8=function(e,t){return t||R(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){t||R(e,2,this.length);var i=this[e]|this[e+1]<<8;return 32768&i?4294901760|i:i},l.prototype.readInt16BE=function(e,t){t||R(e,2,this.length);var i=this[e+1]|this[e]<<8;return 32768&i?4294901760|i:i},l.prototype.readInt32LE=function(e,t){return t||R(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return t||R(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readFloatLE=function(e,t){return t||R(e,4,this.length),ee.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return t||R(e,4,this.length),ee.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return t||R(e,8,this.length),ee.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return t||R(e,8,this.length),ee.read(this,e,!1,52,8)},l.prototype.writeUIntLE=function(e,t,r,s){if(e=+e,t|=0,r|=0,!s){var n=o(2,8*r)-1;O(this,e,t,r,n,0)}var a=1,l=0;for(this[t]=255&e;++l<r&&(a*=256);)this[t+l]=255&e/a;return t+r},l.prototype.writeUIntBE=function(e,t,r,s){if(e=+e,t|=0,r|=0,!s){var n=o(2,8*r)-1;O(this,e,t,r,n,0)}var a=r-1,i=1;for(this[t+a]=255&e;0<=--a&&(i*=256);)this[t+a]=255&e/i;return t+r},l.prototype.writeUInt8=function(e,t,i){return e=+e,t|=0,i||O(this,e,t,1,255,0),l.TYPED_ARRAY_SUPPORT||(e=r(e)),this[t]=255&e,t+1},l.prototype.writeUInt16LE=function(e,t,i){return e=+e,t|=0,i||O(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):P(this,e,t,!0),t+2},l.prototype.writeUInt16BE=function(e,t,i){return e=+e,t|=0,i||O(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):P(this,e,t,!1),t+2},l.prototype.writeUInt32LE=function(e,t,i){return e=+e,t|=0,i||O(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):U(this,e,t,!0),t+4},l.prototype.writeUInt32BE=function(e,t,i){return e=+e,t|=0,i||O(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):U(this,e,t,!1),t+4},l.prototype.writeIntLE=function(e,t,r,s){if(e=+e,t|=0,!s){var n=o(2,8*r-1);O(this,e,t,r,n-1,-n)}var a=0,i=1,l=0;for(this[t]=255&e;++a<r&&(i*=256);)0>e&&0==l&&0!==this[t+a-1]&&(l=1),this[t+a]=255&(e/i>>0)-l;return t+r},l.prototype.writeIntBE=function(e,t,r,s){if(e=+e,t|=0,!s){var n=o(2,8*r-1);O(this,e,t,r,n-1,-n)}var a=r-1,i=1,l=0;for(this[t+a]=255&e;0<=--a&&(i*=256);)0>e&&0==l&&0!==this[t+a+1]&&(l=1),this[t+a]=255&(e/i>>0)-l;return t+r},l.prototype.writeInt8=function(e,t,i){return e=+e,t|=0,i||O(this,e,t,1,127,-128),l.TYPED_ARRAY_SUPPORT||(e=r(e)),0>e&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,i){return e=+e,t|=0,i||O(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):P(this,e,t,!0),t+2},l.prototype.writeInt16BE=function(e,t,i){return e=+e,t|=0,i||O(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):P(this,e,t,!1),t+2},l.prototype.writeInt32LE=function(e,t,i){return e=+e,t|=0,i||O(this,e,t,4,2147483647,-2147483648),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):U(this,e,t,!0),t+4},l.prototype.writeInt32BE=function(e,t,i){return e=+e,t|=0,i||O(this,e,t,4,2147483647,-2147483648),0>e&&(e=4294967295+e+1),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):U(this,e,t,!1),t+4},l.prototype.writeFloatLE=function(e,t,i){return V(this,e,t,!0,i)},l.prototype.writeFloatBE=function(e,t,i){return V(this,e,t,!1,i)},l.prototype.writeDoubleLE=function(e,t,i){return j(this,e,t,!0,i)},l.prototype.writeDoubleBE=function(e,t,i){return j(this,e,t,!1,i)},l.prototype.copy=function(e,t,r,s){if(r||(r=0),s||0===s||(s=this.length),t>=e.length&&(t=e.length),t||(t=0),0<s&&s<r&&(s=r),s===r)return 0;if(0===e.length||0===this.length)return 0;if(0>t)throw new RangeError('targetStart out of bounds');if(0>r||r>=this.length)throw new RangeError('sourceStart out of bounds');if(0>s)throw new RangeError('sourceEnd out of bounds');s>this.length&&(s=this.length),e.length-t<s-r&&(s=e.length-t+r);var o,i=s-r;if(this===e&&r<t&&t<s)for(o=i-1;0<=o;--o)e[o+t]=this[o+r];else if(1e3>i||!l.TYPED_ARRAY_SUPPORT)for(o=0;o<i;++o)e[o+t]=this[o+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+i),t);return i},l.prototype.fill=function(e,t,r,s){if('string'==typeof e){if('string'==typeof t?(s=t,t=0,r=this.length):'string'==typeof r&&(s=r,r=this.length),1===e.length){var o=e.charCodeAt(0);256>o&&(e=o)}if(void 0!==s&&'string'!=typeof s)throw new TypeError('encoding must be a string');if('string'==typeof s&&!l.isEncoding(s))throw new TypeError('Unknown encoding: '+s)}else'number'==typeof e&&(e&=255);if(0>t||this.length<t||this.length<r)throw new RangeError('Out of range index');if(r<=t)return this;t>>>=0,r=r===void 0?this.length:r>>>0,e||(e=0);var n;if('number'==typeof e)for(n=t;n<r;++n)this[n]=e;else{var i=l.isBuffer(e)?e:Z(new l(e,s).toString()),a=i.length;for(n=0;n<r-t;++n)this[n+t]=i[n%a]}return this};var re=/[^+\/0-9A-Za-z-_]/g}).call(t,i(2))},function(e,t){'use strict';function r(e){var t=e.length;if(0<t%4)throw new Error('Invalid string. Length must be a multiple of 4');return'='===e[t-2]?2:'='===e[t-1]?1:0}function s(e){var t,i,s,o,n,a=e.length;o=r(e),n=new c(3*a/4-o),i=0<o?a-4:a;var l=0;for(t=0;t<i;t+=4)s=u[e.charCodeAt(t)]<<18|u[e.charCodeAt(t+1)]<<12|u[e.charCodeAt(t+2)]<<6|u[e.charCodeAt(t+3)],n[l++]=255&s>>16,n[l++]=255&s>>8,n[l++]=255&s;return 2===o?(s=u[e.charCodeAt(t)]<<2|u[e.charCodeAt(t+1)]>>4,n[l++]=255&s):1===o&&(s=u[e.charCodeAt(t)]<<10|u[e.charCodeAt(t+1)]<<4|u[e.charCodeAt(t+2)]>>2,n[l++]=255&s>>8,n[l++]=255&s),n}function o(e){return l[63&e>>18]+l[63&e>>12]+l[63&e>>6]+l[63&e]}function n(e,t,r){for(var s,n=[],a=t;a<r;a+=3)s=(e[a]<<16)+(e[a+1]<<8)+e[a+2],n.push(o(s));return n.join('')}function a(e){for(var t,r=e.length,s=r%3,o='',a=[],u=16383,c=0,i=r-s;c<i;c+=u)a.push(n(e,c,c+u>i?i:c+u));return 1==s?(t=e[r-1],o+=l[t>>2],o+=l[63&t<<4],o+='=='):2==s&&(t=(e[r-2]<<8)+e[r-1],o+=l[t>>10],o+=l[63&t>>4],o+=l[63&t<<2],o+='='),a.push(o),a.join('')}t.byteLength=function(e){return 3*e.length/4-r(e)},t.toByteArray=s,t.fromByteArray=a;for(var l=[],u=[],c='undefined'==typeof Uint8Array?Array:Uint8Array,f='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',d=0,i=f.length;d<i;++d)l[d]=f[d],u[f.charCodeAt(d)]=d;u[45]=62,u[95]=63},function(e,t){t.read=function(t,r,n,a,l){var u,e,c=8*l-a-1,f=(1<<c)-1,p=f>>1,h=-7,m=n?l-1:0,i=n?-1:1,d=t[r+m];for(m+=i,u=d&(1<<-h)-1,d>>=-h,h+=c;0<h;u=256*u+t[r+m],m+=i,h-=8);for(e=u&(1<<-h)-1,u>>=-h,h+=a;0<h;e=256*e+t[r+m],m+=i,h-=8);if(0===u)u=1-p;else{if(u===f)return e?NaN:(d?-1:1)*Infinity;e+=o(2,a),u-=p}return(d?-1:1)*e*o(2,u-a)},t.write=function(t,n,a,l,u,f){var p,h,m,c=8*f-u-1,g=(1<<c)-1,b=g>>1,y=23===u?5.960464477539063e-8-6.617444900424222e-24:0,_=l?0:f-1,i=l?1:-1,d=0>n||0===n&&0>1/n?1:0;for(n=Math.abs(n),isNaN(n)||n===Infinity?(h=isNaN(n)?1:0,p=g):(p=r(Math.log(n)/Math.LN2),1>n*(m=o(2,-p))&&(p--,m*=2),n+=1<=p+b?y/m:y*o(2,1-b),2<=n*m&&(p++,m/=2),p+b>=g?(h=0,p=g):1<=p+b?(h=(n*m-1)*o(2,u),p+=b):(h=n*o(2,b-1)*o(2,u),p=0));8<=u;t[a+_]=255&h,_+=i,h/=256,u-=8);for(p=p<<u|h,c+=u;0<c;t[a+_]=255&p,_+=i,p/=256,c-=8);t[a+_-i]|=128*d}},function(e){var t={}.toString;e.exports=Array.isArray||function(e){return'[object Array]'==t.call(e)}},function(){},function(e,t){var i=Number.MAX_VALUE;t.endianness=function(){return'LE'},t.hostname=function(){return'undefined'==typeof location?'':location.hostname},t.loadavg=function(){return[]},t.uptime=function(){return 0},t.freemem=function(){return i},t.totalmem=function(){return i},t.cpus=function(){return[]},t.type=function(){return'Browser'},t.release=function(){return'undefined'==typeof navigator?'':navigator.appVersion},t.networkInterfaces=t.getNetworkInterfaces=function(){return{}},t.arch=function(){return'javascript'},t.platform=function(){return'browser'},t.tmpdir=t.tmpDir=function(){return'/tmp'},t.EOL='\n',t.homedir=function(){return'/'}},function(i){if('undefined'==typeof t){var r=new Error('Cannot find module "undefined"');throw r.code='MODULE_NOT_FOUND',r}i.exports=t},function(t){t.exports=e},function(e){e.exports={version:{desc:'Prints just the compiler\'s version and exits.',type:'boolean',aliases:['v']},help:{desc:'Prints this message and exits.',type:'boolean',aliases:['h']},optimize:{desc:['Optimizes the module. Also accepts the optimize level:','',' -O     Uses defaults. Equivalent to -O2s',' -O0    Equivalent to --optimizeLevel 0',' -O1    Equivalent to --optimizeLevel 1',' -O2    Equivalent to --optimizeLevel 2',' -O3    Equivalent to --optimizeLevel 3',' -Oz    Equivalent to -O but with --shrinkLevel 2',' -O3s   Equivalent to -O3 with --shrinkLevel 1 etc.',''],type:'boolean',aliases:['O']},optimizeLevel:{desc:'How much to focus on optimizing code. [0-3]',type:'number'},shrinkLevel:{desc:'How much to focus on shrinking code size. [0-2, s=1, z=2]',type:'number'},validate:{desc:'Validates the module using Binaryen. Exits if invalid.',type:'boolean',aliases:['c','check']},baseDir:{desc:'Specifies the base directory of input and output files.',type:'string'},outFile:{desc:'Specifies the output file. File extension indicates format.',type:'string',aliases:['o']},binaryFile:{desc:'Specifies the binary output file (.wasm).',type:'string',aliases:['b']},textFile:{desc:'Specifies the text output file (.wat).',type:'string',aliases:['t']},asmjsFile:{desc:'Specifies the asm.js output file (.js).',type:'string',aliases:['a']},sourceMap:{desc:['Enables source map generation. Optionally takes the URL','used to reference the source map from the binary file.'],type:'string'},noTreeShaking:{desc:'Disables compiler-level tree-shaking, compiling everything.',type:'boolean'},noDebug:{desc:'Disables maintaining of debug information in binaries.',type:'boolean'},noAssert:{desc:'Replaces assertions with just their value without trapping.',type:'boolean'},noEmit:{desc:'Performs compilation as usual but does not emit code.',type:'boolean'},noMemory:{desc:'Does not set up a memory. Useful for low-level WebAssembly.',type:'boolean'},memoryBase:{desc:'Sets the start offset of compiler-generated static memory.',type:'number'},noLib:{desc:'Does not include the shipped standard library.',type:'boolean'},lib:{desc:['Adds one or multiple paths to custom library components and','uses exports of all top-level files at this path as globals.'],type:'string'},trapMode:{desc:['Sets the trap mode to use.','',' allow  Allow trapping operations. This is the default.',' clamp  Replace trapping operations with clamping semantics.',' js     Replace trapping operations with JS semantics.',''],type:'string',default:'allow'},runPasses:{desc:['Specifies additional Binaryen passes to run after other','optimizations, if any. See: Binaryen/src/passes/pass.cpp'],type:'string'},measure:{desc:'Prints measuring information on I/O and compile times.',type:'boolean'}}},function(e){function t(e,t){var i=e;t.slice(0,-1).forEach(function(e){i=i[e]||{}});var r=t[t.length-1];return r in i}function r(e){return!('number'!=typeof e)||!!/^0x[0-9a-f]+$/i.test(e)||/^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(e)}e.exports=function(e,s){function o(e,t){return u.allBools&&/^--[^=]+$/.test(t)||u.strings[e]||u.bools[e]||c[e]}function n(e,t,i){if(!(i&&u.unknownFn&&!o(e,i)&&!1===u.unknownFn(i))){var s=!u.strings[e]&&r(t)?+t:t;a(d,e.split('.'),s),(c[e]||[]).forEach(function(e){a(d,e.split('.'),s)})}}function a(e,t,i){var r=e;t.slice(0,-1).forEach(function(e){void 0===r[e]&&(r[e]={}),r=r[e]});var s=t[t.length-1];void 0===r[s]||u.bools[s]||'boolean'==typeof r[s]?r[s]=i:Array.isArray(r[s])?r[s].push(i):r[s]=[r[s],i]}function l(e){return c[e].some(function(e){return u.bools[e]})}s||(s={});var u={bools:{},strings:{},unknownFn:null};'function'==typeof s.unknown&&(u.unknownFn=s.unknown),'boolean'==typeof s.boolean&&s.boolean?u.allBools=!0:[].concat(s.boolean).filter(Boolean).forEach(function(e){u.bools[e]=!0});var c={};Object.keys(s.alias||{}).forEach(function(e){c[e]=[].concat(s.alias[e]),c[e].forEach(function(t){c[t]=[e].concat(c[e].filter(function(e){return t!==e}))})}),[].concat(s.string).filter(Boolean).forEach(function(e){u.strings[e]=!0,c[e]&&(u.strings[c[e]]=!0)});var f=s['default']||{},d={_:[]};Object.keys(u.bools).forEach(function(e){n(e,void 0!==f[e]&&f[e])});var p=[];-1!==e.indexOf('--')&&(p=e.slice(e.indexOf('--')+1),e=e.slice(0,e.indexOf('--')));for(var h,g=0;g<e.length;g++)if(h=e[g],/^--.+=/.test(h)){var i=h.match(/^--([^=]+)=([\s\S]*)$/),m=i[1],b=i[2];u.bools[m]&&(b='false'!==b),n(m,b,h)}else if(/^--no-.+/.test(h)){var m=h.match(/^--no-(.+)/)[1];n(m,!1,h)}else if(/^--.+/.test(h)){var m=h.match(/^--(.+)/)[1],y=e[g+1];void 0===y||/^-/.test(y)||u.bools[m]||u.allBools||!!c[m]&&!!l(m)?/^(true|false)$/.test(y)?(n(m,'true'===y,h),g++):n(m,!u.strings[m]||'',h):(n(m,y,h),g++)}else if(/^-[^-]+/.test(h)){for(var y,_=h.slice(1,-1).split(''),v=!1,z=0;z<_.length;z++){if(y=h.slice(z+2),'-'===y){n(_[z],y,h);continue}if(/[A-Za-z]/.test(_[z])&&/=/.test(y)){n(_[z],y.split('=')[1],h),v=!0;break}if(/[A-Za-z]/.test(_[z])&&/-?\d+(\.\d*)?(e-?\d+)?$/.test(y)){n(_[z],y,h),v=!0;break}if(_[z+1]&&_[z+1].match(/\W/)){n(_[z],h.slice(z+2),h),v=!0;break}else n(_[z],!u.strings[_[z]]||'',h)}var m=h.slice(-1)[0];v||'-'===m||(!e[g+1]||/^(-|--)[^-]/.test(e[g+1])||u.bools[m]||c[m]&&l(m)?e[g+1]&&/true|false/.test(e[g+1])?(n(m,'true'===e[g+1],h),g++):n(m,!u.strings[m]||'',h):(n(m,e[g+1],h),g++))}else if(u.unknownFn&&!1===u.unknownFn(h)||d._.push(u.strings._||!r(h)?h:+h),s.stopEarly){d._.push.apply(d._,e.slice(g+1));break}return Object.keys(f).forEach(function(e){t(d,e.split('.'))||(a(d,e.split('.'),f[e]),(c[e]||[]).forEach(function(t){a(d,t.split('.'),f[e])}))}),s['--']?(d['--']=[],p.forEach(function(e){d['--'].push(e)})):p.forEach(function(e){d._.push(e)}),d}},function(e,t,i){(function(t,i){e.exports=t.hrtime||function(e){var t=1e-3*o.call(s),i=r(t),n=r(1e9*(t%1));return e&&(i-=e[0],n-=e[1],0>n&&(i--,n+=1e9)),[i,n]};var s=i.performance||{},o=s.now||s.mozNow||s.msNow||s.oNow||s.webkitNow||function(){return new Date().getTime()}}).call(t,i(0),i(2))}])});