!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(function(){try{return require("assemblyscript")}catch(e){}}()):"function"==typeof define&&define.amd?define(["assemblyscript"],n):"object"==typeof exports?exports.asc=n(function(){try{return require("assemblyscript")}catch(e){}}()):e.asc=n(e.assemblyscript)}("undefined"!=typeof self?self:this,function(__WEBPACK_EXTERNAL_MODULE__6__){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)t.d(r,i,function(n){return e[n]}.bind(null,i));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=12)}([function(e,n,t){n.nextTick=function(e){setTimeout(e,0)},n.platform=n.arch=n.execPath=n.title="browser",n.pid=1,n.browser=!0,n.env={},n.argv=[],n.binding=function(e){throw new Error("No such module. (Possibly not yet loaded)")},function(){var e,r="/";n.cwd=function(){return r},n.chdir=function(n){e||(e=t(2)),r=e.resolve(n,r)}}(),n.exit=n.kill=n.umask=n.dlopen=n.uptime=n.memoryUsage=n.uvCounters=function(){},n.features={}},function(e,n){var t;t=function(){return this}();try{t=t||Function("return this")()||(0,eval)("this")}catch(e){"object"==typeof window&&(t=window)}e.exports=t},function(e,n,t){(function(e){function t(e,n){for(var t=0,r=e.length-1;r>=0;r--){var i=e[r];"."===i?e.splice(r,1):".."===i?(e.splice(r,1),t++):t&&(e.splice(r,1),t--)}if(n)for(;t--;t)e.unshift("..");return e}var r=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,i=function(e){return r.exec(e).slice(1)};function s(e,n){if(e.filter)return e.filter(n);for(var t=[],r=0;r<e.length;r++)n(e[r],r,e)&&t.push(e[r]);return t}n.resolve=function(){for(var n="",r=!1,i=arguments.length-1;i>=-1&&!r;i--){var a=i>=0?arguments[i]:e.cwd();if("string"!=typeof a)throw new TypeError("Arguments to path.resolve must be strings");a&&(n=a+"/"+n,r="/"===a.charAt(0))}return n=t(s(n.split("/"),function(e){return!!e}),!r).join("/"),(r?"/":"")+n||"."},n.normalize=function(e){var r=n.isAbsolute(e),i="/"===a(e,-1);return(e=t(s(e.split("/"),function(e){return!!e}),!r).join("/"))||r||(e="."),e&&i&&(e+="/"),(r?"/":"")+e},n.isAbsolute=function(e){return"/"===e.charAt(0)},n.join=function(){var e=Array.prototype.slice.call(arguments,0);return n.normalize(s(e,function(e,n){if("string"!=typeof e)throw new TypeError("Arguments to path.join must be strings");return e}).join("/"))},n.relative=function(e,t){function r(e){for(var n=0;n<e.length&&""===e[n];n++);for(var t=e.length-1;t>=0&&""===e[t];t--);return n>t?[]:e.slice(n,t-n+1)}e=n.resolve(e).substr(1),t=n.resolve(t).substr(1);for(var i=r(e.split("/")),s=r(t.split("/")),a=Math.min(i.length,s.length),o=a,l=0;l<a;l++)if(i[l]!==s[l]){o=l;break}var f=[];for(l=o;l<i.length;l++)f.push("..");return(f=f.concat(s.slice(o))).join("/")},n.sep="/",n.delimiter=":",n.dirname=function(e){var n=i(e),t=n[0],r=n[1];return t||r?(r&&(r=r.substr(0,r.length-1)),t+r):"."},n.basename=function(e,n){var t=i(e)[2];return n&&t.substr(-1*n.length)===n&&(t=t.substr(0,t.length-n.length)),t},n.extname=function(e){return i(e)[3]};var a="b"==="ab".substr(-1)?function(e,n,t){return e.substr(n,t)}:function(e,n,t){return n<0&&(n=e.length+n),e.substr(n,t)}}).call(this,t(0))},function(e,n,t){(function(n,t){e.exports=n.hrtime||function(e){var n=.001*i.call(r),t=Math.floor(n),s=Math.floor(n%1*1e9);e&&(t-=e[0],(s-=e[1])<0&&(t--,s+=1e9));return[t,s]};var r=t.performance||{},i=r.now||r.mozNow||r.msNow||r.oNow||r.webkitNow||function(){return(new Date).getTime()}}).call(this,t(0),t(1))},function(e,n){function t(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}t.keys=function(){return[]},t.resolve=t,e.exports=t,t.id=4},function(e){e.exports={version:{description:"Prints just the compiler's version and exits.",type:"b",alias:"v"},help:{description:"Prints this message and exits.",type:"b",alias:"h"},optimize:{description:["Optimizes the module. Also has the usual shorthands:",""," -O     Uses defaults. Equivalent to -O2s"," -O0    Equivalent to --optimizeLevel 0"," -O1    Equivalent to --optimizeLevel 1"," -O2    Equivalent to --optimizeLevel 2"," -O3    Equivalent to --optimizeLevel 3"," -Oz    Equivalent to -O but with --shrinkLevel 2"," -O3s   Equivalent to -O3 with --shrinkLevel 1 etc.",""],type:"b",alias:"O"},optimizeLevel:{description:"How much to focus on optimizing code. [0-3]",type:"i"},shrinkLevel:{description:"How much to focus on shrinking code size. [0-2, s=1, z=2]",type:"i"},validate:{description:"Validates the module using Binaryen. Exits if invalid.",type:"b",alias:"c",default:!1},baseDir:{description:"Specifies the base directory of input and output files.",type:"s",default:"."},outFile:{description:"Specifies the output file. File extension indicates format.",type:"s",alias:"o"},binaryFile:{description:"Specifies the binary output file (.wasm).",type:"s",alias:"b"},textFile:{description:"Specifies the text output file (.wat).",type:"s",alias:"t"},asmjsFile:{description:"Specifies the asm.js output file (.js).",type:"s",alias:"a"},idlFile:{description:"Specifies the WebIDL output file (.webidl).",type:"s",alias:"i"},tsdFile:{description:"Specifies the TypeScript definition output file (.d.ts).",type:"s",alias:"d"},sourceMap:{description:["Enables source map generation. Optionally takes the URL","used to reference the source map from the binary file."],type:"s"},noTreeShaking:{description:"Disables compiler-level tree-shaking, compiling everything.",type:"b",default:!1},noDebug:{description:"Disables maintaining of debug information in binaries.",type:"b",default:!1},noAssert:{description:"Replaces assertions with just their value without trapping.",type:"b",default:!1},noEmit:{description:"Performs compilation as usual but does not emit code.",type:"b",default:!1},importMemory:{description:"Imports the memory instance provided by the embedder.",type:"b",default:!1},memoryBase:{description:"Sets the start offset of compiler-generated static memory.",type:"i",default:0},importTable:{description:"Imports the function table instance provided by the embedder.",type:"b",default:!1},noLib:{description:"Does not include the shipped standard library.",type:"b",default:!1},lib:{description:["Adds one or multiple paths to custom library components and","uses exports of all top-level files at this path as globals."],type:"s"},use:{description:["Aliases a global object under another name, e.g., to switch","the default 'Math' implementation used: --use Math=JSMath"],type:"S",alias:"u"},trapMode:{description:["Sets the trap mode to use.",""," allow  Allow trapping operations. This is the default."," clamp  Replace trapping operations with clamping semantics."," js     Replace trapping operations with JS semantics.",""],type:"s",default:"allow"},runPasses:{description:["Specifies additional Binaryen passes to run after other","optimizations, if any. See: Binaryen/src/passes/pass.cpp"],type:"s"},enable:{description:["Enables additional (experimental) WebAssembly features.",""," sign-extension  Enables sign-extension operations"," mutable-global  Enables mutable global imports and exports",""],type:"s"},transform:{description:"Specifies the path to a custom transform to 'require'.",type:"S"},measure:{description:"Prints measuring information on I/O and compile times.",type:"b",default:!1},noColors:{description:"Disables terminal colors.",type:"b",default:!1},"-Os":{value:{optimize:!0,shrinkLevel:1}},"-Oz":{value:{optimize:!0,shrinkLevel:2}},"-O0":{value:{optimizeLevel:0,shrinkLevel:0}},"-O1":{value:{optimizeLevel:1,shrinkLevel:0}},"-O2":{value:{optimizeLevel:2,shrinkLevel:0}},"-O3":{value:{optimizeLevel:3,shrinkLevel:0}},"-O0s":{value:{optimizeLevel:0,shrinkLevel:1}},"-O1s":{value:{optimizeLevel:1,shrinkLevel:1}},"-O2s":{value:{optimizeLevel:2,shrinkLevel:1}},"-O3s":{value:{optimizeLevel:3,shrinkLevel:1}},"-O0z":{value:{optimizeLevel:0,shrinkLevel:2}},"-O1z":{value:{optimizeLevel:1,shrinkLevel:2}},"-O2z":{value:{optimizeLevel:2,shrinkLevel:2}},"-O3z":{value:{optimizeLevel:3,shrinkLevel:2}}}},function(e,n){if(void 0===__WEBPACK_EXTERNAL_MODULE__6__){var t=new Error("Cannot find module 'assemblyscript'");throw t.code="MODULE_NOT_FOUND",t}e.exports=__WEBPACK_EXTERNAL_MODULE__6__},function(e,n){n.parse=function(e,n){var t={},r=[],arguments=[],i=[],s={};Object.keys(n).forEach(e=>{var r=n[e];null!=r.alias&&("string"==typeof r.alias?s[r.alias]=e:Array.isArray(r.alias)&&r.alias.forEach(n=>s[n]=e)),null!=r.default&&(t[e]=r.default)});for(var a=0,o=(e=e.slice()).length;a<o;++a){let i=e[a];if("--"==i){++a;break}let o,l,f=/^(?:(\-\w)(?:=(.*))?|(\-\-\w{2,})(?:=(.*))?)$/.exec(i);if(f)n[i]?o=n[l=i]:null!=f[1]?(o=n[l=s[f[1].substring(1)]])&&null!=f[2]&&(e[a--]=f[2]):null!=f[3]&&(o=n[l=f[3].substring(2)])&&null!=f[4]&&(e[a--]=f[4]);else{if(45!=i.charCodeAt(0)){arguments.push(i);continue}o=n[l=i]}if(o){if(null==o.type||"b"===o.type)t[l]=!0;else if(a+1<e.length&&45!=e[a+1].charCodeAt(0))switch(o.type){case"i":t[l]=parseInt(e[++a],10);break;case"I":t[l]=(t[l]||[]).concat(parseInt(e[++a],10));break;case"f":t[l]=parseFloat(e[++a]);break;case"F":t[l]=(t[l]||[]).concat(parseFloat(e[++a]));break;case"s":t[l]=String(e[++a]);break;case"S":t[l]=(t[l]||[]).concat(e[++a].split(","));break;default:r.push(i),--a}else switch(o.type){case"i":case"f":t[l]=o.default||0;break;case"s":t[l]=o.default||"";break;case"I":case"F":case"S":t[l]=t.default||[];break;default:r.push(i)}o.value&&Object.keys(o.value).forEach(e=>t[e]=o.value[e])}else r.push(i)}for(;a<o;)i.push(e[a++]);return{options:t,unknown:r,arguments:arguments,trailing:i}},n.help=function(e,n){n||(n={});var t=n.indent||2,r=n.padding||24,i=n.eol||"\n",s=[];return Object.keys(e).forEach(n=>{var a=e[n];if(null!=a.description){for(var o="";o.length<t;)o+=" ";for(o+="--"+n,a.alias&&(o+=", -"+a.alias);o.length<r;)o+=" ";Array.isArray(a.description)?s.push(o+a.description[0]+a.description.slice(1).map(e=>{for(let n=0;n<r;++n)e=" "+e;return i+e}).join("")):s.push(o+a.description)}}),s.join(i)}},function(e,n,t){(function(e){var t=void 0!==e&&e||{},r=t.env&&"CI"in t.env;function i(e,t){var i=t||{};return i.supported=e&&!!e.isTTY||r,i.gray=(e=>i.supported?n.GRAY+e+n.RESET:e),i.red=(e=>i.supported?n.RED+e+n.RESET:e),i.green=(e=>i.supported?n.GREEN+e+n.RESET:e),i.yellow=(e=>i.supported?n.YELLOW+e+n.RESET:e),i.blue=(e=>i.supported?n.BLUE+e+n.RESET:e),i.magenta=(e=>i.supported?n.MAGENTA+e+n.RESET:e),i.cyan=(e=>i.supported?n.CYAN+e+n.RESET:e),i.white=(e=>i.supported?n.WHITE+e+n.RESET:e),i}n.stdout=i(t.stdout,n),n.stderr=i(t.stderr),n.from=i,n.GRAY="[90m",n.RED="[91m",n.GREEN="[92m",n.YELLOW="[93m",n.BLUE="[94m",n.MAGENTA="[95m",n.CYAN="[96m",n.WHITE="[97m",n.RESET="[0m"}).call(this,t(0))},function(e,n,t){"use strict";var r=n;r.length=function(e){for(var n=0,t=0,r=0;r<e.length;++r)(t=e.charCodeAt(r))<128?n+=1:t<2048?n+=2:55296==(64512&t)&&56320==(64512&e.charCodeAt(r+1))?(++r,n+=4):n+=3;return n},r.read=function(e,n,t){if(t-n<1)return"";for(var r,i=null,s=[],a=0;n<t;)(r=e[n++])<128?s[a++]=r:r>191&&r<224?s[a++]=(31&r)<<6|63&e[n++]:r>239&&r<365?(r=((7&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,s[a++]=55296+(r>>10),s[a++]=56320+(1023&r)):s[a++]=(15&r)<<12|(63&e[n++])<<6|63&e[n++],a>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,s)),a=0);return i?(a&&i.push(String.fromCharCode.apply(String,s.slice(0,a))),i.join("")):String.fromCharCode.apply(String,s.slice(0,a))},r.write=function(e,n,t){for(var r,i,s=t,a=0;a<e.length;++a)(r=e.charCodeAt(a))<128?n[t++]=r:r<2048?(n[t++]=r>>6|192,n[t++]=63&r|128):55296==(64512&r)&&56320==(64512&(i=e.charCodeAt(a+1)))?(r=65536+((1023&r)<<10)+(1023&i),++a,n[t++]=r>>18|240,n[t++]=r>>12&63|128,n[t++]=r>>6&63|128,n[t++]=63&r|128):(n[t++]=r>>12|224,n[t++]=r>>6&63|128,n[t++]=63&r|128);return t-s}},function(e,n){},function(module,exports,__webpack_require__){(function(process,global){process.browser&&(process.cwd=function(){return"."});const fs=__webpack_require__(10),path=__webpack_require__(2),utf8=__webpack_require__(9),colorsUtil=__webpack_require__(8),optionsUtil=__webpack_require__(7),EOL="win32"===process.platform?"\r\n":"\n";process.removeAllListeners&&process.removeAllListeners("uncaughtException");var assemblyscript,isDev=!1;(()=>{try{assemblyscript=__webpack_require__(6)}catch(e){try{__webpack_require__(!function(){var e=new Error("Cannot find module 'ts-node'");throw e.code="MODULE_NOT_FOUND",e}()).register({project:path.join(".","..","src","tsconfig.json")}),__webpack_require__(!function(){var e=new Error("Cannot find module '../src/glue/js'");throw e.code="MODULE_NOT_FOUND",e}()),assemblyscript=__webpack_require__(!function(){var e=new Error("Cannot find module '../src'");throw e.code="MODULE_NOT_FOUND",e}()),isDev=!0}catch(e_ts){try{assemblyscript=eval("require('./assemblyscript')")}catch(e){throw e.stack=e_ts.stack+"\n---\n"+e.stack,e}}}})(),exports.isBundle=!0,exports.isDev=isDev,exports.version=exports.isBundle?"0.5.0":__webpack_require__(!function(){var e=new Error("Cannot find module '../package.json'");throw e.code="MODULE_NOT_FOUND",e}()).version,exports.options=__webpack_require__(5),exports.sourceMapRoot="assemblyscript:///",exports.libraryPrefix=assemblyscript.LIBRARY_PREFIX,exports.defaultOptimizeLevel=2,exports.defaultShrinkLevel=1,exports.libraryFiles=exports.isBundle?Object({"allocator/arena":'/**\n * Arena Memory Allocator\n *\n * Provides a `memory.reset` function to reset the heap to its initial state. A user has to make\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/arena\n *//***/\n\nimport { AL_MASK, MAX_SIZE_32 } from "../internal/allocator";\n\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\nvar offset: usize = startOffset;\n\n// Memory allocator interface\n\n@global export function __memory_allocate(size: usize): usize {\n  if (size) {\n    if (size > MAX_SIZE_32) unreachable();\n    let ptr = offset;\n    let newPtr = (ptr + size + AL_MASK) & ~AL_MASK;\n    let pagesBefore = memory.size();\n    if (newPtr > <usize>pagesBefore << 16) {\n      let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n      let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n      if (memory.grow(pagesWanted) < 0) {\n        if (memory.grow(pagesNeeded) < 0) {\n          unreachable(); // out of memory\n        }\n      }\n    }\n    offset = newPtr;\n    return ptr;\n  }\n  return 0;\n}\n\n@global export function __memory_free(ptr: usize): void { /* nop */ }\n\n@global export function __memory_reset(): void {\n  offset = startOffset;\n}\n',"allocator/buddy":'/**\n * Buddy Memory Allocator.\n * @module std/assembly/allocator/buddy\n *//***/\n\n/*\n  Copyright 2018 Evan Wallace\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the "Software"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n*/// see: https://github.com/evanw/buddy-malloc\n\n/*\n * This file implements a buddy memory allocator, which is an allocator that\n * allocates memory within a fixed linear address range. It spans the address\n * range with a binary tree that tracks free space. Both "malloc" and "free"\n * are O(log N) time where N is the maximum possible number of allocations.\n *\n * The "buddy" term comes from how the tree is used. When memory is allocated,\n * nodes in the tree are split recursively until a node of the appropriate size\n * is reached. Every split results in two child nodes, each of which is the\n * buddy of the other. When a node is freed, the node and its buddy can be\n * merged again if the buddy is also free. This makes the memory available\n * for larger allocations again.\n */\n\n/*\n * Every allocation needs an 8-byte header to store the allocation size while\n * staying 8-byte aligned. The address returned by "malloc" is the address\n * right after this header (i.e. the size occupies the 8 bytes before the\n * returned address).\n */\nconst HEADER_SIZE: usize = 8;\n\n/*\n * The minimum allocation size is 16 bytes because we have an 8-byte header and\n * we need to stay 8-byte aligned.\n */\nconst MIN_ALLOC_LOG2: usize = 4;\nconst MIN_ALLOC: usize = 1 << MIN_ALLOC_LOG2;\n\n/*\n * The maximum allocation size is currently set to 2gb. This is the total size\n * of the heap. It\'s technically also the maximum allocation size because the\n * heap could consist of a single allocation of this size. But of course real\n * heaps will have multiple allocations, so the real maximum allocation limit\n * is at most 1gb.\n */\nconst MAX_ALLOC_LOG2: usize = 30; // 31;\nconst MAX_ALLOC: usize = 1 << MAX_ALLOC_LOG2;\n\n/*\n * Allocations are done in powers of two starting from MIN_ALLOC and ending at\n * MAX_ALLOC inclusive. Each allocation size has a bucket that stores the free\n * list for that allocation size.\n *\n * Given a bucket index, the size of the allocations in that bucket can be\n * found with "(size_t)1 << (MAX_ALLOC_LOG2 - bucket)".\n */\nconst BUCKET_COUNT: usize = MAX_ALLOC_LOG2 - MIN_ALLOC_LOG2 + 1;\n\n/*\n * Free lists are stored as circular doubly-linked lists. Every possible\n * allocation size has an associated free list that is threaded through all\n * currently free blocks of that size. That means MIN_ALLOC must be at least\n * "sizeof(list_t)". MIN_ALLOC is currently 16 bytes, so this will be true for\n * both 32-bit and 64-bit.\n */\n@unmanaged\nclass List {\n  prev: List;\n  next: List;\n  static readonly SIZE: usize = 2 * sizeof<usize>();\n}\n\n/*\n * Each bucket corresponds to a certain allocation size and stores a free list\n * for that size. The bucket at index 0 corresponds to an allocation size of\n * MAX_ALLOC (i.e. the whole address space).\n */\nvar BUCKETS_START: usize = HEAP_BASE;\nvar BUCKETS_END: usize = BUCKETS_START + BUCKET_COUNT * List.SIZE;\n\nfunction buckets$get(index: usize): List {\n  assert(index < BUCKET_COUNT);\n  return changetype<List>(BUCKETS_START + index * List.SIZE);\n}\n\n/*\n * We could initialize the allocator by giving it one free block the size of\n * the entire address space. However, this would cause us to instantly reserve\n * half of the entire address space on the first allocation, since the first\n * split would store a free list entry at the start of the right child of the\n * root. Instead, we have the tree start out small and grow the size of the\n * tree as we use more memory. The size of the tree is tracked by this value.\n */\nvar bucket_limit: usize;\n\n/*\n * This array represents a linearized binary tree of bits. Every possible\n * allocation larger than MIN_ALLOC has a node in this tree (and therefore a\n * bit in this array).\n *\n * Given the index for a node, lineraized binary trees allow you to traverse to\n * the parent node or the child nodes just by doing simple arithmetic on the\n * index:\n *\n * - Move to parent:         index = (index - 1) / 2;\n * - Move to left child:     index = index * 2 + 1;\n * - Move to right child:    index = index * 2 + 2;\n * - Move to sibling:        index = ((index - 1) ^ 1) + 1;\n *\n * Each node in this tree can be in one of several states:\n *\n * - UNUSED (both children are UNUSED)\n * - SPLIT (one child is UNUSED and the other child isn\'t)\n * - USED (neither children are UNUSED)\n *\n * These states take two bits to store. However, it turns out we have enough\n * information to distinguish between UNUSED and USED from context, so we only\n * need to store SPLIT or not, which only takes a single bit.\n *\n * Note that we don\'t need to store any nodes for allocations of size MIN_ALLOC\n * since we only ever care about parent nodes.\n */\nconst SPLIT_COUNT: usize = (1 << (BUCKET_COUNT - 1)) / 8;\nvar NODE_IS_SPLIT_START: usize = BUCKETS_END;\nvar NODE_IS_SPLIT_END: usize = NODE_IS_SPLIT_START + SPLIT_COUNT * sizeof<u8>();\n\nfunction node_is_split$get(index: usize): i32 {\n  assert(index < SPLIT_COUNT);\n  return load<u8>(NODE_IS_SPLIT_START + index);\n}\n\nfunction node_is_split$set(index: usize, state: i32): void {\n  assert(index < SPLIT_COUNT);\n  store<u8>(NODE_IS_SPLIT_START + index, state);\n}\n\n/*\n * This is the starting address of the address range for this allocator. Every\n * returned allocation will be an offset of this pointer from 0 to MAX_ALLOC.\n */\nvar base_ptr: usize;\n\n/*\n * This is the maximum address that has ever been used by the allocator. It\'s\n * used to know when to call "brk" to request more memory from the kernel.\n */\nvar max_ptr: usize;\n\n/*\n * Make sure all addresses before "new_value" are valid and can be used. Memory\n * is allocated in a 2gb address range but that memory is not reserved up\n * front. It\'s only reserved when it\'s needed by calling this function. This\n * will return false if the memory could not be reserved.\n */\nfunction update_max_ptr(new_value: usize): i32 {\n  if (new_value > max_ptr) {\n    // if (brk(new_value)) {\n    //   return 0;\n    // }\n    let oldPages = <i32>memory.size();\n    let newPages = <i32>(((new_value + 0xffff) & ~0xffff) >>> 16);\n    assert(newPages > oldPages);\n    if (memory.grow(newPages - oldPages) < 0) {\n      return 0;\n    }\n    // max_ptr = new_value;\n    max_ptr = <usize>newPages << 16;\n  }\n  return 1;\n}\n\n/*\n * Initialize a list to empty. Because these are circular lists, an "empty"\n * list is an entry where both links point to itself. This makes insertion\n * and removal simpler because they don\'t need any branches.\n */\nfunction list_init(list: List): void {\n  list.prev = list;\n  list.next = list;\n}\n\n/*\n * Append the provided entry to the end of the list. This assumes the entry\n * isn\'t in a list already because it overwrites the linked list pointers.\n */\nfunction list_push(list: List, entry: List): void {\n  var prev = list.prev;\n  entry.prev = prev;\n  entry.next = list;\n  prev.next = entry;\n  list.prev = entry;\n}\n\n/*\n * Remove the provided entry from whichever list it\'s currently in. This\n * assumes that the entry is in a list. You don\'t need to provide the list\n * because the lists are circular, so the list\'s pointers will automatically\n * be updated if the first or last entries are removed.\n */\nfunction list_remove(entry: List): void {\n  var prev = entry.prev;\n  var next = entry.next;\n  prev.next = next;\n  next.prev = prev;\n}\n\n/*\n * Remove and return the first entry in the list or NULL if the list is empty.\n */\nfunction list_pop(list: List): List | null {\n  var back = list.prev;\n  if (back == list) return null;\n  list_remove(back);\n  return back;\n}\n\n/*\n * This maps from the index of a node to the address of memory that node\n * represents. The bucket can be derived from the index using a loop but is\n * required to be provided here since having them means we can avoid the loop\n * and have this function return in constant time.\n */\nfunction ptr_for_node(index: usize, bucket: usize): usize {\n  return base_ptr + ((index - (1 << bucket) + 1) << (MAX_ALLOC_LOG2 - bucket));\n}\n\n/*\n * This maps from an address of memory to the node that represents that\n * address. There are often many nodes that all map to the same address, so\n * the bucket is needed to uniquely identify a node.\n */\nfunction node_for_ptr(ptr: usize, bucket: usize): usize {\n  return ((ptr - base_ptr) >> (MAX_ALLOC_LOG2 - bucket)) + (1 << bucket) - 1;\n}\n\n/*\n * Given the index of a node, this returns the "is split" flag of the parent.\n */\nfunction parent_is_split(index: usize): bool {\n  index = (index - 1) / 2;\n  return ((node_is_split$get(index / 8) >>> <i32>(index % 8)) & 1) == 1;\n}\n\n/*\n * Given the index of a node, this flips the "is split" flag of the parent.\n */\nfunction flip_parent_is_split(index: usize): void {\n  index = (index - 1) / 2;\n  var indexDiv8 = index / 8;\n  node_is_split$set(indexDiv8,\n    node_is_split$get(indexDiv8) ^ <i32>(1 << (index % 8))\n  );\n}\n\n/*\n * Given the requested size passed to "malloc", this function returns the index\n * of the smallest bucket that can fit that size.\n */\nfunction bucket_for_request(request: usize): usize {\n  var bucket = BUCKET_COUNT - 1;\n  var size = MIN_ALLOC;\n\n  while (size < request) {\n    bucket--;\n    size *= 2;\n  }\n\n  return bucket;\n}\n\n/*\n * The tree is always rooted at the current bucket limit. This call grows the\n * tree by repeatedly doubling it in size until the root lies at the provided\n * bucket index. Each doubling lowers the bucket limit by 1.\n */\nfunction lower_bucket_limit(bucket: usize): u32 {\n  while (bucket < bucket_limit) {\n    let root = node_for_ptr(base_ptr, bucket_limit);\n    let right_child: usize;\n\n    /*\n     * If the parent isn\'t SPLIT, that means the node at the current bucket\n     * limit is UNUSED and our address space is entirely free. In that case,\n     * clear the root free list, increase the bucket limit, and add a single\n     * block with the newly-expanded address space to the new root free list.\n     */\n    if (!parent_is_split(root)) {\n      list_remove(changetype<List>(base_ptr));\n      list_init(buckets$get(--bucket_limit));\n      list_push(buckets$get(bucket_limit), changetype<List>(base_ptr));\n      continue;\n    }\n\n    /*\n     * Otherwise, the tree is currently in use. Create a parent node for the\n     * current root node in the SPLIT state with a right child on the free\n     * list. Make sure to reserve the memory for the free list entry before\n     * writing to it. Note that we do not need to flip the "is split" flag for\n     * our current parent because it\'s already on (we know because we just\n     * checked it above).\n     */\n    right_child = ptr_for_node(root + 1, bucket_limit);\n    if (!update_max_ptr(right_child + List.SIZE)) {\n      return 0;\n    }\n    list_push(buckets$get(bucket_limit), changetype<List>(right_child));\n    list_init(buckets$get(--bucket_limit));\n\n    /*\n     * Set the grandparent\'s SPLIT flag so if we need to lower the bucket limit\n     * again, we\'ll know that the new root node we just added is in use.\n     */\n    root = (root - 1) / 2;\n    if (root != 0) {\n      flip_parent_is_split(root);\n    }\n  }\n\n  return 1;\n}\n\n// Memory allocator interface\n\n@global export function __memory_allocate(request: usize): usize {\n  var original_bucket: usize, bucket: usize;\n\n  /*\n   * Make sure it\'s possible for an allocation of this size to succeed. There\'s\n   * a hard-coded limit on the maximum allocation size because of the way this\n   * allocator works.\n   */\n  if (request > MAX_ALLOC - HEADER_SIZE) unreachable();\n\n  /*\n   * Initialize our global state if this is the first call to "malloc". At the\n   * beginning, the tree has a single node that represents the smallest\n   * possible allocation size. More memory will be reserved later as needed.\n   */\n  if (base_ptr == 0) {\n    // base_ptr = max_ptr = (uint8_t *)sbrk(0);\n    base_ptr = (NODE_IS_SPLIT_END + 7) & ~7; // must be aligned\n    max_ptr = <usize>memory.size() << 16; // must grow first\n    bucket_limit = BUCKET_COUNT - 1;\n    if (!update_max_ptr(base_ptr + List.SIZE)) {\n      return 0;\n    }\n    list_init(buckets$get(BUCKET_COUNT - 1));\n    list_push(buckets$get(BUCKET_COUNT - 1), changetype<List>(base_ptr));\n  }\n\n  /*\n   * Find the smallest bucket that will fit this request. This doesn\'t check\n   * that there\'s space for the request yet.\n   */\n  bucket = bucket_for_request(request + HEADER_SIZE);\n  original_bucket = bucket;\n\n  /*\n   * Search for a bucket with a non-empty free list that\'s as large or larger\n   * than what we need. If there isn\'t an exact match, we\'ll need to split a\n   * larger one to get a match.\n   */\n  while (bucket + 1 != 0) {\n    let size: usize, bytes_needed: usize, i: usize;\n    let ptr: usize;\n\n    /*\n     * We may need to grow the tree to be able to fit an allocation of this\n     * size. Try to grow the tree and stop here if we can\'t.\n     */\n    if (!lower_bucket_limit(bucket)) {\n      return 0;\n    }\n\n    /*\n     * Try to pop a block off the free list for this bucket. If the free list\n     * is empty, we\'re going to have to split a larger block instead.\n     */\n    ptr = changetype<usize>(list_pop(buckets$get(bucket)));\n    if (!ptr) {\n      /*\n       * If we\'re not at the root of the tree or it\'s impossible to grow the\n       * tree any more, continue on to the next bucket.\n       */\n      if (bucket != bucket_limit || bucket == 0) {\n        bucket--;\n        continue;\n      }\n\n      /*\n       * Otherwise, grow the tree one more level and then pop a block off the\n       * free list again. Since we know the root of the tree is used (because\n       * the free list was empty), this will add a parent above this node in\n       * the SPLIT state and then add the new right child node to the free list\n       * for this bucket. Popping the free list will give us this right child.\n       */\n      if (!lower_bucket_limit(bucket - 1)) {\n        return 0;\n      }\n      ptr = changetype<usize>(list_pop(buckets$get(bucket)));\n    }\n\n    /*\n     * Try to expand the address space first before going any further. If we\n     * have run out of space, put this block back on the free list and fail.\n     */\n    size = 1 << (MAX_ALLOC_LOG2 - bucket);\n    bytes_needed = bucket < original_bucket ? size / 2 + List.SIZE : size;\n    if (!update_max_ptr(ptr + bytes_needed)) {\n      list_push(buckets$get(bucket), changetype<List>(ptr));\n      return 0;\n    }\n\n    /*\n     * If we got a node off the free list, change the node from UNUSED to USED.\n     * This involves flipping our parent\'s "is split" bit because that bit is\n     * the exclusive-or of the UNUSED flags of both children, and our UNUSED\n     * flag (which isn\'t ever stored explicitly) has just changed.\n     *\n     * Note that we shouldn\'t ever need to flip the "is split" bit of our\n     * grandparent because we know our buddy is USED so it\'s impossible for our\n     * grandparent to be UNUSED (if our buddy chunk was UNUSED, our parent\n     * wouldn\'t ever have been split in the first place).\n     */\n    i = node_for_ptr(ptr, bucket);\n    if (i != 0) {\n      flip_parent_is_split(i);\n    }\n\n    /*\n     * If the node we got is larger than we need, split it down to the correct\n     * size and put the new unused child nodes on the free list in the\n     * corresponding bucket. This is done by repeatedly moving to the left\n     * child, splitting the parent, and then adding the right child to the free\n     * list.\n     */\n    while (bucket < original_bucket) {\n      i = i * 2 + 1;\n      bucket++;\n      flip_parent_is_split(i);\n      list_push(\n        buckets$get(bucket),\n        changetype<List>(ptr_for_node(i + 1, bucket))\n      );\n    }\n\n    /*\n     * Now that we have a memory address, write the block header (just the size\n     * of the allocation) and return the address immediately after the header.\n     */\n    store<usize>(ptr, request);\n    return ptr + HEADER_SIZE;\n  }\n\n  return 0;\n}\n\n@global export function __memory_free(ptr: usize): void {\n  var bucket: usize, i: usize;\n\n  /*\n   * Ignore any attempts to free a NULL pointer.\n   */\n  if (!ptr) {\n    return;\n  }\n\n  /*\n   * We were given the address returned by "malloc" so get back to the actual\n   * address of the node by subtracting off the size of the block header. Then\n   * look up the index of the node corresponding to this address.\n   */\n  ptr = ptr - HEADER_SIZE;\n  bucket = bucket_for_request(load<usize>(ptr) + HEADER_SIZE);\n  i = node_for_ptr(ptr, bucket);\n\n  /*\n   * Traverse up to the root node, flipping USED blocks to UNUSED and merging\n   * UNUSED buddies together into a single UNUSED parent.\n   */\n  while (i != 0) {\n    /*\n     * Change this node from UNUSED to USED. This involves flipping our\n     * parent\'s "is split" bit because that bit is the exclusive-or of the\n     * UNUSED flags of both children, and our UNUSED flag (which isn\'t ever\n     * stored explicitly) has just changed.\n     */\n    flip_parent_is_split(i);\n\n    /*\n     * If the parent is now SPLIT, that means our buddy is USED, so don\'t merge\n     * with it. Instead, stop the iteration here and add ourselves to the free\n     * list for our bucket.\n     *\n     * Also stop here if we\'re at the current root node, even if that root node\n     * is now UNUSED. Root nodes don\'t have a buddy so we can\'t merge with one.\n     */\n    if (parent_is_split(i) || bucket == bucket_limit) {\n      break;\n    }\n\n    /*\n     * If we get here, we know our buddy is UNUSED. In this case we should\n     * merge with that buddy and continue traversing up to the root node. We\n     * need to remove the buddy from its free list here but we don\'t need to\n     * add the merged parent to its free list yet. That will be done once after\n     * this loop is finished.\n     */\n    list_remove(changetype<List>(ptr_for_node(((i - 1) ^ 1) + 1, bucket)));\n    i = (i - 1) / 2;\n    bucket--;\n  }\n\n  /*\n   * Add ourselves to the free list for our bucket. We add to the back of the\n   * list because "malloc" takes from the back of the list and we want a "free"\n   * followed by a "malloc" of the same size to ideally use the same address\n   * for better memory locality.\n   */\n  list_push(buckets$get(bucket), changetype<List>(ptr_for_node(i, bucket)));\n}\n',"allocator/emscripten":"/**\n * Emscripten Memory Allocator.\n *\n * Uses Emscripten's exported _malloc and _free implementations, i.e., when linking with\n * Emscripten-compiled programs that already provide these. Differs from 'system' in that their\n * names are prefixed with an underscore.\n *\n * @module std/assembly/allocator/emscripten\n *//***/\n\ndeclare function _malloc(size: usize): usize;\ndeclare function _free(ptr: usize): void;\n\n// Memory allocator interface\n\n@global export function __memory_allocate(size: usize): usize {\n  return _malloc(size);\n}\n\n@global export function __memory_free(ptr: usize): void {\n  _free(ptr);\n}\n","allocator/system":"/**\n * System Memory Allocator.\n *\n * Uses the environment's malloc and free implementations, i.e., when linking with other C-like\n * programs that already provide these.\n *\n * @module std/assembly/allocator/system\n *//***/\n\ndeclare function malloc(size: usize): usize;\ndeclare function free(ptr: usize): void;\n\n// Memory allocator interface\n\n@global export function __memory_allocate(size: usize): usize {\n  return malloc(size);\n}\n\n@global export function __memory_free(ptr: usize): void {\n  free(ptr);\n}\n","allocator/tlsf":"/**\n * Two-Level Segregate Fit Memory Allocator.\n *\n * A general purpose dynamic memory allocator specifically designed to meet real-time requirements.\n * Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/tlsf\n *//***/\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─╫─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴─────────╨─────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\nimport {\n  AL_BITS,\n  AL_SIZE,\n  AL_MASK\n} from \"../internal/allocator\";\n\nconst SL_BITS: u32 = 5;\nconst SL_SIZE: usize = 1 << <usize>SL_BITS;\n\nconst SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\nconst SB_SIZE: usize = 1 << <usize>SB_BITS;\n\nconst FL_BITS: u32 = (sizeof<usize>() == sizeof<u32>()\n  ? 30 // ^= up to 1GB per block\n  : 32 // ^= up to 4GB per block\n) - SB_BITS;\n\n// ╒════════════════ Block structure layout (32-bit) ══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤\n// │                          size                             │L│F│ ◄─┐ info\n// ╞═══════════════════════════════════════════════════════════╧═╧═╡   │      ┐\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                ... unused free space >= 0 ...                 │   │    = 0\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤   │\n// │                        if free: jump ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ MIN SIZE ┘\n// F: FREE, L: LEFT_FREE\n\n/** Tag indicating that this block is free. */\nconst FREE: usize = 1 << 0;\n/** Tag indicating that this block's left block is free. */\nconst LEFT_FREE: usize = 1 << 1;\n/** Mask to obtain all tags. */\nconst TAGS: usize = FREE | LEFT_FREE;\n\n/** Block structure. */\n@unmanaged\nclass Block {\n\n  /** Info field holding this block's size and tags. */\n  info: usize;\n\n  /** End offset of the {@link Block#info} field. User data starts here. */\n  static readonly INFO: usize = (sizeof<usize>() + AL_MASK) & ~AL_MASK;\n\n  /** Previous free block, if any. Only valid if free. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free. */\n  next: Block | null;\n\n  /** Minimum size of a block, excluding {@link Block#info}. */\n  static readonly MIN_SIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK;// prev + next + jump\n\n  /** Maximum size of a used block, excluding {@link Block#info}. */\n  static readonly MAX_SIZE: usize = 1 << (FL_BITS + SB_BITS);\n\n  /** Gets this block's left (free) block in memory. */\n  get left(): Block {\n    assert(this.info & LEFT_FREE); // must be free to contain a jump\n    return assert(\n      load<Block>(changetype<usize>(this) - sizeof<usize>())\n    ); // can't be null\n  }\n\n  /** Gets this block's right block in memory. */\n  get right(): Block {\n    assert(this.info & ~TAGS); // can't skip beyond the tail block\n    return assert(\n      changetype<Block>(\n        changetype<usize>(this) + Block.INFO + (this.info & ~TAGS)\n      )\n    ); // can't be null\n  }\n}\n\n// ╒════════════════ Root structure layout (32-bit) ═══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                              ...                              │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[22] P                         │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[736]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                            tailRef                            │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map, P: Possibly padded if 64-bit\n\nassert((1 << SL_BITS) <= 32); // second level must fit into 32 bits\n\n/** Root structure. */\n@unmanaged\nclass Root {\n\n  /** First level bitmap. */\n  flMap: usize = 0;\n\n  /** Start offset of second level maps. */\n  private static readonly SL_START: usize = sizeof<usize>();\n\n  // Using *one* SL map per *FL bit*\n\n  /** Gets the second level map for the specified first level. */\n  getSLMap(fl: usize): u32 {\n    assert(fl < FL_BITS); // fl out of range\n    return load<u32>(changetype<usize>(this) + fl * 4, Root.SL_START);\n  }\n\n  /** Sets the second level map for the specified first level. */\n  setSLMap(fl: usize, value: u32): void {\n    assert(fl < FL_BITS); // fl out of range\n    store<u32>(changetype<usize>(this) + fl * 4, value, Root.SL_START);\n  }\n\n  /** End offset of second level maps. */\n  private static readonly SL_END: usize = Root.SL_START + FL_BITS * 4;\n\n  // Using *number bits per SL* heads per *FL bit*\n\n  /** Start offset of FL/SL heads. */\n  private static readonly HL_START: usize = (Root.SL_END + AL_MASK) & ~AL_MASK;\n\n  /** Gets the head of the specified first and second level index. */\n  getHead(fl: usize, sl: u32): Block | null {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    return changetype<Block>(load<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , Root.HL_START));\n  }\n\n  /** Sets the head of the specified first and second level index. */\n  setHead(fl: usize, sl: u32, value: Block | null): void {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    store<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , changetype<usize>(value)\n    , Root.HL_START);\n  }\n\n  /** End offset of FL/SL heads. */\n  private static readonly HL_END: usize = (\n    Root.HL_START + FL_BITS * SL_SIZE * sizeof<usize>()\n  );\n\n  get tailRef(): usize { return load<usize>(0, Root.HL_END); }\n  set tailRef(value: usize) { store<usize>(0, value, Root.HL_END); }\n\n  /** Total size of the {@link Root} structure. */\n  static readonly SIZE: usize = Root.HL_END + sizeof<usize>();\n\n  /** Inserts a previously used block back into the free list. */\n  insert(block: Block): void {\n    // check as much as possible here to prevent invalid free blocks\n    assert(block); // cannot be null\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size: usize;\n    assert(\n      (size = block.info & ~TAGS) >= Block.MIN_SIZE && size < Block.MAX_SIZE\n    ); // must be valid, not necessary to compute yet if noAssert=true\n\n    var right: Block = assert(block.right); // can't be null\n    var rightInfo = right.info;\n\n    // merge with right block if also free\n    if (rightInfo & FREE) {\n      this.remove(right);\n      block.info = (blockInfo += Block.INFO + (rightInfo & ~TAGS));\n      right = block.right;\n      rightInfo = right.info;\n      // jump is set below\n    }\n\n    // merge with left block if also free\n    if (blockInfo & LEFT_FREE) {\n      let left: Block = assert(block.left); // can't be null\n      let leftInfo = left.info;\n      assert(leftInfo & FREE); // must be free according to tags\n      this.remove(left);\n      left.info = (leftInfo += Block.INFO + (blockInfo & ~TAGS));\n      block = left;\n      blockInfo = leftInfo;\n      // jump is set below\n    }\n\n    right.info = rightInfo | LEFT_FREE;\n    this.setJump(block, right);\n    // right is no longer used now, hence rightInfo is not synced\n\n    size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // perform insertion\n    var head = this.getHead(fl, sl);\n    block.prev = null;\n    block.next = head;\n    if (head) head.prev = block;\n    this.setHead(fl, sl, block);\n\n    // update first and second level maps\n    this.flMap |= (1 << fl);\n    this.setSLMap(fl, this.getSLMap(fl) | (1 << sl));\n  }\n\n  /**\n   * Removes a free block from FL/SL maps. Does not alter left/jump because it\n   * is likely that splitting is performed afterwards, invalidating any changes\n   * again.\n   */\n  private remove(block: Block): void {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // link previous and next free block\n    var prev = block.prev;\n    var next = block.next;\n    if (prev) prev.next = next;\n    if (next) next.prev = prev;\n\n    // update head if we are removing it\n    if (block == this.getHead(fl, sl)) {\n      this.setHead(fl, sl, next);\n\n      // clear second level map if head is empty now\n      if (!next) {\n        let slMap = this.getSLMap(fl);\n        this.setSLMap(fl, slMap &= ~(1 << sl));\n\n        // clear first level map if second level is empty now\n        if (!slMap) this.flMap &= ~(1 << fl);\n      }\n    }\n  }\n\n  /** Searches for a free block of at least the specified size. */\n  search(size: usize): Block | null {\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE);\n\n    // mapping_search\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      // (*) size += (1 << (fls<usize>(size) - SL_BITS)) - 1;\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n      // (*) instead of rounding up, use next second level list for better fit\n      if (sl < SL_SIZE - 1) ++sl;\n      else ++fl, sl = 0;\n    }\n\n    // search second level\n    var slMap = this.getSLMap(fl) & (~0 << sl);\n    var head: Block | null;\n    if (!slMap) {\n      // search next larger first level\n      let flMap = this.flMap & (~0 << (fl + 1));\n      if (!flMap) {\n        head = null;\n      } else {\n        fl = ffs<usize>(flMap);\n        slMap = assert(this.getSLMap(fl)); // can't be zero if fl points here\n        head = this.getHead(fl, ffs<u32>(slMap));\n      }\n    } else {\n      head = this.getHead(fl, ffs<u32>(slMap));\n    }\n    return head;\n  }\n\n  /** Links a free left with its right block in memory. */\n  private setJump(left: Block, right: Block): void {\n    assert(left.info & FREE);       // must be free\n    assert(left.right == right);    // right block must match\n    assert(right.info & LEFT_FREE); // right block must be tagged as LEFT_FREE\n    store<Block>(\n      changetype<usize>(right) - sizeof<usize>()\n    , left); // last word in left block's (free) data region\n  }\n\n  /**\n   * Uses the specified free block, removing it from internal maps and\n   * splitting it if possible, and returns its data pointer.\n   */\n  use(block: Block, size: usize): usize {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free so we can use it\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n    assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n    this.remove(block);\n\n    // split if the block can hold another MIN_SIZE block\n    var remaining = (blockInfo & ~TAGS) - size;\n    if (remaining >= Block.INFO + Block.MIN_SIZE) {\n      block.info = size | (blockInfo & LEFT_FREE); // also discards FREE\n\n      let spare = changetype<Block>(\n        changetype<usize>(block) + Block.INFO + size\n      );\n      spare.info = (remaining - Block.INFO) | FREE; // not LEFT_FREE\n      this.insert(spare); // also sets jump\n\n    // otherwise tag block as no longer FREE and right as no longer LEFT_FREE\n    } else {\n      block.info = blockInfo & ~FREE;\n      let right: Block = assert(block.right); // can't be null (tail)\n      right.info &= ~LEFT_FREE;\n    }\n\n    return changetype<usize>(block) + Block.INFO;\n  }\n\n  /** Adds more memory to the pool. */\n  addMemory(start: usize, end: usize): bool {\n    assert(start <= end);\n    assert(!(start & AL_MASK)); // must be aligned\n    assert(!(end & AL_MASK)); // must be aligned\n\n    var tailRef = this.tailRef;\n    var tailInfo: usize = 0;\n    if (tailRef) {\n      assert(start >= tailRef + sizeof<usize>()); // starts after tail\n\n      // merge with current tail if adjacent\n      if (start - Block.INFO == tailRef) {\n        start -= Block.INFO;\n        tailInfo = changetype<Block>(tailRef).info;\n      }\n\n    } else {\n      assert(start >= changetype<usize>(this) + Root.SIZE); // starts after root\n    }\n\n    // check if size is large enough for a free block and the tail block\n    var size = end - start;\n    if (size < Block.INFO + Block.MIN_SIZE + Block.INFO) {\n      return false;\n    }\n\n    // left size is total minus its own and the zero-length tail's header\n    var leftSize = size - 2 * Block.INFO;\n    var left = changetype<Block>(start);\n    left.info = leftSize | FREE | (tailInfo & LEFT_FREE);\n    left.prev = null;\n    left.next = null;\n\n    // tail is a zero-length used block\n    var tail = changetype<Block>(start + size - Block.INFO);\n    tail.info = 0 | LEFT_FREE;\n    this.tailRef = changetype<usize>(tail);\n\n    this.insert(left); // also merges with free left before tail / sets jump\n\n    return true;\n  }\n}\n\n/** Determines the first (LSB to MSB) set bit's index of a word. */\nfunction ffs<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  return ctz<T>(word);  // differs from ffs only for 0\n}\n\n/** Determines the last (LSB to MSB) set bit's index of a word. */\nfunction fls<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  const inv: T = (sizeof<T>() << 3) - 1;\n  return inv - clz<T>(word);\n}\n\n/** Reference to the initialized {@link Root} structure, once initialized. */\nvar ROOT: Root = changetype<Root>(0);\n\n// Memory allocator interface\n\n/** Allocates a chunk of memory. */\n@global export function __memory_allocate(size: usize): usize {\n\n  // initialize if necessary\n  var root = ROOT;\n  if (!root) {\n    let rootOffset = (HEAP_BASE + AL_MASK) & ~AL_MASK;\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>((((rootOffset + Root.SIZE) + 0xffff) & ~0xffff) >>> 16);\n    if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n    ROOT = root = changetype<Root>(rootOffset);\n    root.tailRef = 0;\n    root.flMap = 0;\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n      root.setSLMap(fl, 0);\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n        root.setHead(fl, sl, null);\n      }\n    }\n    root.addMemory((rootOffset + Root.SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\n  }\n\n  // search for a suitable block\n  var data: usize = 0;\n  if (size) {\n    if (size > Block.MAX_SIZE) unreachable();\n    // 32-bit MAX_SIZE is 1 << 30 and itself aligned, hence the following can't overflow MAX_SIZE\n    size = max<usize>((size + AL_MASK) & ~AL_MASK, Block.MIN_SIZE);\n\n    let block = root.search(size);\n    if (!block) {\n\n      // request more memory\n      let pagesBefore = memory.size();\n      let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n      let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n      if (memory.grow(pagesWanted) < 0) {\n        if (memory.grow(pagesNeeded) < 0) {\n          unreachable(); // out of memory\n        }\n      }\n      let pagesAfter = memory.size();\n      root.addMemory(<usize>pagesBefore << 16, <usize>pagesAfter << 16);\n      block = assert(root.search(size)); // must be found now\n    }\n\n    assert((block.info & ~TAGS) >= size);\n    data = root.use(<Block>block, size);\n  }\n\n  return data;\n}\n\n/** Frees the chunk of memory at the specified address. */\n@global export function __memory_free(data: usize): void {\n  if (data) {\n    let root = ROOT;\n    if (root) {\n      let block = changetype<Block>(data - Block.INFO);\n      let blockInfo = block.info;\n      assert(!(blockInfo & FREE)); // must be used\n      block.info = blockInfo | FREE;\n      root.insert(changetype<Block>(data - Block.INFO));\n    }\n  }\n}\n\n@global export function __memory_reset(): void {\n  unreachable();\n}\n",array:'import {\n  MAX_BLENGTH,\n  HEADER_SIZE as HEADER_SIZE_AB,\n  allocUnsafe,\n  reallocUnsafe,\n  loadUnsafe,\n  storeUnsafe\n} from "./internal/arraybuffer";\n\nimport {\n  defaultComparator,\n  insertionSort,\n  weakHeapSort\n} from "./internal/array";\n\nexport class Array<T> {\n\n  /* @internal */ buffer_: ArrayBuffer;\n  /* @internal */ length_: i32;\n\n  constructor(length: i32 = 0) {\n    const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n    if (<u32>length > <u32>MAX_LENGTH) throw new RangeError("Invalid array length");\n    var byteLength = length << alignof<T>();\n    var buffer = allocUnsafe(byteLength);\n    this.buffer_ = buffer;\n    this.length_ = length;\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE_AB,\n      0,\n      <usize>byteLength\n    );\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(length: i32) {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>length > <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length > <u32>MAX_LENGTH) throw new RangeError("Invalid array length");\n      buffer = reallocUnsafe(buffer, length << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = length;\n  }\n\n  every(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      if (!callbackfn(loadUnsafe<T,T>(buffer, index), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (element: T, index: i32, array: Array<T>) => bool): i32 {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      if (predicate(loadUnsafe<T,T>(buffer, index), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator("[]")\n  private __get(index: i32): T {\n    var buffer = this.buffer_;\n    return <u32>index < <u32>(buffer.byteLength >>> alignof<T>())\n      ? loadUnsafe<T,T>(buffer, index)\n      : <T>unreachable();\n  }\n\n  @operator("{}")\n  private __unchecked_get(index: i32): T {\n    return loadUnsafe<T,T>(this.buffer_, index);\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: T): void {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>index >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>index >= <u32>MAX_LENGTH) throw new Error("Invalid array length");\n      buffer = reallocUnsafe(buffer, (index + 1) << alignof<T>());\n      this.buffer_ = buffer;\n      this.length_ = index + 1;\n    }\n    storeUnsafe<T,T>(buffer, index, value);\n  }\n\n  @operator("{}=")\n  private __unchecked_set(index: i32, value: T): void {\n    storeUnsafe<T,T>(this.buffer_, index, value);\n  }\n\n  includes(searchElement: T, fromIndex: i32 = 0): bool {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return false;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var buffer = this.buffer_;\n    while (fromIndex < length) {\n      if (loadUnsafe<T,T>(buffer, fromIndex) == searchElement) return true;\n      ++fromIndex;\n    }\n    return false;\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var buffer = this.buffer_;\n    while (fromIndex < length) {\n      if (loadUnsafe<T,T>(buffer, fromIndex) == searchElement) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex; // no need to clamp\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var buffer = this.buffer_;\n    while (fromIndex >= 0) {                           // ^\n      if (loadUnsafe<T,T>(buffer, fromIndex) == searchElement) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(element: T): i32 {\n    var length = this.length_;\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error("Invalid array length");\n      buffer = reallocUnsafe(buffer, newLength << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = newLength;\n    storeUnsafe<T,T>(buffer, length, element);\n    return newLength;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError("Array is empty");\n    var element = loadUnsafe<T,T>(this.buffer_, --length);\n    this.length_ = length;\n    return element;\n  }\n\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      callbackfn(loadUnsafe<T,T>(buffer, index), index, this);\n    }\n  }\n\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var buffer = this.buffer_;\n    var length = this.length_;\n    var result = new Array<U>(length);\n    var resultBuffer = result.buffer_;\n    for (let index = 0; index < length && index < this.length_; ++index) {\n      storeUnsafe<U,U>(resultBuffer, index, callbackfn(loadUnsafe<T,T>(buffer, index), index, this));\n    }\n    return result;\n  }\n\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var buffer = this.buffer_;\n    var length = this.length_;\n    var result = new Array<T>();\n    for (let index = 0; index < length && index < this.length_; ++index) {\n      let value = loadUnsafe<T,T>(buffer, index);\n      if (callbackfn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      accum = callbackfn(accum, loadUnsafe<T,T>(buffer, index), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    var buffer = this.buffer_;\n    for (let index: i32 = this.length_ - 1; index >= 0; --index) {\n      accum = callbackfn(accum, loadUnsafe<T,T>(buffer, index), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError("Array is empty");\n    var buffer = this.buffer_;\n    var element = loadUnsafe<T,T>(buffer, 0);\n    var lastIndex = length - 1;\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE_AB,\n      changetype<usize>(buffer) + HEADER_SIZE_AB + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    storeUnsafe<T,T>(buffer, lastIndex, <T>null);\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      if (callbackfn(loadUnsafe<T,T>(buffer, index), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(element: T): i32 {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var length = this.length_;\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error("Invalid array length");\n      buffer = reallocUnsafe(buffer, newLength << alignof<T>());\n      capacity = buffer.byteLength >>> alignof<T>();\n      this.buffer_ = buffer;\n    }\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE_AB + sizeof<T>(),\n      changetype<usize>(buffer) + HEADER_SIZE_AB,\n      <usize>(capacity - 1) << alignof<T>()\n    );\n    storeUnsafe<T,T>(buffer, 0, element);\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length_;\n    if (begin < 0) begin = max(length + begin, 0);\n    else if (begin > length) begin = length;\n    if (end < 0) end = length + end; // no need to clamp\n    else if (end > length) end = length;\n    if (end < begin) end = begin;    // ^\n    var newLength = end - begin;\n    assert(newLength >= 0);\n    var sliced = new Array<T>(newLength);\n    if (newLength) {\n      memory.copy(\n        changetype<usize>(sliced.buffer_) + HEADER_SIZE_AB,\n        changetype<usize>(this.buffer_) + HEADER_SIZE_AB + (<usize>begin << alignof<T>()),\n        <usize>newLength << alignof<T>()\n      );\n    }\n    return sliced;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): void {\n    if (deleteCount < 1) return;\n    var length = this.length_;\n    if (start < 0) start = max(length + start, 0);\n    if (start >= length) return;\n    deleteCount = min(deleteCount, length - start);\n    var buffer = this.buffer_;\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE_AB + (<usize>start << alignof<T>()),\n      changetype<usize>(buffer) + HEADER_SIZE_AB + (<usize>(start + deleteCount) << alignof<T>()),\n      <usize>deleteCount << alignof<T>()\n    );\n    this.length_ = length - deleteCount;\n  }\n\n  reverse(): Array<T> {\n    var buffer = this.buffer_;\n    for (let front = 0, back = this.length_ - 1; front < back; ++front, --back) {\n      let temp = loadUnsafe<T,T>(buffer, front);\n      storeUnsafe<T,T>(buffer, front, loadUnsafe<T,T>(buffer, back));\n      storeUnsafe<T,T>(buffer, back, temp);\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = defaultComparator<T>()): this {\n    // TODO remove this when flow will allow trackcing null\n    assert(comparator); // The comparison function must be a function\n\n    var length = this.length_;\n    if (length <= 1) return this;\n    var buffer = this.buffer_;\n    if (length == 2) {\n      let a = loadUnsafe<T,T>(buffer, 1); // a = arr[1]\n      let b = loadUnsafe<T,T>(buffer, 0); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        storeUnsafe<T,T>(buffer, 1, b);   // arr[1] = b;\n        storeUnsafe<T,T>(buffer, 0, a);   // arr[0] = a;\n      }\n      return this;\n    }\n\n    if (isReference<T>()) {\n      // TODO replace this to faster stable sort (TimSort) when it implemented\n      return changetype<this>(insertionSort<T>(this, comparator));\n    } else {\n      return changetype<this>(length < 256\n        ? insertionSort<T>(this, comparator)\n        : weakHeapSort<T>(this, comparator)\n      );\n    }\n  }\n}\n',arraybuffer:'import {\n  HEADER_SIZE,\n  MAX_BLENGTH,\n  allocUnsafe\n} from "./internal/arraybuffer";\n\n@sealed\nexport class ArrayBuffer {\n\n  readonly byteLength: i32; // capped to [0, MAX_LENGTH]\n\n  constructor(length: i32, unsafe: bool = false) {\n    if (<u32>length > <u32>MAX_BLENGTH) throw new RangeError("Invalid array buffer length");\n    var buffer = allocUnsafe(length);\n    if (!unsafe) memory.fill(changetype<usize>(buffer) + HEADER_SIZE, 0, <usize>length);\n    return buffer;\n  }\n\n  slice(begin: i32 = 0, end: i32 = MAX_BLENGTH): ArrayBuffer {\n    var len = this.byteLength;\n    if (begin < 0) begin = max(len + begin, 0);\n    else begin = min(begin, len);\n    if (end < 0) end = max(len + end, 0);\n    else end = min(end, len);\n    var newLen = max(end - begin, 0);\n    var buffer = allocUnsafe(newLen);\n    memory.copy(changetype<usize>(buffer) + HEADER_SIZE, changetype<usize>(this) + HEADER_SIZE + begin, newLen);\n    return buffer;\n  }\n}\n',builtins:"/* tslint:disable */\n\n@builtin @inline export const NaN: f64 = 0 / 0;\n@builtin @inline export const Infinity: f64 = 1 / 0;\n@builtin export declare const HEAP_BASE: usize;\n\n@builtin export declare function isInteger<T>(value?: T): bool;\n@builtin export declare function isFloat<T>(value?: T): bool;\n@builtin export declare function isSigned<T>(value?: T): bool;\n@builtin export declare function isReference<T>(value?: T): bool;\n@builtin export declare function isString<T>(value?: T): bool;\n@builtin export declare function isArray<T>(value?: T): bool;\n@builtin export declare function isDefined(expression: void): bool;\n@builtin export declare function isConstant(expression: void): bool;\n@inline export function isNaN<T>(value: T): bool { return value != value; }\n@inline export function isFinite<T>(value: T): bool { return value - value == 0; }\n\n@builtin export declare function clz<T>(value: T): T;\n@builtin export declare function ctz<T>(value: T): T;\n@builtin export declare function popcnt<T>(value: T): T;\n@builtin export declare function rotl<T>(value: T, shift: T): T;\n@builtin export declare function rotr<T>(value: T, shift: T): T;\n@builtin export declare function abs<T>(value: T): T;\n@builtin export declare function max<T>(left: T, right: T): T;\n@builtin export declare function min<T>(left: T, right: T): T;\n@builtin export declare function ceil<T>(value: T): T;\n@builtin export declare function floor<T>(value: T): T;\n@builtin export declare function copysign<T>(left: T, right: T): T;\n@builtin export declare function nearest<T>(value: T): T;\n@builtin export declare function reinterpret<T>(value: void): T;\n@builtin export declare function sqrt<T>(value: T): T;\n@builtin export declare function trunc<T>(value: T): T;\n@builtin export declare function load<T>(offset: usize, constantOffset?: usize): T;\n@builtin export declare function store<T>(offset: usize, value: void, constantOffset?: usize): void;\n@builtin export declare function sizeof<T>(): usize; // | u32 / u64\n@builtin export declare function alignof<T>(): usize; // | u32 / u64\n@builtin export declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n@builtin export declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n@builtin export declare function unreachable(): void;\n@builtin export declare function changetype<T>(value: void): T;\n@builtin export declare function assert<T>(isTrueish: T, message?: string): T;\n@builtin export declare function unchecked<T>(expr: T): T;\n@builtin export declare function call_indirect<T>(target: void, ...args: void[]): T;\n\n@builtin export declare function i8(value: void): i8;\nexport namespace i8 {\n  export const MIN_VALUE: i8 = -128;\n  export const MAX_VALUE: i8 =  127;\n}\n\n@builtin export declare function i16(value: void): i16;\nexport namespace i16 {\n  export const MIN_VALUE: i16 = -32768;\n  export const MAX_VALUE: i16 =  32767;\n}\n\n@builtin export declare function i32(value: void): i32;\nexport namespace i32 {\n  export const MIN_VALUE: i32 = -2147483648;\n  export const MAX_VALUE: i32 =  2147483647;\n  @builtin export declare function clz(value: i32): i32;\n  @builtin export declare function ctz(value: i32): i32;\n  @builtin export declare function popcnt(value: i32): i32;\n  @builtin export declare function rotl(value: i32, shift: i32): i32;\n  @builtin export declare function rotr(value: i32, shift: i32): i32;\n  @builtin export declare function reinterpret_f32(value: f32): i32;\n  @builtin export declare function load8_s(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function load8_u(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function load16_s(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function load16_u(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function load(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function store8(offset: usize, value: i32, constantOffset?: usize): void;\n  @builtin export declare function store16(offset: usize, value: i32, constantOffset?: usize): void;\n  @builtin export declare function store(offset: usize, value: i32, constantOffset?: usize): void;\n}\n\n@builtin export declare function i64(value: void): i64;\nexport namespace i64 {\n  export const MIN_VALUE: i64 = -9223372036854775808;\n  export const MAX_VALUE: i64 =  9223372036854775807;\n  @builtin export declare function clz(value: i64): i64;\n  @builtin export declare function ctz(value: i64): i64;\n  @builtin export declare function load8_s(offset: usize, constantOffset?: usize): i64;\n  @builtin export declare function load8_u(offset: usize, constantOffset?: usize): u64;\n  @builtin export declare function load16_s(offset: usize, constantOffset?: usize): i64;\n  @builtin export declare function load16_u(offset: usize, constantOffset?: usize): u64;\n  @builtin export declare function load32_s(offset: usize, constantOffset?: usize): i64;\n  @builtin export declare function load32_u(offset: usize, constantOffset?: usize): u64;\n  @builtin export declare function load(offset: usize, constantOffset?: usize): i64;\n  @builtin export declare function popcnt(value: i64): i64;\n  @builtin export declare function rotl(value: i64, shift: i64): i64;\n  @builtin export declare function rotr(value: i64, shift: i64): i64;\n  @builtin export declare function reinterpret_f64(value: f64): i64;\n  @builtin export declare function store8(offset: usize, value: i64, constantOffset?: usize): void;\n  @builtin export declare function store16(offset: usize, value: i64, constantOffset?: usize): void;\n  @builtin export declare function store32(offset: usize, value: i64, constantOffset?: usize): void;\n  @builtin export declare function store(offset: usize, value: i64, constantOffset?: usize): void;\n}\n\n@builtin export declare function isize(value: void): isize;\nexport namespace isize {\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n@builtin export declare function u8(value: void): u8;\nexport namespace u8 {\n  export const MIN_VALUE: u8 = 0;\n  export const MAX_VALUE: u8 = 255;\n}\n\n@builtin export declare function u16(value: void): u16;\nexport namespace u16 {\n  export const MIN_VALUE: u16 = 0;\n  export const MAX_VALUE: u16 = 65535;\n}\n\n@builtin export declare function u32(value: void): u32;\nexport namespace u32 {\n  export const MIN_VALUE: u32 = 0;\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\n@builtin export declare function u64(value: void): u64;\nexport namespace u64 {\n  export const MIN_VALUE: u64 = 0;\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n@builtin export declare function usize(value: void): usize;\nexport namespace usize {\n  export const MIN_VALUE: usize = 0;\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n@builtin export declare function bool(value: void): bool;\nexport namespace bool {\n  export const MIN_VALUE: bool = false;\n  export const MAX_VALUE: bool = true;\n}\n\n@builtin export declare function f32(value: void): f32;\nexport namespace f32 {\n  export const MIN_VALUE = reinterpret<f32>(0xFF7FFFFF); // -0x1.fffffep+127f\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); //  0x1.fffffep+127f\n  export const MIN_POSITIVE_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n  @builtin export declare function abs(value: f32): f32;\n  @builtin export declare function ceil(value: f32): f32;\n  @builtin export declare function copysign(x: f32, y: f32): f32;\n  @builtin export declare function floor(value: f32): f32;\n  @builtin export declare function load(offset: usize, constantOffset?: usize): f32;\n  @builtin export declare function max(left: f32, right: f32): f32;\n  @builtin export declare function min(left: f32, right: f32): f32;\n  @builtin export declare function nearest(value: f32): f32;\n  @builtin export declare function reinterpret_i32(value: i32): f32;\n  @builtin export declare function sqrt(value: f32): f32;\n  @builtin export declare function store(offset: usize, value: f32, constantOffset?: usize): void;\n  @builtin export declare function trunc(value: f32): f32;\n}\n\n@builtin export declare function f64(value: void): f64;\nexport namespace f64 {\n  export const MIN_VALUE = reinterpret<f64>(0xFFEFFFFFFFFFFFFF); // -0x1.fffffffffffffp+1023\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); //  0x1.fffffffffffffp+1023\n  export const MIN_POSITIVE_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n  @builtin export declare function abs(value: f64): f64;\n  @builtin export declare function ceil(value: f64): f64;\n  @builtin export declare function copysign(x: f64, y: f64): f64;\n  @builtin export declare function floor(value: f64): f64;\n  @builtin export declare function load(offset: usize, constantOffset?: usize): f64;\n  @builtin export declare function max(left: f64, right: f64): f64;\n  @builtin export declare function min(left: f64, right: f64): f64;\n  @builtin export declare function nearest(value: f64): f64;\n  @builtin export declare function reinterpret_i64(value: i64): f64;\n  @builtin export declare function sqrt(value: f64): f64;\n  @builtin export declare function store(offset: usize, value: f64, constantOffset?: usize): void;\n  @builtin export declare function trunc(value: f64): f64;\n}\n\n@builtin export declare function start(): void;\n\n@builtin export declare function ERROR(message?: void): void;\n@builtin export declare function WARNING(message?: void): void;\n@builtin export declare function INFO(message?: void): void;\n\n@builtin export declare function __gc_iterate_roots(fn: (ref: usize) => void): void;\n","collector/itcm":'/**\n * Incremental Tri-Color-Marking Garbage Collector.\n *\n * @module std/assembly/collector/itcm\n *//***/\n\n// Largely based on the Bach Le\'s μgc, see: https://github.com/bullno1/ugc\n\nconst TRACE = false;\n\nimport {\n  AL_MASK,\n  MAX_SIZE_32\n} from "../internal/allocator";\n\nimport {\n  iterateRoots\n} from "../gc";\n\n/** Collector states. */\nconst enum State {\n  /** Not yet initialized. */\n  INIT = 0,\n  /** Currently transitioning from SWEEP to MARK state. */\n  IDLE = 1,\n  /** Currently marking reachable objects. */\n  MARK = 2,\n  /** Currently sweeping unreachable objects. */\n  SWEEP = 3\n}\n\n/** Current collector state. */\nvar state = State.INIT;\n/** Current white color value. */\nvar white = 0;\n\n// From and to spaces\nvar from: ManagedObjectSet;\nvar to: ManagedObjectSet;\nvar iter: ManagedObject;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┤      ┐\n// │                              next                       │  F  │ ◄─┐ = nextWithFlags\n// ├─────────────────────────────────────────────────────────┴─────┤   │ usize\n// │                              prev                             │ ◄─┘\n// ╞═══════════════════════════════════════════════════════════════╡ SIZE ┘\n// │                          ... data ...                         │\n// └───────────────────────────────────────────────────────────────┘\n// F: flags\n\n/** Represents a managed object in memory, consisting of a header followed by the object\'s data. */\n@unmanaged\nclass ManagedObject {\n\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize;\n\n  /** Pointer to the previous object. */\n  prev: ManagedObject;\n\n  /** Visitor function called with the payload reference. */\n  visitFn: (ref: usize) => void;\n\n  /** Size of a managed object after alignment. */\n  static readonly SIZE: usize = (offsetof<ManagedObject>() + AL_MASK) & ~AL_MASK;\n\n  /** Gets the pointer to the next object in the list. */\n  get next(): ManagedObject {\n    return changetype<ManagedObject>(this.nextWithColor & ~3);\n  }\n\n  /** Sets the pointer to the next object in the list. */\n  set next(obj: ManagedObject) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & 3);\n  }\n\n  /** Gets this object\'s color. */\n  get color(): i32 {\n    return this.nextWithColor & 3;\n  }\n\n  /** Sets this object\'s color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~3) | color;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    var next = this.next;\n    var prev = this.prev;\n    if (TRACE) trace("   unlink", 3, objToRef(prev), objToRef(this), objToRef(next));\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (TRACE) trace("   makeGray", 1, objToRef(this));\n    const gray = 2;\n    if (this == iter) iter = this.prev;\n    this.unlink();\n    to.push(this);\n    this.nextWithColor = (this.nextWithColor & ~3) | gray;\n  }\n}\n\n/** A set of managed objects. Used for the from and to spaces. */\n@unmanaged\nclass ManagedObjectSet extends ManagedObject {\n\n  /** Inserts an object. */\n  push(obj: ManagedObject): void {\n    var prev = this.prev;\n    if (TRACE) trace("   push", 3, objToRef(prev), objToRef(obj), objToRef(this));\n    obj.next = this;\n    obj.prev = prev;\n    prev.next = obj;\n    this.prev = obj;\n  }\n\n  /** Clears this list. */\n  clear(): void {\n    if (TRACE) trace("   clear", 1, objToRef(this));\n    this.nextWithColor = changetype<usize>(this);\n    this.prev = this;\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): void {\n  var obj: ManagedObject;\n  switch (state) {\n    case State.INIT: {\n      if (TRACE) trace("gc~step/INIT");\n      from = changetype<ManagedObjectSet>(memory.allocate(ManagedObject.SIZE));\n      from.visitFn = changetype<(ref: usize) => void>(<u32>-1); // would error\n      from.clear();\n      to = changetype<ManagedObjectSet>(memory.allocate(ManagedObject.SIZE));\n      to.visitFn = changetype<(ref: usize) => void>(<u32>-1); // would error\n      to.clear();\n      iter = to;\n      state = State.IDLE;\n      if (TRACE) trace("gc~state = IDLE");\n      // fall-through\n    }\n    case State.IDLE: {\n      if (TRACE) trace("gc~step/IDLE");\n      iterateRoots(__gc_mark);\n      state = State.MARK;\n      if (TRACE) trace("gc~state = MARK");\n      break;\n    }\n    case State.MARK: {\n      obj = iter.next;\n      if (obj !== to) {\n        if (TRACE) trace("gc~step/MARK iterate", 1, objToRef(obj));\n        iter = obj;\n        obj.color = <i32>!white;\n        obj.visitFn(objToRef(obj));\n      } else {\n        if (TRACE) trace("gc~step/MARK finish");\n        iterateRoots(__gc_mark);\n        obj = iter.next;\n        if (obj === to) {\n          let prevFrom = from;\n          from = to;\n          to = prevFrom;\n          white = <i32>!white;\n          iter = prevFrom.next;\n          state = State.SWEEP;\n          if (TRACE) trace("gc~state = SWEEP");\n        }\n      }\n      break;\n    }\n    case State.SWEEP: {\n      obj = iter;\n      if (obj !== to) {\n        if (TRACE) trace("gc~step/SWEEP free", 1, objToRef(obj));\n        iter = obj.next;\n        memory.free(changetype<usize>(obj));\n      } else {\n        if (TRACE) trace("gc~step/SWEEP finish");\n        to.clear();\n        state = State.IDLE;\n        if (TRACE) trace("gc~state = IDLE");\n      }\n      break;\n    }\n  }\n}\n\n@inline function refToObj(ref: usize): ManagedObject {\n  return changetype<ManagedObject>(ref - ManagedObject.SIZE);\n}\n\n@inline function objToRef(obj: ManagedObject): usize {\n  return changetype<usize>(obj) + ManagedObject.SIZE;\n}\n\n// Garbage collector interface\n\n@global export function __gc_allocate(\n  size: usize,\n  visitFn: (ref: usize) => void\n): usize {\n  if (TRACE) trace("gc.allocate", 1, size);\n  if (size > MAX_SIZE_32 - ManagedObject.SIZE) unreachable();\n  step(); // also makes sure it\'s initialized\n  var obj = changetype<ManagedObject>(memory.allocate(ManagedObject.SIZE + size));\n  obj.visitFn = visitFn;\n  obj.color = white;\n  from.push(obj);\n  return objToRef(obj);\n}\n\n@global export function __gc_link(parentRef: usize, childRef: usize): void {\n  if (TRACE) trace("gc.link", 2, parentRef, childRef);\n  var parent = refToObj(parentRef);\n  if (parent.color == <i32>!white && refToObj(childRef).color == white) parent.makeGray();\n}\n\n@global export function __gc_mark(ref: usize): void {\n  if (TRACE) trace("gc.mark", 1, ref);\n  if (ref) {\n    let obj = refToObj(ref);\n    if (obj.color == white) obj.makeGray();\n  }\n}\n\n@global export function __gc_collect(): void {\n  if (TRACE) trace("gc.collect");\n  // begin collecting if not yet collecting\n  switch (state) {\n    case State.INIT:\n    case State.IDLE: step();\n  }\n  // finish the cycle\n  while (state != State.IDLE) step();\n}\n',env:"declare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n",error:'export class Error {\n\n  message: string;\n  stack: string = ""; // TODO\n\n  constructor(message: string = "") {\n    this.message = message;\n  }\n}\n\nexport class RangeError extends Error {}\nexport class TypeError extends Error {}\n',gc:"@builtin export declare function iterateRoots(fn: (ref: usize) => void): void; // tslint:disable-line\n\nexport namespace gc {\n\n  export function allocate(size: usize, visitFn: (ref: usize) => void): usize {\n    if (isDefined(__gc_allocate)) return __gc_allocate(size, visitFn); // tslint:disable-line\n    WARNING(\"Calling 'gc.allocate' requires a garbage collector to be present.\");\n    return <usize>unreachable();\n  }\n\n  export function collect(): void {\n    if (isDefined(__gc_collect)) { __gc_collect(); return; } // tslint:disable-line\n    WARNING(\"Calling 'gc.collect' requires a garbage collector to be present.\");\n    unreachable();\n  }\n\n  export function link(parentRef: usize, childRef: usize): void {\n    if (isDefined(__gc_link)) { __gc_link(parentRef, childRef); return; } // tslint:disable-line\n    WARNING(\"Calling 'gc.link' requires a garbage collector to be present.\");\n    unreachable();\n  }\n\n  export function mark(ref: usize): void {\n    if (isDefined(__gc_mark)) { __gc_mark(ref); return; } // tslint:disable-line\n    WARNING(\"Calling 'gc.mark' requires a garbage collector to be present.\");\n    unreachable();\n  }\n}\n","internal/allocator":"/** Number of alignment bits. */\nexport const AL_BITS: u32 = 3;\n\n/** Number of possible alignment values. */\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\n\n/** Mask to obtain just the alignment bits. */\nexport const AL_MASK: usize = AL_SIZE - 1;\n\n/** Maximum 32-bit allocation size. */\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","internal/array":"import {\n  loadUnsafe,\n  storeUnsafe\n} from \"./arraybuffer\";\n\nimport {\n  Array\n} from \"../array\";\n\n/** Obtains the default comparator for the specified type. */\n@inline\nexport function defaultComparator<T>(): (a: T, b: T) => i32 {\n  return (a: T, b: T): i32 => (<i32>(a > b) - <i32>(a < b)); // compiles to a constant table index\n}\n\n/** Sorts an Array with the 'Insertion Sort' algorithm. */\nexport function insertionSort<T>(arr: Array<T>, comparator: (a: T, b: T) => i32): Array<T> {\n  var buffer = arr.buffer_;\n  for (let i: i32 = 0, length: i32 = arr.length; i < length; i++) {\n    let a = loadUnsafe<T,T>(buffer, i);       // a = arr[i]\n    let j = i - 1;\n    while (j >= 0) {\n      let b = loadUnsafe<T,T>(buffer, j);     // b = arr[j]\n      if (comparator(a, b) < 0) {\n        storeUnsafe<T,T>(buffer, j-- + 1, b); // arr[j + 1] = b\n      } else break;\n    }\n    storeUnsafe<T,T>(buffer, j + 1, a);       // arr[j + 1] = a\n  }\n  return arr;\n}\n\n/** Sorts an Array with the 'Weak Heap Sort' algorithm. */\nexport function weakHeapSort<T>(arr: Array<T>, comparator: (a: T, b: T) => i32): Array<T> {\n  const shift32 = alignof<u32>();\n\n  var length = arr.length;\n  var bitsetSize = (length + 31) >> 5 << shift32;\n  var bitset = memory.allocate(bitsetSize); // indexed in 32-bit chunks below\n  memory.fill(bitset, 0, bitsetSize);\n\n  // see: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.21.1863&rep=rep1&type=pdf\n\n  var buffer = arr.buffer_;\n  for (let i = length - 1; i > 0; i--) {\n    let j = i;\n    while ((j & 1) == (load<u32>(bitset + (j >> 6 << shift32)) >> (j >> 1 & 31) & 1)) j >>= 1;\n\n    let p = j >> 1;\n    let a = loadUnsafe<T,T>(buffer, p);                       // a = arr[p]\n    let b = loadUnsafe<T,T>(buffer, i);                       // b = arr[i]\n    if (comparator(a, b) < 0) {\n      store<u32>(\n        bitset + (i >> 5 << shift32),\n        load<u32>(bitset + (i >> 5 << shift32)) ^ (1 << (i & 31))\n      );\n      storeUnsafe<T,T>(buffer, i, a);                         // arr[i] = a\n      storeUnsafe<T,T>(buffer, p, b);                         // arr[p] = b\n    }\n  }\n\n  for (let i = length - 1; i >= 2; i--) {\n    let a = loadUnsafe<T,T>(buffer, 0);                       // a = arr[0]\n    storeUnsafe<T,T>(buffer, 0, loadUnsafe<T,T>(buffer, i));  // arr[0] = arr[i]\n    storeUnsafe<T,T>(buffer, i, a);                           // arr[i] = a\n\n    let x = 1, y: i32;\n    while ((y = (x << 1) + ((load<u32>(bitset + (x >> 5 << shift32)) >> (x & 31)) & 1)) < i) x = y;\n\n    while (x > 0) {\n      a = loadUnsafe<T,T>(buffer, 0);                         // a = arr[0]\n      let b = loadUnsafe<T,T>(buffer, x);                     // b = arr[x]\n\n      if (comparator(a, b) < 0) {\n        store<u32>(\n          bitset + (x >> 5 << shift32),\n          load<u32>(bitset + (x >> 5 << shift32)) ^ (1 << (x & 31))\n        );\n        storeUnsafe<T,T>(buffer, x, a);                       // arr[x] = a\n        storeUnsafe<T,T>(buffer, 0, b);                       // arr[0] = b\n      }\n      x >>= 1;\n    }\n  }\n\n  memory.free(bitset);\n\n  var t = loadUnsafe<T,T>(buffer, 1);                         // t = arr[1]\n  storeUnsafe<T,T>(buffer, 1, loadUnsafe<T,T>(buffer, 0));    // arr[1] = arr[0]\n  storeUnsafe<T,T>(buffer, 0, t);                             // arr[0] = t\n  return arr;\n}\n","internal/arraybuffer":'import { AL_MASK, MAX_SIZE_32 } from "./allocator";\n\n/** Size of an ArrayBuffer header. */\nexport const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\n\n/** Maximum byte length of an ArrayBuffer. */\nexport const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\n\n/** Computes an ArrayBuffer\'s size in memory. */\nexport function computeSize(byteLength: i32): usize {\n  // round up to power of 2, with HEADER_SIZE=8:\n  // 0            -> 2^3  = 8\n  // 1..8         -> 2^4  = 16\n  // 9..24        -> 2^5  = 32\n  // ...\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\n}\n\n/** Allocates a raw ArrayBuffer. Contents remain uninitialized. */\nexport function allocUnsafe(byteLength: i32): ArrayBuffer {\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\n  var buffer = memory.allocate(computeSize(byteLength));\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>("byteLength"));\n  return changetype<ArrayBuffer>(buffer);\n}\n\n/** Reallocates an ArrayBuffer, resizing it as requested. Tries to modify the buffer in place. */\nexport function reallocUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\n  var oldByteLength = buffer.byteLength;\n  if (newByteLength > oldByteLength) {\n    assert(newByteLength <= MAX_BLENGTH);\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>("byteLength"));\n      memory.fill(\n        changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\n        0,\n        <usize>(newByteLength - oldByteLength)\n      );\n    } else { // slow path: copy to new buffer\n      let newBuffer = allocUnsafe(newByteLength);\n      memory.copy(\n        changetype<usize>(newBuffer) + HEADER_SIZE,\n        changetype<usize>(buffer) + HEADER_SIZE,\n        <usize>oldByteLength\n      );\n      memory.fill(\n        changetype<usize>(newBuffer) + HEADER_SIZE + <usize>oldByteLength,\n        0,\n        <usize>(newByteLength - oldByteLength)\n      );\n      return newBuffer;\n    }\n  } else if (newByteLength < oldByteLength) { // fast path: override size\n    // TBD: worth to copy and release if size is significantly less than before?\n    assert(newByteLength >= 0);\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>("byteLength"));\n  }\n  return buffer;\n}\n\n@inline\nexport function loadUnsafe<T,V>(buffer: ArrayBuffer, index: i32): V {\n  return <V>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()), HEADER_SIZE);\n}\n\n@inline\nexport function storeUnsafe<T,V>(buffer: ArrayBuffer, index: i32, value: V): void {\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()), value, HEADER_SIZE);\n}\n\n@inline\nexport function loadUnsafeWithOffset<T,V>(buffer: ArrayBuffer, index: i32, byteOffset: i32): V {\n  return <V>load<T>(changetype<usize>(buffer) + <usize>byteOffset + (<usize>index << alignof<T>()), HEADER_SIZE);\n}\n\n@inline\nexport function storeUnsafeWithOffset<T,V>(buffer: ArrayBuffer, index: i32, value: V, byteOffset: i32): void {\n  store<T>(changetype<usize>(buffer) + <usize>byteOffset + (<usize>index << alignof<T>()), value, HEADER_SIZE);\n}\n',"internal/hash":'import {\n  HEADER_SIZE as HEADER_SIZE_STR\n} from "./string";\n\n/** Computes the 32-bit hash of a value of any type. */\n@inline\nexport function hash<T>(key: T): u32 {\n  // branch-level tree-shaking makes this a `(return (call ...))`\n  if (isString(key)) {\n    return hashStr(key);\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(key));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(key));\n  } else {\n    if (sizeof<T>() == 1) return hash8 (<u32>key);\n    if (sizeof<T>() == 2) return hash16(<u32>key);\n    if (sizeof<T>() == 4) return hash32(<u32>key);\n    if (sizeof<T>() == 8) return hash64(<u64>key);\n  }\n  unreachable();\n}\n\n// FNV-1a 32-bit as a starting point, see: http://isthe.com/chongo/tech/comp/fnv/\n\nconst FNV_OFFSET: u32 = 2166136261;\nconst FNV_PRIME: u32 = 16777619;\n\nfunction hash8(key: u32): u32 {\n  return (FNV_OFFSET ^ key) * FNV_PRIME;\n}\n\nfunction hash16(key: u32): u32 {\n  var v = FNV_OFFSET;\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\n  v = (v ^ ( key >>  8        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hash32(key: u32): u32 {\n  var v = FNV_OFFSET;\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((key >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((key >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( key >> 24        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hash64(key: u64): u32 {\n  var l = <u32> key;\n  var h = <u32>(key >>> 32);\n  var v = FNV_OFFSET;\n  v = (v ^ ( l        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((l >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((l >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( l >> 24        )) * FNV_PRIME;\n  v = (v ^ ( h        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((h >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((h >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( h >> 24        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hashStr(key: string): u32 {\n  var v = FNV_OFFSET;\n  for (let i: usize = 0, k: usize = key.length << 1; i < k; ++i) {\n    v = (v ^ <u32>load<u8>(changetype<usize>(key) + i, HEADER_SIZE_STR)) * FNV_PRIME;\n  }\n  return v;\n}\n',"internal/itoa":'\nimport {\n  CharCode,\n  allocate as allocateString,\n  HEADER_SIZE as STRING_HEADER_SIZE\n} from "./string";\n\nimport {\n  loadUnsafe\n} from "./arraybuffer";\n\n@inline\nfunction POWERS10(): u32[] {\n  const table: u32[] = [\n    1,\n    10,\n    100,\n    1000,\n    10000,\n    100000,\n    1000000,\n    10000000,\n    100000000,\n    1000000000\n  ];\n  return table; // inlines to a constant memory offset\n}\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  "00", "01", "02", "03", "04", "05", "06", "07", "08", "09",\n  "10", "11", "12", "13", "14", "15", "16", "17", "18", "19",\n  "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",\n  "30", "31", "32", "33", "34", "35", "36", "37", "38", "39",\n  "40", "41", "42", "43", "44", "45", "46", "47", "48", "49",\n  "50", "51", "52", "53", "54", "55", "56", "57", "58", "59",\n  "60", "61", "62", "63", "64", "65", "66", "67", "68", "69",\n  "70", "71", "72", "73", "74", "75", "76", "77", "78", "79",\n  "80", "81", "82", "83", "84", "85", "86", "87", "88", "89",\n  "90", "91", "92", "93", "94", "95", "96", "97", "98", "99"\n*/\n@inline\nfunction DIGITS(): u32[] {\n  const table: u32[] = [\n    0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n    0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n    0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n    0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n    0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n    0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n    0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n    0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n    0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n    0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n    0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n    0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n    0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n    0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n    0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n    0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n    0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n    0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n    0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n    0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n  ];\n  return table; // inlines to a constant memory offset\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nfunction decimalCountU32(value: u32): i32 {\n  var l: usize = 32 - <usize>clz<u32>(value); // log2\n  var t = l * 1233 >>> 12; // log10\n\n  var lutbuf = <ArrayBuffer>POWERS10().buffer_;\n  var power  = loadUnsafe<u32,u32>(lutbuf, t);\n  t -= <usize>(value < power);\n  return t + 1;\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nfunction decimalCountU64(value: u64): i32 {\n  var l: usize = 64 - <usize>clz<u64>(value); // log2\n  var t = l * 1233 >>> 12; // log10\n\n  var lutbuf = <ArrayBuffer>POWERS10().buffer_;\n  var power  = loadUnsafe<u32,u64>(lutbuf, t - 10);\n  t -= <usize>(value < 10000000000 * power);\n  return t + 1;\n}\n\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\n  var lutbuf = <ArrayBuffer>DIGITS().buffer_;\n\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = loadUnsafe<u32,u64>(lutbuf, d1);\n    let digits2 = loadUnsafe<u32,u64>(lutbuf, d2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = loadUnsafe<u32,u32>(lutbuf, d1);\n    store<u32>(buffer + (offset << 1), digits, STRING_HEADER_SIZE);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = loadUnsafe<u32,u32>(lutbuf, num);\n    store<u32>(buffer + (offset << 1), digits, STRING_HEADER_SIZE);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit, STRING_HEADER_SIZE);\n  }\n}\n\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\n  var lutbuf = <ArrayBuffer>DIGITS().buffer_;\n\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = loadUnsafe<u32,u64>(lutbuf, c1);\n    let digits2 = loadUnsafe<u32,u64>(lutbuf, c2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n\n    digits1 = loadUnsafe<u32,u64>(lutbuf, b1);\n    digits2 = loadUnsafe<u32,u64>(lutbuf, b2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n  }\n\n  utoa32_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_simple<T>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = t;\n    offset -= 1;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r, STRING_HEADER_SIZE);\n  } while (num);\n}\n\n@inline\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, <usize>offset);\n  } else {\n    utoa32_lut(buffer, num, <usize>offset);\n  }\n}\n\n@inline\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, <usize>offset);\n  } else {\n    utoa64_lut(buffer, num, <usize>offset);\n  }\n}\n\nexport function utoa32(value: u32): string {\n  if (!value) return "0";\n\n  var decimals = decimalCountU32(value);\n  var buffer   = allocateString(decimals);\n\n  utoa32_core(changetype<usize>(buffer), value, decimals);\n  return changetype<string>(buffer);\n}\n\nexport function itoa32(value: i32): string {\n  if (!value) return "0";\n\n  var isneg = value < 0;\n  if (isneg) value = -value;\n\n  var decimals = decimalCountU32(value) + <i32>isneg;\n  var buffer   = allocateString(decimals);\n\n  utoa32_core(changetype<usize>(buffer), value, decimals);\n  if (isneg) store<u16>(changetype<usize>(buffer), CharCode.MINUS, STRING_HEADER_SIZE);\n\n  return changetype<string>(buffer);\n}\n\nexport function utoa64(value: u64): string {\n  if (!value) return "0";\n\n  var buffer: String;\n  if (value <= u32.MAX_VALUE) {\n    let value32  = <u32>value;\n    let decimals = decimalCountU32(value32);\n    buffer = allocateString(decimals);\n    utoa32_core(changetype<usize>(buffer), value32, decimals);\n  } else {\n    let decimals = decimalCountU64(value);\n    buffer = allocateString(decimals);\n    utoa64_core(changetype<usize>(buffer), value, decimals);\n  }\n\n  return changetype<string>(buffer);\n}\n\nexport function itoa64(value: i64): string {\n  if (!value) return "0";\n\n  var isneg = value < 0;\n  if (isneg) value = -value;\n\n  var buffer: String;\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\n    let value32  = <u32>value;\n    let decimals = decimalCountU32(value32) + <i32>isneg;\n    buffer = allocateString(decimals);\n    utoa32_core(changetype<usize>(buffer), value32, decimals);\n  } else {\n    let decimals = decimalCountU64(value) + <i32>isneg;\n    buffer = allocateString(decimals);\n    utoa64_core(changetype<usize>(buffer), value, decimals);\n  }\n  if (isneg) store<u16>(changetype<usize>(buffer), CharCode.MINUS, STRING_HEADER_SIZE);\n\n  return changetype<string>(buffer);\n}\n',"internal/string":'import {\n  MAX_SIZE_32\n} from "./allocator";\n\nimport {\n  String\n} from "../string";\n\n/** Size of a String header. */\nexport const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\n\n/** Maximum length of a String. */\nexport const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\n\n/** Singleton empty String. */\nexport const EMPTY = changetype<String>(""); // TODO: is this a bad idea with \'===\' in place?\n\n@inline\nexport function clamp<T>(val: T, lo: T, hi: T): T {\n  return max<T>(min<T>(val, hi), lo);\n}\n\n/** Allocates a raw String with uninitialized contents. */\nexport function allocate(length: i32): String {\n  assert(length > 0 && length <= MAX_LENGTH);\n  var buffer = memory.allocate(HEADER_SIZE + (<usize>length << 1));\n  store<i32>(buffer, length);\n  return changetype<String>(buffer);\n}\n\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n    case 10:      // <LF>\n    case 13:      // <CR>\n    case 8232:    // <LS>\n    case 8233:    // <PS>\n    case 9:       // <TAB>\n    case 11:      // <VT>\n    case 12:      // <FF>\n    case 32:      // <SP>\n    case 160:     // <NBSP>\n    case 65279: { // <ZWNBSP>\n      return true;\n    }\n    default: return false;\n  }\n}\n\nexport const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len) {\n    return <T>NaN;\n  }\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      return <T>NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      return <T>NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: {\n          radix = 10;\n        }\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    return <T>NaN;\n  }\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else {\n      break;\n    }\n    if (code >= radix) {\n      break;\n    }\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n',"internal/typedarray":'import {\n  HEADER_SIZE as HEADER_SIZE_AB,\n  MAX_BLENGTH,\n  allocUnsafe,\n  loadUnsafeWithOffset,\n  storeUnsafeWithOffset\n} from "./arraybuffer";\n\n/** Typed array base class. Not a global object. */\nexport abstract class TypedArray<T,V> {\n\n  readonly buffer: ArrayBuffer;\n  readonly byteOffset: i32;\n  readonly byteLength: i32;\n\n  constructor(length: i32) {\n    const MAX_LENGTH = <u32>MAX_BLENGTH / sizeof<T>();\n    if (<u32>length > MAX_LENGTH) throw new RangeError("Invalid typed array length");\n    var byteLength = length << alignof<T>();\n    var buffer = allocUnsafe(byteLength);\n    memory.fill(changetype<usize>(buffer) + HEADER_SIZE_AB, 0, <usize>byteLength);\n    this.buffer = buffer;\n    this.byteOffset = 0;\n    this.byteLength = byteLength;\n  }\n\n  @inline\n  get length(): i32 {\n    return (this.byteLength - this.byteOffset) >> alignof<T>();\n  }\n\n  @operator("[]")\n  protected __get(index: i32): T {\n    var byteOffset = this.byteOffset;\n    var elementLength = (this.byteLength - byteOffset) >>> alignof<T>();\n    if (<u32>index >= <u32>elementLength) throw new Error("Index out of bounds");\n    return loadUnsafeWithOffset<T,T>(this.buffer, index, byteOffset);\n  }\n\n  @inline @operator("{}")\n  protected __unchecked_get(index: i32): T {\n    return loadUnsafeWithOffset<T,T>(this.buffer, index, this.byteOffset);\n  }\n\n  @operator("[]=")\n  protected __set(index: i32, value: V): void {\n    var byteOffset = this.byteOffset;\n    var elementLength = (this.byteLength - byteOffset) >>> alignof<T>();\n    if (<u32>index >= <u32>elementLength) throw new Error("Index out of bounds");\n    storeUnsafeWithOffset<T,V>(this.buffer, index, value, byteOffset);\n  }\n\n  @inline @operator("{}=")\n  protected __unchecked_set(index: i32, value: V): void {\n    storeUnsafeWithOffset<T,V>(this.buffer, index, value, this.byteOffset);\n  }\n\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\n\n  @inline\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): TypedArray<T,V> {\n    var length = this.length;\n    if (begin < 0) begin = max(length + begin, 0);\n    else begin = min(begin, length);\n    if (end < 0) end = max(length + end, begin);\n    else end = max(min(end, length), begin);\n    var slice = memory.allocate(offsetof<this>());\n    store<usize>(slice, this.buffer, offsetof<this>("buffer"));\n    store<i32>(slice, begin << alignof<T>(), offsetof<this>("byteOffset"));\n    store<i32>(slice, end << alignof<T>(), offsetof<this>("byteLength"));\n    return changetype<this>(slice);\n  }\n}\n',iterator:"// export abstract class Iterator<T> {\n//   abstract get done(): bool;\n//   abstract next(): T;\n// }\n",map:'import {\n  HEADER_SIZE as HEADER_SIZE_AB\n} from "./internal/arraybuffer";\n\nimport {\n  hash\n} from "./internal/hash";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\nconst INITIAL_CAPACITY = 4;\nconst FILL_FACTOR: f64 = 8 / 3;\nconst FREE_FACTOR: f64 = 3 / 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\nconst EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\nconst BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n@inline function ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n@inline function ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets holding references to the respective first entry within\n  private buckets: ArrayBuffer; // usize[bucketsMask + 1]\n  private bucketsMask: u32;\n\n  // entries in insertion order\n  private entries: ArrayBuffer; // MapEntry<K,V>[entriesCapacity]\n  private entriesCapacity: i32;\n  private entriesOffset: i32;\n  private entriesCount: i32;\n\n  get size(): i32 { return this.entriesCount; }\n\n  constructor() { this.clear(); }\n\n  clear(): void {\n    const bucketsSize = INITIAL_CAPACITY * <i32>BUCKET_SIZE;\n    this.buckets = new ArrayBuffer(bucketsSize);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    const entriesSize = INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>();\n    this.entries = new ArrayBuffer(entriesSize, true);\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>(\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE,\n      HEADER_SIZE_AB\n    );\n    while (entry) {\n      if (!(entry.taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(entry.taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, hash<K>(key)) !== null;\n  }\n\n  get(key: K): V {\n    var entry = this.find(key, hash<K>(key));\n    return entry ? entry.value : <V>unreachable();\n  }\n\n  set(key: K, value: V): void {\n    var hashCode = hash<K>(key);\n    var entry = this.find(key, hashCode);\n    if (entry) {\n      entry.value = value;\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(\n        changetype<usize>(entries) + HEADER_SIZE_AB + this.entriesOffset++ * ENTRY_SIZE<K,V>()\n      );\n      entry.key = key;\n      entry.value = value;\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase, HEADER_SIZE_AB);\n      store<usize>(bucketPtrBase, changetype<usize>(entry), HEADER_SIZE_AB);\n    }\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, hash<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = <i32>(newBucketsCapacity * FILL_FACTOR);\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>(), true);\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries) + HEADER_SIZE_AB;\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries) + HEADER_SIZE_AB;\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        newEntry.key = oldEntry.key;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = hash<K>(oldEntry.key) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase, HEADER_SIZE_AB);\n        store<usize>(newBucketPtrBase, newPtr, HEADER_SIZE_AB);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n}\n',math:'export declare namespace JSMath {\n\n  export const E: f64;\n  export const LN2: f64;\n  export const LN10: f64;\n  export const LOG2E: f64;\n  export const LOG10E: f64;\n  export const PI: f64;\n  export const SQRT1_2: f64;\n  export const SQRT2: f64;\n\n  export function abs(x: f64): f64;\n  export function acos(x: f64): f64;\n  export function acosh(x: f64): f64;\n  export function asin(x: f64): f64;\n  export function asinh(x: f64): f64;\n  export function atan(x: f64): f64;\n  export function atan2(y: f64, x: f64): f64;\n  export function atanh(x: f64): f64;\n  export function cbrt(x: f64): f64;\n  export function ceil(x: f64): f64;\n  export function clz32(x: f64): f64;\n  export function cos(x: f64): f64;\n  export function cosh(x: f64): f64;\n  export function exp(x: f64): f64;\n  export function expm1(x: f64): f64;\n  export function floor(x: f64): f64;\n  export function fround(x: f64): f32;\n  export function hypot(value1: f64, value2: f64): f64; // TODO: rest\n  export function imul(a: f64, b: f64): f64;\n  export function log(x: f64): f64;\n  export function log10(x: f64): f64;\n  export function log1p(x: f64): f64;\n  export function log2(x: f64): f64;\n  export function max(value1: f64, value2: f64): f64; // TODO: rest\n  export function min(value1: f64, value2: f64): f64; // TODO: rest\n  export function pow(base: f64, exponent: f64): f64;\n  export function random(): f64;\n  export function round(x: f64): f64;\n  export function sign(x: f64): f64;\n  export function sin(x: f64): f64;\n  export function sinh(x: f64): f64;\n  export function sqrt(x: f64): f64;\n  export function tan(x: f64): f64;\n  export function tanh(x: f64): f64;\n  export function trunc(x: f64): f64;\n}\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from "./builtins";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n// TODO: sin, cos, tan\n\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\nfunction expo2(x: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  return NativeMath.exp(x - kln2) * scale * scale;\n}\n\nvar random_seeded = false;\nvar random_state0: u64;\nvar random_state1: u64;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nexport namespace NativeMath {\n\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  @inline\n  export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    var s: f64, w: f64, z: f64;\n    if (hx >> 31) {\n      z = (1.0 + x) * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    z = (1.0 - x) * 0.5;\n    s = builtin_sqrt<f64>(z);\n    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    var c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    var e = reinterpret<u64>(x) >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    var z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    var s = builtin_sqrt<f64>(z);\n    var r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    if (hx >> 31) return -x;\n    return x;\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var s = u >> 63;\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    if (e >= 0x3FF + 26) x = log(x) + c;\n    else if (e >= 0x3FF + 1) x = log(2 * x + 1 / (builtin_sqrt<f64>(x * x + 1) + x));\n    else if (e >= 0x3FF - 26) x = log1p(x + x * x / (builtin_sqrt<f64>(x * x + 1) + 1));\n    return s ? -x : x;\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var ix = <u32>(reinterpret<u64>(x) >> 32);\n    var sign_ = ix >> 31;\n    ix &= 0x7FFFFFFF;\n    var z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return sign_ ? -z : z;\n    }\n    var id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    if (id < 0) return x - x * (s1 + s2);\n    switch (id) {\n      case 0: { z = atanhi0 - (x * (s1 + s2) - atanlo0 - x); break; }\n      case 1: { z = atanhi1 - (x * (s1 + s2) - atanlo1 - x); break; }\n      case 2: { z = atanhi2 - (x * (s1 + s2) - atanlo2 - x); break; }\n      case 3: { z = atanhi3 - (x * (s1 + s2) - atanlo3 - x); break; }\n      default: unreachable();\n    }\n    return sign_ ? -z : z;\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var s = u >> 63;\n    u &= 0x7FFFFFFFFFFFFFFF;\n    var y = reinterpret<f64>(u);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return s ? -y : y;\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f64>(0x400921FB54442D18), // 3.1415926535897931160E+00\n      pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var lx = <u32>u;\n    u = reinterpret<u64>(y);\n    var iy = <u32>(u >> 32);\n    var ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        switch (m) {\n          case 0: return  pi / 4;\n          case 1: return -pi / 4;\n          case 2: return  3 * pi / 4;\n          case 3: return -3 * pi / 4;\n        }\n      } else {\n        switch (m) {\n          case 0: return  0.0;\n          case 1: return -0.0;\n          case 2: return  pi;\n          case 3: return -pi;\n        }\n      }\n    }\n    var z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -pi / 2 : pi / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    var t = reinterpret<f64>(u);\n    var r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    var s = t * t;\n    r = x / s;\n    var w = t + t;\n    r = (r - t) / (w + r);\n    t = t + t * r;\n    return t;\n  }\n\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  @inline\n  export function clz32(x: f64): f64 {\n    return <f64>builtin_clz<i32>(<i32>x);\n  }\n\n  export function cos(x: f64): f64 { // TODO\n    unreachable();\n    return 0;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      return 1 + t * t / (2 * (1 + t));\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n      P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n      P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n      P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n      P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n      overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n      underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var sign_ = <i32>(hx >> 31);\n    hx &= 0x7FFFFFFF;\n    if (hx >= 0x4086232B) {\n      if (isNaN(x)) return x;\n      if (x > overflow) {\n        x *= Ox1p1023;\n        return x;\n      }\n      if (x < underflow) return 0;\n    }\n    var hi: f64, lo: f64 = 0;\n    var k: i32 = 0;\n    if (hx > 0x3FD62E42) {\n      if (hx >= 0x3FF0A2B2) {\n        k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));\n      } else {\n        k = 1 - sign_ - sign_;\n      }\n      hi = x - k * ln2hi;\n      lo = k * ln2lo;\n      x = hi - lo;\n    } else if (hx > 0x3E300000) {\n      hi = x;\n    } else return 1.0 + x;\n    var xx = x * x;\n    var c = x - xx * (P1 + xx * (P2 + xx * (P3 + xx * (P4 + xx * P5))));\n    var y = 1.0 + (x * c / (2 - c) - lo + hi);\n    if (k == 0) return y;\n    return scalbn(y, k);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32 & 0x7FFFFFFF);\n    var k = 0, sign_ = <i32>(u >> 63);\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) {\n        x *= Ox1p1023;\n        return x;\n      }\n    }\n    var c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      let hi: f64, lo: f64;\n      if (hx < 0x3FF0A2B2) {\n        if (!sign_) {\n          hi = x - ln2_hi;\n          lo = ln2_lo;\n          k =  1;\n        } else {\n          hi = x + ln2_hi;\n          lo = -ln2_lo;\n          k = -1;\n        }\n      } else {\n        k  = <i32>(invln2 * x + (sign_ ? -0.5 : 0.5));\n        t  = <f64>k;\n        hi = x - t * ln2_hi;\n        lo = t * ln2_lo;\n      }\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    var hfx = 0.5 * x;\n    var hxs = x * hfx;\n    var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    t = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    var twopk = reinterpret<f64>(u);\n    var y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    if (k < 20) y = (x - e + (1 - reinterpret<f64>(u))) * twopk;\n    else y = (x - (e + reinterpret<f64>(u)) + 1) * twopk;\n    return y;\n  }\n\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  @inline\n  export function fround(x: f64): f32 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    var ex = <i32>(ux >> 52);\n    var ey = <i32>(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    var z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    var c = x * SPLIT;\n    var h = x - c + c;\n    var l = x - h;\n    var hx = x * x;\n    var lx = h * h - hx + 2 * h * l + l * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    var hy = y * y;\n    var ly = h * h - hy + 2 * h * l + l * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    return <f64>(<i32>x * <i32>y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31)     return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) return x;\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += (<i32>hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = k;\n    return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) return x;\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln10hi;\n    var dk = <f64>k;\n    var y = dk * log10_2hi;\n    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    val_hi = w;\n    return val_lo + val_hi;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 1;\n    var c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = <u32>(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = <i32>(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n      ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n      Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54  = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) return x;\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln2hi;\n    var val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n    var y = <f64>k;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    val_hi = w;\n    return val_lo + val_hi;\n  }\n\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    const\n      dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n      dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n      two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n      huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n      tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n      L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n      L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n      L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n      L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n      L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n      L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n      P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n      P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n      P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n      P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n      P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n      lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n      lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n      lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n      ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n      cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n      cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n      cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n      ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n      ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44); //  1.92596299112661746887e-08\n    var u_ = reinterpret<u64>(x);\n    var hx = <i32>(u_ >> 32);\n    var lx = <u32>u_;\n    u_ = reinterpret<u64>(y);\n    var hy = <i32>(u_ >> 32);\n    var ly = <u32>u_;\n    var ix = hx & 0x7FFFFFFF;\n    var iy = hy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n    // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n    if ( // NaN if either arg is NaN\n      ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n      iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n    ) return x + y;\n    var yisint = 0, k: i32;\n    if (hx < 0) {\n      if (iy >= 0x43400000) yisint = 2;\n      else if (iy >= 0x3FF00000) {\n        k = (iy >> 20) - 0x3FF;\n        if (k > 20) {\n          let jj = ly >> (52 - k);\n          if ((jj << (52 - k)) == ly) yisint = 2 - (jj & 1);\n        } else if (ly == 0) {\n          let jj = iy >> (20 - k);\n          if ((jj << (20 - k)) == iy) yisint = 2 - (jj & 1);\n        }\n      }\n    }\n    if (ly == 0) {\n      if (iy == 0x7FF00000) { // y is +-inf\n        if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n        else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n        else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n      }\n      if (iy == 0x3FF00000) {\n        if (hy >= 0) return x;\n        return 1 / x;\n      }\n      if (hy == 0x40000000) return x * x;\n      if (hy == 0x3FE00000) {\n        if (hx >= 0) return builtin_sqrt(x);\n      }\n    }\n    var ax = builtin_abs<f64>(x), z: f64;\n    if (lx == 0) {\n      if (ix == 0x7FF00000 || ix == 0 || ix == 0x3FF00000) {\n        z = ax;\n        if (hy < 0) z = 1.0 / z;\n        if (hx < 0) {\n          if (((ix - 0x3FF00000) | yisint) == 0) z = (z - z) / (z - z);\n          else if (yisint == 1) z = -z;\n        }\n        return z;\n      }\n    }\n    var s = 1.0;\n    if (hx < 0) {\n      if (yisint == 0) return (x - x) / (x - x);\n      if (yisint == 1) s = -1.0;\n    }\n    var t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n    var j: i32, n: i32;\n    if (iy > 0x41E00000) {\n      if (iy > 0x43F00000) {\n        if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n        if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n      }\n      if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n      if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n      t = ax - 1.0;\n      w = (t * t) * (0.5 - t * (0.3333333333333333333333 - t * 0.25));\n      u = ivln2_h * t;\n      v = t * ivln2_l - w * ivln2;\n      t1 = u + v;\n      t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n      t2 = v - (t1 - u);\n    } else {\n      let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n      n = 0;\n      if (ix < 0x00100000) {\n        ax *= two53;\n        n -= 53;\n        ix = <u32>(reinterpret<u64>(ax) >> 32);\n      }\n      n += (ix >> 20) - 0x3FF;\n      j = ix & 0x000FFFFF;\n      ix = j | 0x3FF00000;\n      if (j <= 0x3988E) k = 0;\n      else if (j < 0xBB67A) k = 1;\n      else {\n        k = 0;\n        n += 1;\n        ix -= 0x00100000;\n      }\n      ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n      let bp = select<f64>(1.5, 1.0, k);\n      u = ax - bp;\n      v = 1.0 / (ax + bp);\n      ss = u * v;\n      s_h = ss;\n      s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n      t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n      t_l = ax - (t_h - bp);\n      s_l = v * ((u - s_h * t_h) - s_h * t_l);\n      s2 = ss * ss;\n      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n      r += s_l * (s_h + ss);\n      s2 = s_h * s_h;\n      t_h = 3.0 + s2 + r;\n      t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n      t_l = r - ((t_h - 3.0) - s2);\n      u = s_h * t_h;\n      v = s_l * t_h + t_l * ss;\n      p_h = u + v;\n      p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n      p_l = v - (p_h - u);\n      let z_h = cp_h * p_h;\n      let dp_l = select<f64>(dp_l1, 0.0, k);\n      let z_l = cp_l * p_h + p_l * cp + dp_l;\n      t = <f64>n;\n      let dp_h = select<f64>(dp_h1, 0.0, k);\n      t1 = ((z_h + z_l) + dp_h) + t;\n      t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n      t2 = z_l - (((t1 - t) - dp_h) - z_h);\n    }\n    var y1 = y;\n    y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n    p_l = (y - y1) * t1 + y * t2;\n    p_h = y1 * t1;\n    z = p_l + p_h;\n    u_ = reinterpret<u64>(z);\n    j = <u32>(u_ >> 32);\n    var i = <i32>u_;\n    if (j >= 0x40900000) {\n      if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n      if (p_l + ovt > z - p_h) return s * huge * huge;\n    } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n      if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n      if (p_l <= z - p_h) return s * tiny * tiny;\n    }\n    i = j & 0x7FFFFFFF;\n    k = (i >> 20) - 0x3FF;\n    n = 0;\n    if (i > 0x3FE00000) {\n      n = j + (0x00100000 >> (k + 1));\n      k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n      t = 0.0;\n      t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);\n      n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n      if (j < 0) n = -n;\n      p_h -= t;\n    }\n    t = p_l + p_h;\n    t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n    u = t * lg2_h;\n    v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n    z = u + v;\n    w = v - (z - u);\n    t = z * z;\n    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n    r = (z * t1) / (t1 - 2.0) - (w + z * w);\n    z = 1.0 - (r - z);\n    j = <u32>(reinterpret<u64>(z) >> 32);\n    j += n << 20;\n    if ((j >> 20) <= 0) z = scalbn(z, n);\n    else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n    return s * z;\n  }\n\n  export function seedRandom(value: i64): void {\n    assert(value);\n    random_seeded = true;\n    random_state0 = murmurHash3(value);\n    random_state1 = murmurHash3(random_state0);\n  }\n\n  export function random(): f64 { // see: v8/src/base/random-number-generator.cc\n    if (!random_seeded) throw new Error("PRNG must be seeded.");\n    var s1 = random_state0;\n    var s0 = random_state1;\n    random_state0 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1 = s1;\n    var r = ((s0 + s1) & 0x000FFFFFFFFFFFFF) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  export function round(x: f64): f64 { // see: musl/src/math/round.c\n    const toint = 1.0 / f64.EPSILON;\n    var ux = reinterpret<u64>(x);\n    var e = <i32>(ux >> 52 & 0x7FF);\n    if (e >= 0x3FF + 52) return x;\n    if (e < 0x3FF - 1) return 0 * x;\n    var y: f64;\n    if (ux >> 63) {\n      // FIXME: JS always rounds fractional 0.5 towards +Infinity\n      // and there certainly is a smarter way to do this.\n      y = toint - x - toint + x;\n      if (y >= 0.5) y = x - y + 1;\n      else if (y < -0.5) y = x - y - 1;\n      else y = x - y;\n    } else {\n      y = x + toint - toint - x;\n      if (y > 0.5) y = y + x - 1;\n      else if (y <= -0.5) y = y + x + 1;\n      else y = y + x;\n    }\n    return y;\n  }\n\n  @inline\n  export function sign(x: f64): f64 {\n    // return x > 0 ? 1 : x < 0 ? -1 : x;\n    return builtin_abs<f64>(x) > 0 ? builtin_copysign<f64>(1, x) : x;\n  }\n\n  export function sin(x: f64): f64 { // TODO\n    unreachable();\n    return 0;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    var u = reinterpret<u64>(x);\n    var h = 0.5;\n    if (u >> 63) h = -h;\n    u &=  0x7FFFFFFFFFFFFFFF;\n    var absx = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w < 0x40862E42) {\n      t = expm1(absx);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    t = 2 * h * expo2(absx);\n    return t;\n  }\n\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // TODO\n    unreachable();\n    return 0;\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    var u = reinterpret<u64>(x);\n    var sign_ = <i32>(u >> 63);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / x;\n      } else {\n        t = expm1(2 * x);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * x);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * x);\n      t = -t / (t + 2);\n    } else t = x;\n    return sign_ ? -t : t;\n  }\n\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  /** @internal */\n  export function scalbn(x: f64, n: i32): f64 { // see: musl/src/math/scalbn.c\n    const\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n    var y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n -= 1023;\n        if (n > 1023) n = 1023;\n      }\n    } else if (n < -1022) {\n      y *= Ox1p_1022;\n      n += 1022;\n      if (n < -1022) {\n        y *= Ox1p_1022;\n        n += 1022;\n        if (n < -1022) n = -1022;\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i32>(ux >> 52 & 0x7FF);\n    var ey = <i32>(uy >> 52 & 0x7FF);\n    var sx = <i32>(ux >> 63);\n    if (uy << 1 == 0 || isNaN<f64>(y) || ex == 0x7FF) return (x * y) / (x * y);\n    if (ux << 1 <= uy << 1) {\n      if (ux << 1 == uy << 1) return 0 * x;\n      return x;\n    }\n    var i: u64;\n    if (!ex) {\n      for (i = ux << 12; !(i >> 63); i <<= 1) --ex;\n      ux <<= -ex + 1;\n    } else {\n      ux &= <u64>-1 >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      for (i = uy << 12; !(i >> 63); i <<= 1) --ey;\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    for (; ex > ey; ex--) {\n      i = ux - uy;\n      if (!(i >> 63)) {\n        if (!i) return 0 * x;\n        ux = i;\n      }\n      ux <<= 1;\n    }\n    i = ux - uy;\n    if (!(i >> 63)) {\n      if (!i) return 0 * x;\n      ux = i;\n    }\n    for (; !(ux >> 52); ux <<= 1) --ex;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= <u64>ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    ux |= <u64>sx << 63;\n    return reinterpret<f64>(ux);\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i32>(ux >> 52 & 0x7FF);\n    var ey = <i32>(uy >> 52 & 0x7FF);\n    var sx = <i32>(ux >> 63);\n    var sy = <i32>(uy >> 63);\n    if (uy << 1 == 0 || isNaN(y) || ex == 0x7FF) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    var uxi = ux;\n    var i: u64;\n    if (!ex) {\n      for (i = uxi << 12; i >> 63 == 0; ex--, i <<= 1) {}\n      uxi <<= -ex + 1;\n    } else {\n      uxi &= <u64>-1 >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      for (i = uy << 12; i >> 63 == 0; ey--, i <<= 1) {}\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    var q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      for (; ex > ey; ex--) {\n        i = uxi - uy;\n        if (i >> 63 == 0) {\n          uxi = i;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n      }\n      i = uxi - uy;\n      if (i >> 63 == 0) {\n        uxi = i;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else for (; uxi >> 52 == 0; uxi <<= 1, ex--) {}\n      break;\n    } while (false);\n  // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= <u64>ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    if (sy) y = -y;\n    if (ex == ey || (ex + 1 == ey && (2.0 * x > y || (2.0 * x == y && <bool>(q & 1))))) {\n      x -= y;\n      ++q;\n    }\n    return sx ? -x : x;\n  }\n}\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n  var p = z * (pS0 + z * (pS1 + z * pS2));\n  var q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\nfunction expo2f(x: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                        // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  var scale = reinterpret<f32>(<u32>(0x7F + k / 2) << 23);\n  return NativeMathf.exp(x - kln2) * scale * scale;\n}\n\nexport namespace NativeMathf {\n\n  export const E       = <f32>NativeMath.E;\n  export const LN2     = <f32>NativeMath.LN2;\n  export const LN10    = <f32>NativeMath.LN10;\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n  export const PI      = <f32>NativeMath.PI;\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = reinterpret<u32>(x);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    var z: f32, w: f32, s: f32;\n    if (hx >> 31) {\n      z = (1 + x) * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    z = (1 - x) * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    var df = reinterpret<f32>(hx & 0xFFFFF000);\n    var c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x);\n    var a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) return log1p(x - 1 + builtin_sqrt((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (a < 0x3F800000 + (12 << 23)) return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = reinterpret<u32>(x);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix < 0x39800000 && ix >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    var s = builtin_sqrt<f64>(z); // sic\n    x = <f32>(pio2 - 2 * (s + s * Rf(z)));\n    if (hx >> 31) return -x;\n    return x;\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x);\n    var i = u & 0x7FFFFFFF;\n    var s = <u32>(u >> 31);\n    u = i;\n    x = reinterpret<f32>(u);\n    if (i >= 0x3F800000 + (12 << 23)) x = log(x) + c;\n    else if (i >= 0x3F800000 + (1 << 23)) x = log(2 * x + 1 / (builtin_sqrt<f32>(x * x + 1) + x));\n    else if (i >= 0x3F800000 - (12 << 23)) x = log1p(x + x * x / (builtin_sqrt<f32>(x * x + 1) + 1));\n    return s ? -x : x;\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var ix = reinterpret<u32>(x);\n    var sig = <u32>(ix >> 31);\n    ix &= 0x7FFFFFFF;\n    var z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return sig ? -z : z;\n    }\n    var id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * aT4));\n    var s2 = w * (aT1 + w * aT3);\n    if (id < 0) return x - x * (s1 + s2);\n    switch (id) {\n      case 0: { z = atanhi0 - ((x * (s1 + s2) - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((x * (s1 + s2) - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((x * (s1 + s2) - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((x * (s1 + s2) - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return sig ? -z : z;\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    var u = reinterpret<u32>(x);\n    var s = <u32>(u >> 31);\n    u &= 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return s ? -y : y;\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var ix = reinterpret<u32>(x);\n    var iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        switch (m) {\n          case 0: return  pi / 4;\n          case 1: return -pi / 4;\n          case 2: return  3 * pi / 4;\n          case 3: return -3 * pi / 4;\n        }\n      } else {\n        switch (m) {\n          case 0: return  0;\n          case 1: return -0;\n          case 2: return  pi;\n          case 3: return -pi;\n        }\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    var z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    var T = <f64>reinterpret<f32>(u);\n    var r = T * T * T;\n    T = T * (<f64>x + x + r) / (x + r + r);\n    r = T * T * T;\n    T = T * (<f64>x + x + r) / (x + r + r);\n    return <f32>T;\n  }\n\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  @inline\n  export function clz32(x: f32): f32 {\n    return <f32>builtin_clz<i32>(<i32>x);\n  }\n\n  export function cos(x: f32): f32 { // TODO\n    unreachable();\n    return 0;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      return 1 + t * t / (2 * (1 + t));\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    return expo2f(x);\n  }\n\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n      ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n      P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n      P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n      Ox1p127f = reinterpret<f32>(0x7F000000);\n    var hx = reinterpret<u32>(x);\n    var sign_ = <i32>(hx >> 31);\n    hx &= 0x7FFFFFFF;\n    if (hx >= 0x42AEAC50) {\n      if (hx >= 0x42B17218 && !sign_) {\n        x *= Ox1p127f;\n        return x;\n      }\n      if (sign_ && hx >= 0x42CFF1B5) return 0;\n    }\n    var hi: f32, lo: f32;\n    var k: i32;\n    if (hx > 0x3EB17218) {\n      if (hx > 0x3F851592) {\n        k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));\n      } else {\n        k = 1 - sign_ - sign_;\n      }\n      hi = x - <f32>k * ln2hi;\n      lo = <f32>k * ln2lo;\n      x = hi - lo;\n    } else if (hx > 0x39000000) {\n      k = 0;\n      hi = x;\n      lo = 0;\n    } else {\n      return 1 + x;\n    }\n    var xx = x * x;\n    var c = x - xx * (P1 + xx * P2);\n    var y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n    if (k == 0) return y;\n    return scalbn(y, k);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f32>(0x42B17180), //  8.8721679688e+01f\n      ln2_hi      = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo      = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2      = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1          = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2          = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f    = reinterpret<f32>(0x7F000000);\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    var sign_ = <i32>(u >> 31);\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) {\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    var c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      let hi: f32, lo: f32;\n      if (hx < 0x3F851592) {\n        if (!sign_) {\n          hi = x - ln2_hi;\n          lo = ln2_lo;\n          k =  1;\n        } else {\n          hi = x + ln2_hi;\n          lo = -ln2_lo;\n          k = -1;\n        }\n      } else {\n        k  = <i32>(invln2 * x + (sign_ ? -0.5 : 0.5));\n        t  = <f32>k;\n        hi = x - t * ln2_hi;\n        lo = t * ln2_lo;\n      }\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    var hfx: f32 = 0.5 * x;\n    var hxs: f32 = x * hfx;\n    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    var twopk = reinterpret<f32>(u);\n    var y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    if (k < 23) y = (x - e + (1 - reinterpret<f32>(u))) * twopk;\n    else y = (x - (e + reinterpret<f32>(u)) + 1) * twopk;\n    return y;\n  }\n\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    var z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));\n  }\n\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    return <f32>(<i32>x * <i32>y);\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n      ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n      Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n      Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n      Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n      Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n      Ox1p25f = reinterpret<f32>(0x4C000000);\n    var u = reinterpret<u32>(x);\n    var k = 0;\n    if (u < 0x00800000 || <bool>(u >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (u >> 31) return (x - x) / 0;\n      k -= 25;\n      x *= Ox1p25f;\n      u = reinterpret<u32>(x);\n    } else if (u >= 0x7F800000) return x;\n      else if (u == 0x3F800000) return 0;\n    u += 0x3F800000 - 0x3F3504F3;\n    k += <u32>(<i32>u >> 23) - 0x7F;\n    u = (u & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(u);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq = <f32>0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000);\n    var ix = reinterpret<u32>(x);\n    var k = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) return x;\n      else if (ix == 0x3F800000) return 0;\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    ix = reinterpret<u32>(hi);\n    ix &= 0xFFFFF000;\n    hi = reinterpret<f32>(ix);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n    var ix = reinterpret<u32>(x);\n    var c: f32 = 0, f: f32 = 0;\n    var k: i32 = 1;\n    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = <i32>(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n      ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n      Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f = reinterpret<f32>(0x4C000000);\n    var ix = reinterpret<u32>(x);\n    var k: i32 = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) return x;\n      else if (ix == 0x3F800000) return 0;\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    var u = reinterpret<u32>(hi);\n    u &= 0xFFFFF000;\n    hi = reinterpret<f32>(u);\n    var lo: f32 = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n  }\n\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 { // see: musl/src/math/powf.c and SUN COPYRIGHT NOTICE above\n    const\n      dp_h1   = reinterpret<f32>(0x3F15C000), //  5.84960938e-01f\n      dp_l1   = reinterpret<f32>(0x35D1CFDC), //  1.56322085e-06f\n      two24   = reinterpret<f32>(0x4B800000), //  16777216f\n      huge    = reinterpret<f32>(0x7149F2CA), //  1.0e+30f\n      tiny    = reinterpret<f32>(0x0DA24260), //  1.0e-30f\n      L1      = reinterpret<f32>(0x3F19999A), //  6.0000002384e-01f\n      L2      = reinterpret<f32>(0x3EDB6DB7), //  4.2857143283e-01f\n      L3      = reinterpret<f32>(0x3EAAAAAB), //  3.3333334327e-01f\n      L4      = reinterpret<f32>(0x3E8BA305), //  2.7272811532e-01f\n      L5      = reinterpret<f32>(0x3E6C3255), //  2.3066075146e-01f\n      L6      = reinterpret<f32>(0x3E53F142), //  2.0697501302e-01f\n      P1      = reinterpret<f32>(0x3E2AAAAB), //  1.6666667163e-01f\n      P2      = reinterpret<f32>(0xBB360B61), // -2.7777778450e-03f\n      P3      = reinterpret<f32>(0x388AB355), //  6.6137559770e-05f\n      P4      = reinterpret<f32>(0xB5DDEA0E), // -1.6533901999e-06f\n      P5      = reinterpret<f32>(0x3331BB4C), //  4.1381369442e-08f\n      lg2     = reinterpret<f32>(0x3F317218), //  6.9314718246e-01f\n      lg2_h   = reinterpret<f32>(0x3F317200), //  6.93145752e-01f\n      lg2_l   = reinterpret<f32>(0x35BFBE8C), //  1.42860654e-06f\n      ovt     = reinterpret<f32>(0x3338AA3C), //  4.2995665694e-08f\n      cp      = reinterpret<f32>(0x3F76384F), //  9.6179670095e-01\n      cp_h    = reinterpret<f32>(0x3F764000), //  9.6191406250e-01\n      cp_l    = reinterpret<f32>(0xB8F623C6), // -1.1736857402e-04\n      ivln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00\n      ivln2_h = reinterpret<f32>(0x3FB8AA00), //  1.4426879883e+00\n      ivln2_l = reinterpret<f32>(0x36ECA570); //  7.0526075433e-06\n    var hx = reinterpret<i32>(x);\n    var hy = reinterpret<i32>(y);\n    var ix = hx & 0x7FFFFFFF;\n    var iy = hy & 0x7FFFFFFF;\n    if (iy == 0) return 1.0; // x**0 = 1, even if x is NaN\n    // if (hx == 0x3F800000) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n    if (ix > 0x7F800000 || iy > 0x7F800000) return x + y; // NaN if either arg is NaN\n    var yisint  = 0, j: i32, k: i32;\n    if (hx < 0) {\n      if (iy >= 0x4B800000) yisint = 2;\n      else if (iy >= 0x3F800000) {\n        k = (iy >> 23) - 0x7F;\n        j = iy >> (23 - k);\n        if ((j << (23 - k)) == iy) yisint = 2 - (j & 1);\n      }\n    }\n    if (iy == 0x7F800000) { // y is +-inf\n      if (ix == 0x3F800000) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n      else if (ix > 0x3F800000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n      else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n    }\n    if (iy == 0x3F800000) return hy >= 0 ? x : 1.0 / x;\n    if (hy == 0x40000000) return x * x;\n    if (hy == 0x3F000000) {\n      if (hx >= 0) return builtin_sqrt<f32>(x);\n    }\n    var ax = builtin_abs<f32>(x);\n    var z: f32;\n    if (ix == 0x7F800000 || ix == 0 || ix == 0x3F800000) {\n      z = ax;\n      if (hy < 0) z = 1.0 / z;\n      if (hx < 0) {\n        if (((ix - 0x3F800000) | yisint) == 0) z = (z - z) / (z - z);\n        else if (yisint == 1) z = -z;\n      }\n      return z;\n    }\n    var sn = <f32>1.0;\n    if (hx < 0) {\n      if (yisint == 0) return (x - x) / (x - x);\n      if (yisint == 1) sn = -1.0;\n    }\n    var t1: f32, t2: f32, r: f32, s: f32, t: f32, u: f32, v: f32, w: f32, p_h: f32, p_l: f32;\n    var n: i32, is: i32;\n    if (iy > 0x4D000000) {\n      if (ix < 0x3F7FFFF8) return hy < 0 ? sn * huge * huge : sn * tiny * tiny;\n      if (ix > 0x3F800007) return hy > 0 ? sn * huge * huge : sn * tiny * tiny;\n      t = ax - 1;\n      w = (t * t) * (0.5 - t * (0.333333333333 - t * 0.25));\n      u = ivln2_h * t;\n      v = t * ivln2_l - w * ivln2;\n      t1 = u + v;\n      is = reinterpret<i32>(t1);\n      t1 = reinterpret<f32>(is & 0xFFFFF000);\n      t2 = v - (t1 - u);\n    } else {\n      let s2: f32, s_h: f32, s_l: f32, t_h: f32, t_l: f32;\n      n = 0;\n      if (ix < 0x00800000) {\n        ax *= two24;\n        n -= 24;\n        ix = reinterpret<i32>(ax);\n      }\n      n += (ix >> 23) - 0x7F;\n      j = ix & 0x007FFFFF;\n      ix = j | 0x3F800000;\n      if (j <= 0x1CC471) k = 0;\n      else if (j < 0x5DB3D7) k = 1;\n      else {\n        k = 0;\n        n += 1;\n        ix -= 0x00800000;\n      }\n      ax = reinterpret<f32>(ix);\n      let bp = select<f32>(1.5, 1.0, k);\n      u = ax - bp;\n      v = 1.0 / (ax + bp);\n      s = u * v;\n      s_h = s;\n      is = reinterpret<u32>(s_h);\n      s_h = reinterpret<f32>(is & 0xFFFFF000);\n      is = ((ix >> 1) & 0xFFFFF000) | 0x20000000;\n      t_h = reinterpret<f32>(is + 0x00400000 + (k << 21));\n      t_l = ax - (t_h - bp);\n      s_l = v * ((u - s_h * t_h) - s_h * t_l);\n      s2 = s * s;\n      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n      r += s_l * (s_h + s);\n      s2 = s_h * s_h;\n      t_h = 3.0 + s2 + r;\n      is = reinterpret<u32>(t_h);\n      t_h = reinterpret<f32>(is & 0xFFFFF000);\n      t_l = r - ((t_h - 3.0) - s2);\n      u = s_h * t_h;\n      v = s_l * t_h + t_l * s;\n      p_h = u + v;\n      is = reinterpret<u32>(p_h);\n      p_h = reinterpret<f32>(is & 0xFFFFF000);\n      p_l = v - (p_h - u);\n      let z_h = cp_h * p_h;\n      let dp_l = select<f32>(dp_l1, 0.0, k);\n      let z_l = cp_l * p_h + p_l * cp + dp_l;\n      t = <f32>n;\n      let dp_h = select<f32>(dp_h1, 0.0, k);\n      t1 = (((z_h + z_l) + dp_h) + t);\n      is = reinterpret<u32>(t1);\n      t1 = reinterpret<f32>(is & 0xFFFFF000);\n      t2 = z_l - (((t1 - t) - dp_h) - z_h);\n    }\n    is = reinterpret<u32>(y);\n    var y1 = reinterpret<f32>(is & 0xFFFFF000);\n    p_l = (y - y1) * t1 + y * t2;\n    p_h = y1 * t1;\n    z = p_l + p_h;\n    j = reinterpret<u32>(z);\n    if (j > 0x43000000) {\n      return sn * huge * huge;\n    } else if (j == 0x43000000) {\n      if (p_l + ovt > z - p_h) return sn * huge * huge;\n    } else if ((j & 0x7FFFFFFF) > 0x43160000) {\n      return sn * tiny * tiny;\n    } else if (j == 0xC3160000) {\n      if (p_l <= z - p_h) return sn * tiny * tiny;\n    }\n    var i = j & 0x7FFFFFFF;\n    k = (i >> 23) - 0x7F;\n    n = 0;\n    if (i > 0x3F000000) {\n      n = j + (0x00800000 >> (k + 1));\n      k = ((n & 0x7FFFFFFF) >> 23) - 0x7F;\n      t = reinterpret<f32>(n & ~(0x007FFFFF >> k));\n      n = ((n & 0x007FFFFF) | 0x00800000) >> (23 - k);\n      if (j < 0) n = -n;\n      p_h -= t;\n    }\n    t = p_l + p_h;\n    is = reinterpret<u32>(t);\n    t = reinterpret<f32>(is & 0xFFFF8000);\n    u = t * lg2_h;\n    v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n    z = u + v;\n    w = v - (z - u);\n    t = z * z;\n    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n    r = (z * t1) / (t1 - 2.0) - (w + z * w);\n    z = 1.0 - (r - z);\n    j = reinterpret<u32>(z);\n    j += n << 23;\n    if ((j >> 23) <= 0) z = scalbn(z, n);\n    else z = reinterpret<f32>(j);\n    return sn * z;\n  }\n\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  export function random(): f32 {\n    var f: f32; // FIXME: demoting from f64 to f32 might yield 1.0f\n    do f = <f32>NativeMath.random(); while (f == 1.0);\n    return f;\n  }\n\n  export function round(x: f32): f32 { // see: musl/src/math/roundf.c\n    const toint = <f32>1.0 / f32.EPSILON;\n    var ux = reinterpret<u32>(x);\n    var e = <i32>(ux >> 23 & 0xFF);\n    if (e >= 0x7F + 23) return x;\n    if (e < 0x7F - 1) return 0 * x;\n    var y: f32;\n    if (ux >> 31) {\n      // FIXME: JS always rounds fractional 0.5 towards +Infinity\n      // and there certainly is a smarter way to do this.\n      y = toint - x - toint + x;\n      if (y >= 0.5) y = x - y + 1;\n      else if (y < -0.5) y = x - y - 1;\n      else y = x - y;\n    } else {\n      y = x + toint - toint - x;\n      if (y > 0.5) y = y + x - 1;\n      else if (y <= -0.5) y = y + x + 1;\n      else y = y + x;\n    }\n    return y;\n  }\n\n  @inline\n  export function sign(x: f32): f32 {\n    // return x > 0 ? 1 : x < 0 ? -1 : x;\n    return builtin_abs<f32>(x) > 0 ? builtin_copysign<f32>(1, x) : x;\n  }\n\n  export function sin(x: f32): f32 { // TODO\n    unreachable();\n    return 0;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    var u = reinterpret<u32>(x);\n    var h: f32 = 0.5;\n    if (u >> 31) h = -h;\n    u &= 0x7FFFFFFF;\n    var absx = reinterpret<f32>(u);\n    var t: f32;\n    if (u < 0x42B17217) {\n      t = expm1(absx);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    t = 2 * h * expo2f(absx);\n    return t;\n  }\n\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // TODO\n    unreachable();\n    return 0;\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    var u = reinterpret<u32>(x);\n    var sig = u >> 31;\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    var t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / x;\n      else {\n        t = expm1(2 * x);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * x);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * x);\n      t = -t / (t + 2);\n    } else t = x;\n    return sig ? -t : t;\n  }\n\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  /** @internal */\n  export function scalbn(x: f32, n: i32): f32 { // see: musl/src/math/scalbnf.c\n    const\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n    var y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n -= 127;\n        if (n > 127) n = 127;\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f;\n      n += 126;\n      if (n < -126) {\n        y *= Ox1p_126f;\n        n += 126;\n        if (n < -126) n = -126;\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = ux & 0x80000000;\n    if (uy << 1 == 0 || isNaN<f32>(y) || ex == 0xFF) return (x * y) / (x * y);\n    if (ux << 1 <= uy << 1) {\n      if (ux << 1 == uy << 1) return 0 * x;\n      return x;\n    }\n    var i: u32;\n    if (!ex) {\n      for (i = ux << 9; !(i >> 31); i <<= 1) --ex;\n      ux <<= -ex + 1;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      for (i = uy << 9; !(i >> 31); i <<= 1) --ey;\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    for (; ex > ey; --ex) {\n      i = ux - uy;\n      if (!(i >> 31)) {\n        if (!i) return 0 * x;\n        ux = i;\n      }\n      ux <<= 1;\n    }\n    i = ux - uy;\n    if (!(i >> 31)) {\n      if (!i) return 0 * x;\n      ux = i;\n    }\n    for (; !(ux >> 23); ux <<= 1) --ex;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    ux |= sx;\n    return reinterpret<f32>(ux);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = <i32>(ux >> 31);\n    var sy = <i32>(uy >> 31);\n    var i: u32;\n    var uxi = ux;\n    if (uy << 1 == 0 || isNaN(y) || ex == 0xFF) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      for (i = uxi << 9; i >> 31 == 0; ex--, i <<= 1) {}\n      uxi <<= -ex + 1;\n    } else {\n      uxi &= <u32>-1 >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      for (i = uy << 9; i >> 31 == 0; ey--, i <<= 1) {}\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    var q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      for (; ex > ey; ex--) {\n        i = uxi - uy;\n        if (i >> 31 == 0) {\n          uxi = i;\n          q++;\n        }\n        uxi <<= 1;\n        q <<= 1;\n      }\n      i = uxi - uy;\n      if (i >> 31 == 0) {\n        uxi = i;\n        q++;\n      }\n      if (uxi == 0) ex = -30;\n      else for (; uxi >> 23 == 0; uxi <<= 1, ex--) {}\n      break;\n    } while (false);\n  // end\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    if (sy) y = -y;\n    if (ex == ey || (ex + 1 == ey && (<f32>2 * x > y || (<f32>2 * x == y && <bool>(q & 1))))) {\n      x -= y;\n      q++;\n    }\n    return sx ? -x : x;\n  }\n}\n',memory:"export namespace memory {\n\n  @builtin export declare function size(): i32; // tslint:disable-line\n\n  @builtin export declare function grow(pages: i32): i32; // tslint:disable-line\n\n  export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n    if (isDefined(__memory_fill)) { __memory_fill(dest, c, n); return; } // tslint:disable-line\n    memset(dest, c, n);\n  }\n\n  export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n    if (isDefined(__memory_copy)) { __memory_copy(dest, src, n); return; } // tslint:disable-line\n    memmove(dest, src, n);\n  }\n\n  export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n    if (isDefined(__memory_compare)) return __memory_compare(vl, vr, n); // tslint:disable-line\n    return memcmp(vl, vr, n);\n  }\n\n  // Passive segments\n\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\n  // }\n\n  // export function drop(segmentIndex: u32): void {\n  //   __memory_drop(segmentIndex);\n  // }\n\n  // Allocator\n\n  export function allocate(size: usize): usize {\n    if (isDefined(__memory_allocate)) return __memory_allocate(size); // tslint:disable-line\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\n    return <usize>unreachable();\n  }\n\n  export function free(ptr: usize): void {\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; } // tslint:disable-line\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\n    unreachable();\n  }\n\n  export function reset(): void {\n    if (isDefined(__memory_reset)) { __memory_reset(); return; } // tslint:disable-line\n    unreachable();\n  }\n}\n\n// this function will go away once `memory.copy` becomes an intrinsic\nfunction memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// this function will go away once `memory.copy` becomes an intrinsic\nfunction memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest == src) return;\n  if (src + n <= dest || dest + n <= src) {\n    memcpy(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// this function will go away once `memory.fill` becomes an intrinsic\nfunction memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n\n  // fill head and tail with minimal branching\n  if (!n) return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2) return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6) return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8) return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8) return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24) return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nfunction memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n  if (vl == vr) return 0;\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\n    n--; vl++; vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n",polyfills:"export function bswap<T>(value: T): T {\n  assert(sizeof<T>() == 1 || sizeof<T>() == 2 || sizeof<T>() == 4 || sizeof<T>() == 8);\n\n  if (sizeof<T>() == 2) {\n    return bswap16<T>(value);\n  }\n  if (sizeof<T>() == 4) {\n    return <T>(\n      rotl<u32>(<u32>value & 0xFF00FF00, 8) |\n      rotr<u32>(<u32>value & 0x00FF00FF, 8)\n    );\n  }\n  if (sizeof<T>() == 8) {\n    let a: u64 = (<u64>value >> 8) & 0x00FF00FF00FF00FF;\n    let b: u64 = (<u64>value & 0x00FF00FF00FF00FF) << 8;\n    let v: u64 = a | b;\n\n    a = (v >> 16) & 0x0000FFFF0000FFFF;\n    b = (v & 0x0000FFFF0000FFFF) << 16;\n\n    return <T>rotr<u64>(a | b, 32);\n  }\n  return value;\n}\n\nexport function bswap16<T>(value: T): T {\n  assert(sizeof<T>() == 1 || sizeof<T>() == 2 || sizeof<T>() == 4);\n\n  if (sizeof<T>() == 2 || sizeof<T>() == 4) {\n    return <T>(((value << 8) & <T>0xFF00) | ((value >> 8) & <T>0x00FF) | (value & <T>0xFFFF0000));\n  }\n  return value;\n}\n",regexp:'export class RegExp {\n\n  // @binding(CALL_NEW, [ STRING, STRING], OBJECT_HANDLE)\n  constructor(pattern: string, flags: string = "") { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [ STRING ], PASS_THRU)\n  test(search: string): bool { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [], STRING)\n  toString(): string { throw new Error("unreachable"); }\n\n}\n',set:'import {\n  HEADER_SIZE as HEADER_SIZE_AB\n} from "./internal/arraybuffer";\n\nimport {\n  hash\n} from "./internal/hash";\n\n// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht\n\nconst INITIAL_CAPACITY = 4;\nconst FILL_FACTOR: f64 = 8 / 3;\nconst FREE_FACTOR: f64 = 3 / 4;\n\n/** Structure of a set entry. */\n@unmanaged class SetEntry<K> {\n  key: K;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\nconst EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\nconst BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n@inline function ENTRY_ALIGN<K>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits\n  const align = (sizeof<K>() > sizeof<usize>() ? sizeof<K>() : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n@inline function ENTRY_SIZE<K>(): usize {\n  const align = ENTRY_ALIGN<K>();\n  const size = (offsetof<SetEntry<K>>() + align) & ~align;\n  return size;\n}\n\nexport class Set<K> {\n\n  // buckets holding references to the respective first entry within\n  private buckets: ArrayBuffer; // usize[bucketsMask + 1]\n  private bucketsMask: u32;\n\n  // entries in insertion order\n  private entries: ArrayBuffer; // SetEntry<K>[entriesCapacity]\n  private entriesCapacity: i32;\n  private entriesOffset: i32;\n  private entriesCount: i32;\n\n  get size(): i32 { return this.entriesCount; }\n\n  constructor() { this.clear(); }\n\n  clear(): void {\n    const bucketsSize = INITIAL_CAPACITY * <i32>BUCKET_SIZE;\n    this.buckets = new ArrayBuffer(bucketsSize);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    const entriesSize = INITIAL_CAPACITY * <i32>ENTRY_SIZE<K>();\n    this.entries = new ArrayBuffer(entriesSize, true);\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): SetEntry<K> | null {\n    var entry = load<SetEntry<K>>(\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE,\n      HEADER_SIZE_AB\n    );\n    while (entry) {\n      if (!(entry.taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<SetEntry<K>>(entry.taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, hash(key)) !== null;\n  }\n\n  add(key: K): void {\n    var hashCode = hash(key);\n    var entry = this.find(key, hashCode);\n    if (!entry) {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<SetEntry<K>>(\n        changetype<usize>(entries) + HEADER_SIZE_AB + this.entriesOffset++ * ENTRY_SIZE<K>()\n      );\n      entry.key = key;\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase, HEADER_SIZE_AB);\n      store<usize>(bucketPtrBase, changetype<usize>(entry), HEADER_SIZE_AB);\n    }\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, hash<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = <i32>(newBucketsCapacity * FILL_FACTOR);\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K>(), true);\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries) + HEADER_SIZE_AB;\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K>();\n    var newPtr = changetype<usize>(newEntries) + HEADER_SIZE_AB;\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<SetEntry<K>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<SetEntry<K>>(newPtr);\n        newEntry.key = oldEntry.key;\n        let newBucketIndex = hash<K>(oldEntry.key) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase, HEADER_SIZE_AB);\n        store<usize>(newBucketPtrBase, newPtr, HEADER_SIZE_AB);\n        newPtr += ENTRY_SIZE<K>();\n      }\n      oldPtr += ENTRY_SIZE<K>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n}\n',string:'import {\n  HEADER_SIZE,\n  MAX_LENGTH,\n  EMPTY,\n  clamp,\n  allocate,\n  isWhiteSpaceOrLineTerminator,\n  CharCode,\n  parse\n} from "./internal/string";\n\n@sealed\nexport class String {\n\n  readonly length: i32; // capped to [0, MAX_LENGTH]\n\n  static fromCharCode(code: i32): String {\n    var out = allocate(1);\n    store<u16>(\n      changetype<usize>(out),\n      <u16>code,\n      HEADER_SIZE\n    );\n    return out;\n  }\n\n  @operator("[]")\n  charAt(pos: i32): String {\n    assert(this !== null);\n\n    if (<u32>pos >= <u32>this.length) {\n      return EMPTY;\n    }\n\n    var out = allocate(1);\n    store<u16>(\n      changetype<usize>(out),\n      load<u16>(\n        changetype<usize>(this) + (<usize>pos << 1),\n        HEADER_SIZE\n      ),\n      HEADER_SIZE\n    );\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    assert(this !== null);\n    if (<u32>pos >= <u32>this.length) {\n      return -1; // (NaN)\n    }\n    return load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n  }\n\n  codePointAt(pos: i32): i32 {\n    assert(this !== null);\n    if (<u32>pos >= <u32>this.length) {\n      return -1; // (undefined)\n    }\n    var first = <i32>load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) {\n      return first;\n    }\n    var second = <i32>load<u16>(\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\n      HEADER_SIZE\n    );\n    if (second < 0xDC00 || second > 0xDFFF) return first;\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator("+")\n  private static __concat(left: String, right: String): String {\n    if (!changetype<usize>(left)) left = changetype<String>("null");\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    assert(this !== null);\n    if (other === null) other = changetype<String>("null");\n    var thisLen: isize = this.length;\n    var otherLen: isize = other.length;\n    var outLen: usize = thisLen + otherLen;\n    if (outLen == 0) return EMPTY;\n    var out = allocate(outLen);\n\n    memory.copy(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE,\n      thisLen << 1\n    );\n\n    memory.copy(\n      changetype<usize>(out) + HEADER_SIZE + (thisLen << 1),\n      changetype<usize>(other) + HEADER_SIZE,\n      otherLen << 1\n    );\n\n    return out;\n  }\n\n  endsWith(searchString: String, endPosition: i32 = MAX_LENGTH): bool {\n    assert(this !== null);\n    if (searchString === null) return false;\n    var end = clamp<isize>(endPosition, 0, this.length);\n    var searchLength: isize = searchString.length;\n    var start: isize = end - searchLength;\n    if (start < 0) return false;\n    return !memory.compare(\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\n      changetype<usize>(searchString) + HEADER_SIZE,\n      searchLength << 1\n    );\n  }\n\n  @operator("==")\n  private static __eq(left: String, right: String): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n\n    return !memory.compare(\n      changetype<usize>(left) + HEADER_SIZE,\n      changetype<usize>(right) + HEADER_SIZE,\n      (<usize>leftLength << 1)\n    );\n  }\n\n  @operator("!=")\n  private static __ne(left: String, right: String): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(">")\n  private static __gt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!leftLength)  return false;\n    if (!rightLength) return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return memory.compare(\n      changetype<usize>(left)  + HEADER_SIZE,\n      changetype<usize>(right) + HEADER_SIZE,\n      length << 1\n    ) > 0;\n  }\n\n  @operator(">=")\n  private static __gte(left: String, right: String): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!leftLength)  return !rightLength;\n    if (!rightLength) return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return memory.compare(\n      changetype<usize>(left)  + HEADER_SIZE,\n      changetype<usize>(right) + HEADER_SIZE,\n      length << 1\n    ) >= 0;\n  }\n\n  @operator("<")\n  private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!rightLength) return false;\n    if (!leftLength)  return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return memory.compare(\n      changetype<usize>(left)  + HEADER_SIZE,\n      changetype<usize>(right) + HEADER_SIZE,\n      length << 1\n    ) < 0;\n  }\n\n  @operator("<=")\n  private static __lte(left: String, right: String): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!rightLength) return !leftLength;\n    if (!leftLength)  return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return memory.compare(\n      changetype<usize>(left)  + HEADER_SIZE,\n      changetype<usize>(right) + HEADER_SIZE,\n      length << 1\n    ) <= 0;\n  }\n\n  includes(searchString: String, position: i32 = 0): bool {\n    return this.indexOf(searchString, position) != -1;\n  }\n\n  indexOf(searchString: String, fromIndex: i32 = 0): i32 {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>("null");\n    var searchLen: isize = searchString.length;\n    if (!searchLen) return 0;\n    var len: isize = this.length;\n    if (!len) return -1;\n    var start = clamp<isize>(fromIndex, 0, len);\n    len -= searchLen;\n    // TODO: multiple char codes\n    for (let k: isize = start; k <= len; ++k) {\n      if (!memory.compare(\n        changetype<usize>(this) + HEADER_SIZE + (k << 1),\n        changetype<usize>(searchString) + HEADER_SIZE,\n        searchLen << 1\n      )) {\n        return <i32>k;\n      }\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchString: String, fromIndex: i32 = i32.MAX_VALUE): i32 {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>("null");\n    var len: isize = this.length;\n    var searchLen: isize = searchString.length;\n    if (!searchLen) return len;\n    if (!len) return -1;\n    var start = clamp<isize>(fromIndex, 0, len - searchLen);\n\n    // TODO: multiple char codes\n    for (let k = start; k >= 0; --k) {\n      if (!memory.compare(\n        changetype<usize>(this) + HEADER_SIZE + (k << 1),\n        changetype<usize>(searchString) + HEADER_SIZE,\n        searchLen << 1\n      )) {\n        return <i32>k;\n      }\n    }\n    return -1;\n  }\n\n  startsWith(searchString: String, position: i32 = 0): bool {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>("null");\n\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start = clamp<isize>(pos, 0, len);\n    var searchLength: isize = searchString.length;\n    if (searchLength + start > len) {\n      return false;\n    }\n    return !memory.compare(\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\n      changetype<usize>(searchString) + HEADER_SIZE,\n      searchLength << 1\n    );\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\n    assert(this !== null);\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0) {\n      intStart = max<isize>(size + intStart, 0);\n    }\n    var resultLength = clamp<isize>(end, 0, size - intStart);\n    if (resultLength <= 0) {\n      return EMPTY;\n    }\n    var out = allocate(resultLength);\n    memory.copy(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + (intStart << 1),\n      <usize>resultLength << 1\n    );\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    assert(this !== null);\n    var len = this.length;\n    var finalStart = clamp<isize>(start, 0, len);\n    var finalEnd = clamp<isize>(end, 0, len);\n    var from = min<i32>(finalStart, finalEnd);\n    var to = max<i32>(finalStart, finalEnd);\n    len = to - from;\n    if (!len) {\n      return EMPTY;\n    }\n    if (!from && to == this.length) {\n      return this;\n    }\n    var out = allocate(len);\n    memory.copy(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + (from << 1),\n      len << 1\n    );\n    return out;\n  }\n\n  trim(): String {\n    assert(this !== null);\n    var length: usize = this.length;\n\n    while (\n      length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (length << 1), HEADER_SIZE)\n      )\n    ) {\n      --length;\n    }\n    var start: usize = 0;\n    while (\n      start < length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start, --length;\n    }\n    if (!length) {\n      return EMPTY;\n    }\n    if (!start && length == this.length) {\n      return this;\n    }\n    var out = allocate(length);\n    memory.copy(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\n      length << 1\n    );\n    return out;\n  }\n\n  trimLeft(): String {\n    assert(this !== null);\n    var start: isize = 0;\n    var len: isize = this.length;\n    while (\n      start < len &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start;\n    }\n    if (!start) {\n      return this;\n    }\n    var outLen = len - start;\n    if (!outLen) {\n      return EMPTY;\n    }\n    var out = allocate(outLen);\n    memory.copy(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\n      outLen << 1\n    );\n    return out;\n  }\n\n  trimRight(): String {\n    assert(this !== null);\n    var len: isize = this.length;\n    while (\n      len > 0 &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (len << 1), HEADER_SIZE)\n      )\n    ) {\n      --len;\n    }\n    if (len <= 0) {\n      return EMPTY;\n    }\n    if (<i32>len == this.length) {\n      return this;\n    }\n    var out = allocate(len);\n    memory.copy(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE,\n      len << 1\n    );\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    assert(this !== null);\n    var length = this.length;\n\n    // Most browsers can\'t handle strings 1 << 28 chars or longer\n    if (count < 0 || length * count > (1 << 28)) {\n      throw new RangeError("Invalid count value");\n    }\n\n    if (count === 0 || !length) return EMPTY;\n    if (count === 1) return this;\n\n    var result = allocate(length * count);\n    var strLen = length << 1;\n\n    /*\n     * TODO possible improvments: reuse existing result for exponentially concats like:\n     * \'a\' + \'a\' => \'aa\' + \'aa\' => \'aaaa\' + \'aaaa\' etc\n     */\n    for (let offset = 0, len = strLen * count; offset < len; offset += strLen) {\n      memory.copy(\n        changetype<usize>(result) + HEADER_SIZE + offset,\n        changetype<usize>(this)   + HEADER_SIZE,\n        strLen\n      );\n    }\n\n    return result;\n  }\n\n  toString(): String {\n    return this;\n  }\n\n  get lengthUTF8(): i32 {\n    var len = 1; // null terminated\n    var pos: usize = 0;\n    var end = <usize>this.length;\n    while (pos < end) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\n      if (c < 128) {\n        len += 1; ++pos;\n      } else if (c < 2048) {\n        len += 2; ++pos;\n      } else {\n        if (\n          (c & 0xFC00) == 0xD800 && pos + 1 < end &&\n          (<u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE) & 0xFC00) == 0xDC00\n        ) {\n          len += 4; pos += 2;\n        } else {\n          len += 3; ++pos;\n        }\n      }\n    }\n    return len;\n  }\n\n  toUTF8(): usize {\n    var buf = memory.allocate(<usize>this.lengthUTF8);\n    var pos: usize = 0;\n    var end = <usize>this.length;\n    var off: usize = 0;\n    while (pos < end) {\n      let c1 = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\n      if (c1 < 128) {\n        store<u8>(buf + off, c1);\n        ++off; ++pos;\n      } else if (c1 < 2048) {\n        let ptr = buf + off;\n        store<u8>(ptr, c1 >> 6      | 192);\n        store<u8>(ptr, c1      & 63 | 128, 1);\n        off += 2; ++pos;\n      } else {\n        let ptr = buf + off;\n        if ((c1 & 0xFC00) == 0xD800 && pos + 1 < end) {\n          let c2 = <u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE);\n          if ((c2 & 0xFC00) == 0xDC00) {\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n            store<u8>(ptr, c1 >> 18      | 240);\n            store<u8>(ptr, c1 >> 12 & 63 | 128, 1);\n            store<u8>(ptr, c1 >> 6  & 63 | 128, 2);\n            store<u8>(ptr, c1       & 63 | 128, 3);\n            off += 4; pos += 2;\n            continue;\n          }\n        }\n        store<u8>(ptr, c1 >> 12      | 224);\n        store<u8>(ptr, c1 >> 6  & 63 | 128, 1);\n        store<u8>(ptr, c1       & 63 | 128, 2);\n        off += 3; ++pos;\n      }\n    }\n    store<u8>(buf + off, 0);\n    return buf;\n  }\n}\n\nexport function parseInt(str: String, radix: i32 = 0): f64 {\n  return parse<f64>(str, radix);\n}\n\nexport function parseI32(str: String, radix: i32 = 0): i32 {\n  return parse<i32>(str, radix);\n}\n\nexport function parseI64(str: String, radix: i32 = 0): i64 {\n  return parse<i64>(str, radix);\n}\n\n// FIXME: naive implementation\nexport function parseFloat(str: String): f64 {\n  var len: i32 = str.length;\n  if (!len) {\n    return NaN;\n  }\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: f64;\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      return NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      return NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // calculate value\n  var num: f64 = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      let fac: f64 = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr, HEADER_SIZE);\n        if (code == CharCode.E || code == CharCode.e) {\n          assert(false); // TODO\n        }\n        code -= CharCode._0;\n        if (<u32>code > 9) {\n          break;\n        }\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10) {\n      break;\n    }\n    num = (num * 10) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n',symbol:'import { Map } from "./map";\n\nvar stringToId: Map<string, usize>;\nvar idToString: Map<usize, string>;\nvar nextId: usize = 12; // Symbol.unscopables + 1\n\n@unmanaged export class symbol {}\n\ntype Symbol = symbol;\n\nexport function Symbol(description: string | null = null): symbol {\n  var id = nextId++;\n  if (!id) unreachable(); // out of ids\n  return changetype<symbol>(id);\n}\n\nexport namespace Symbol {\n\n  // well-known symbols\n  export const hasInstance      = changetype<symbol>(1);\n  export const concatSpreadable = changetype<symbol>(2);\n  export const isRegExp         = changetype<symbol>(3);\n  export const iterator         = changetype<symbol>(3);\n  export const match            = changetype<symbol>(4);\n  export const replace          = changetype<symbol>(5);\n  export const search           = changetype<symbol>(6);\n  export const species          = changetype<symbol>(7);\n  export const split            = changetype<symbol>(8);\n  export const toPrimitive      = changetype<symbol>(9);\n  export const toStringTag      = changetype<symbol>(10);\n  export const unscopables      = changetype<symbol>(11);\n\n  /* tslint:disable */// not valid TS\n  export function for(key: string): symbol {\n    if (!stringToId) { stringToId = new Map(); idToString = new Map(); }\n    else if (stringToId.has(key)) return changetype<symbol>(stringToId.get(key));\n    var id = nextId++;\n    if (!id) unreachable(); // out of ids\n    stringToId.set(key, id);\n    idToString.set(id, key);\n    return changetype<symbol>(id);\n  }\n  /* tslint:enable */\n\n  export function keyFor(sym: symbol): string | null {\n    return idToString !== null && idToString.has(changetype<usize>(sym))\n      ? idToString.get(changetype<usize>(sym))\n      : null;\n  }\n}\n',table:"export namespace table {\n\n  // export function copy(dst: u32, src: u32, n: u32): void {\n  //   __table_copy(dst, src, n);\n  // }\n\n  // Passive elements\n\n  // export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void {\n  //   __table_init(elementIndex, srcOffset, dstOffset, n);\n  // }\n\n  // export function drop(elementIndex: u32): void {\n  //   __table_drop(elementIndex);\n  // }\n}\n",typedarray:'import {\n  TypedArray\n} from "./internal/typedarray";\n\nexport class Int8Array extends TypedArray<i8,i32> {\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i8>();\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int8Array {\n    return changetype<Int8Array>(super.subarray(begin, end));\n  }\n}\n\nexport class Uint8Array extends TypedArray<u8,u32> {\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint8Array {\n    return changetype<Uint8Array>(super.subarray(begin, end));\n  }\n}\n\nexport class Uint8ClampedArray extends TypedArray<u8,u32> {\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  @operator("[]=")\n  protected __set(index: i32, value: i32): void {\n    super.__set(index, max(min(value, 255), 0));\n  }\n\n  @inline @operator("{}=")\n  protected __unchecked_set(index: i32, value: i32): void {\n    super.__unchecked_set(index, max(min(value, 255), 0));\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint8ClampedArray {\n    return changetype<Uint8ClampedArray>(super.subarray(begin, end));\n  }\n}\n\nexport class Int16Array extends TypedArray<i16,i32> {\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i16>();\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int16Array {\n    return changetype<Int16Array>(super.subarray(begin, end));\n  }\n}\n\nexport class Uint16Array extends TypedArray<u16,u32> {\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u16>();\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint16Array {\n    return changetype<Uint16Array>(super.subarray(begin, end));\n  }\n}\n\nexport class Int32Array extends TypedArray<i32,i32> {\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i32>();\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int32Array {\n    return changetype<Int32Array>(super.subarray(begin, end));\n  }\n}\n\nexport class Uint32Array extends TypedArray<u32,u32> {\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u32>();\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint32Array {\n    return changetype<Uint32Array>(super.subarray(begin, end));\n  }\n}\n\nexport class Int64Array extends TypedArray<i64,i64> {\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i64>();\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int64Array {\n    return changetype<Int64Array>(super.subarray(begin, end));\n  }\n}\n\nexport class Uint64Array extends TypedArray<u64,u64> {\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u64>();\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint64Array {\n    return changetype<Uint64Array>(super.subarray(begin, end));\n  }\n}\n\nexport class Float32Array extends TypedArray<f32,f32> {\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<f32>();\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float32Array {\n    return changetype<Float32Array>(super.subarray(begin, end));\n  }\n}\n\nexport class Float64Array extends TypedArray<f64,f64> {\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<f64>();\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float64Array {\n    return changetype<Float64Array>(super.subarray(begin, end));\n  }\n}\n'}):(()=>{const e=path.join(".","..","std","assembly"),n={};return __webpack_require__(!function(){var e=new Error("Cannot find module 'glob'");throw e.code="MODULE_NOT_FOUND",e}()).sync("**/!(*.d).ts",{cwd:e}).forEach(t=>n[t.replace(/\.ts$/,"")]=fs.readFileSync(path.join(e,t),"utf8")),n})(),exports.definitionFiles=exports.isBundle?Object({assembly:"/**\n * Environment definitions for compiling AssemblyScript to WebAssembly using asc.\n * @module std/assembly\n *//***/\n\n/// <reference no-default-lib=\"true\"/>\n\n// Types\n\n/** An 8-bit signed integer. */\ndeclare type i8 = number;\n/** A 16-bit signed integer. */\ndeclare type i16 = number;\n/** A 32-bit signed integer. */\ndeclare type i32 = number;\n/** A 64-bit signed integer. */\ndeclare type i64 = number;\n/** A 32-bit signed integer when targeting 32-bit WebAssembly or a 64-bit signed integer when targeting 64-bit WebAssembly. */\ndeclare type isize = number;\n/** An 8-bit unsigned integer. */\ndeclare type u8 = number;\n/** A 16-bit unsigned integer. */\ndeclare type u16 = number;\n/** A 32-bit unsigned integer. */\ndeclare type u32 = number;\n/** A 64-bit unsigned integer. */\ndeclare type u64 = number;\n/** A 32-bit unsigned integer when targeting 32-bit WebAssembly or a 64-bit unsigned integer when targeting 64-bit WebAssembly. */\ndeclare type usize = number;\n/** A 1-bit unsigned integer. */\ndeclare type bool = boolean | number;\n/** A 32-bit float. */\ndeclare type f32 = number;\n/** A 64-bit float. */\ndeclare type f64 = number;\n\n// Compiler hints\n\n/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */\ndeclare const ASC_TARGET: i32;\n/** Provided noTreeshaking option. */\ndeclare const ASC_NO_TREESHAKING: bool;\n/** Provided noAssert option. */\ndeclare const ASC_NO_ASSERT: bool;\n/** Provided memoryBase option. */\ndeclare const ASC_MEMORY_BASE: i32;\n/** Provided optimizeLevel option. */\ndeclare const ASC_OPTIMIZE_LEVEL: i32;\n/** Provided shrinkLevel option. */\ndeclare const ASC_SHRINK_LEVEL: i32;\n/** Whether the mutable global feature is enabled. */\ndeclare const ASC_FEATURE_MUTABLE_GLOBAL: bool;\n/** Whether the sign extension feature is enabled. */\ndeclare const ASC_FEATURE_SIGN_EXTENSION: bool;\n\n// Builtins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered trailing if the value is zero. */\ndeclare function ctz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit or 64-bit integer. */\ndeclare function popcnt<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic rotate left operation on a 32-bit or 64-bit integer. */\ndeclare function rotl<T = i32 | i64>(value: T, shift: T): T;\n/** Performs the sign-agnostic rotate right operation on a 32-bit or 64-bit integer. */\ndeclare function rotr<T = i32 | i64>(value: T, shift: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | i64 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\ndeclare function copysign<T = f32 | f64>(x: T, y: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\ndeclare function nearest<T = f32 | f64>(value: T): T;\n/** Reinterprets the bits of the specified value as type `T`. Valid reinterpretations are u32/i32 to/from f32 and u64/i64 to/from f64. */\ndeclare function reinterpret<T = i32 | i64 | f32 | f64>(value: number): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Loads a value of the specified type from memory. Equivalent to dereferncing a pointer in other languages. */\ndeclare function load<T>(ptr: usize, constantOffset?: usize): T;\n/** Stores a value of the specified type to memory. Equivalent to dereferencing a pointer in other languages when assigning a value. */\ndeclare function store<T>(ptr: usize, value: any, constantOffset?: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. Both a statement and an expression of any type. */\ndeclare function unreachable(): any; // sic\n\n/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */\ndeclare const NaN: f32 | f64;\n/** Positive infinity as a 32-bit or 64-bit float depending on context. */\ndeclare const Infinity: f32 | f64;\n/** Heap base offset. */\ndeclare const HEAP_BASE: usize;\n/** Determines the byte size of the specified underlying core type. Compiles to a constant. */\ndeclare function sizeof<T>(): usize;\n/** Determines the alignment (log2) of the specified underlying core type. Compiles to a constant. */\ndeclare function alignof<T>(): usize;\n/** Determines the offset of the specified field within the given class type. Returns the class type's end offset if field name has been omitted. Compiles to a constant. */\ndeclare function offsetof<T>(fieldName?: string): usize;\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */\ndeclare function unchecked<T>(value: T): T;\n/** Emits a `call_indirect` instruction, calling the specified function in the function table by index with the specified arguments. Does result in a runtime error if the arguments do not match the called function. */\ndeclare function call_indirect<T>(target: Function | u32, ...args: any[]): T;\n/** Tests if a 32-bit or 64-bit float is `NaN`. */\ndeclare function isNaN<T = f32 | f64>(value: T): bool;\n/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */\ndeclare function isFinite<T = f32 | f64>(value: T): bool;\n/** Tests if the specified type *or* expression is of an integer type and not a reference. Compiles to a constant. */\ndeclare function isInteger<T>(value?: any): value is number;\n/** Tests if the specified type *or* expression is of a float type. Compiles to a constant. */\ndeclare function isFloat<T>(value?: any): value is number;\n/** Tests if the specified type *or* expression can represent negative numbers. Compiles to a constant. */\ndeclare function isSigned<T>(value?: any): value is number;\n/** Tests if the specified type *or* expression is of a reference type. Compiles to a constant. */\ndeclare function isReference<T>(value?: any): value is object | string;\n/** Tests if the specified type *or* expression can be used as a string. Compiles to a constant. */\ndeclare function isString<T>(value?: any): value is string | String;\n/** Tests if the specified type *or* expression can be used as an array. Compiles to a constant. */\ndeclare function isArray<T>(value?: any): value is Array<any>;\n/** Tests if the specified expression resolves to a defined element. Compiles to a constant. */\ndeclare function isDefined(expression: any): bool;\n/** Tests if the specified expression evaluates to a constant value. Compiles to a constant. */\ndeclare function isConstant(expression: any): bool;\n/** Traps if the specified value is not true-ish, otherwise returns the (non-nullable) value. */\ndeclare function assert<T>(isTrueish: T, message?: string): T & object; // any better way to model `: T != null`?\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses an integer string to a 32-bit integer. */\ndeclare function parseI32(str: string, radix?: i32): i32;\n/** Parses an integer string to a 64-bit integer. */\ndeclare function parseI64(str: string, radix?: i32): i64;\n/** Parses a string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n/** Returns the 64-bit floating-point remainder of `x/y`. */\ndeclare function fmod(x: f64, y: f64): f64;\n/** Returns the 32-bit floating-point remainder of `x/y`. */\ndeclare function fmodf(x: f32, y: f32): f32;\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace i8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i8;\n  /** Largest representable value. */\n  export const MAX_VALUE: i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace i16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i16;\n  /** Largest representable value. */\n  export const MAX_VALUE: i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i32;\ndeclare namespace i32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i32;\n  /** Largest representable value. */\n  export const MAX_VALUE: i32;\n  /** Loads an 8-bit signed integer from memory and returns it as a 32-bit integer. */\n  export function load8_s(offset: usize, constantOffset?: usize): i32;\n  /** Loads an 8-bit unsigned integer from memory and returns it as a 32-bit integer. */\n  export function load8_u(offset: usize, constantOffset?: usize): i32;\n  /** Loads a 16-bit signed integer from memory and returns it as a 32-bit integer. */\n  export function load16_s(offset: usize, constantOffset?: usize): i32;\n  /** Loads a 16-bit unsigned integer from memory and returns it as a 32-bit integer. */\n  export function load16_u(offset: usize, constantOffset?: usize): i32;\n  /** Loads a 32-bit integer from memory. */\n  export function load(offset: usize, constantOffset?: usize): i32;\n  /** Stores a 32-bit integer to memory as an 8-bit integer. */\n  export function store8(offset: usize, value: i32, constantOffset?: usize): void;\n  /** Stores a 32-bit integer to memory as a 16-bit integer. */\n  export function store16(offset: usize, value: i32, constantOffset?: usize): void;\n  /** Stores a 32-bit integer to memory. */\n  export function store(offset: usize, value: i32, constantOffset?: usize): void;\n}\n/** Converts any other numeric value to a 64-bit signed integer. */\ndeclare function i64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i64;\ndeclare namespace i64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i64;\n  /** Largest representable value. */\n  export const MAX_VALUE: i64;\n  /** Loads an 8-bit signed integer from memory and returns it as a 64-bit signed integer. */\n  export function load8_s(offset: usize, constantOffset?: usize): i64;\n  /** Loads an 8-bit unsigned integer from memory and returns it as a 64-bit unsigned integer. */\n  export function load8_u(offset: usize, constantOffset?: usize): u64;\n  /** Loads a 16-bit signed integer from memory and returns it as a 64-bit signed integer. */\n  export function load16_s(offset: usize, constantOffset?: usize): i64;\n  /** Loads a 16-bit unsigned integer from memory and returns it as a 64-bit unsigned integer. */\n  export function load16_u(offset: usize, constantOffset?: usize): u64;\n  /** Loads a 32-bit signed integer from memory and returns it as a 64-bit signed integer. */\n  export function load32_s(offset: usize, constantOffset?: usize): i64;\n  /** Loads a 32-bit unsigned integer from memory and returns it as a 64-bit unsigned integer. */\n  export function load32_u(offset: usize, constantOffset?: usize): u64;\n  /** Loads a 64-bit unsigned integer from memory. */\n  export function load(offset: usize, constantOffset?: usize): i64;\n  /** Stores a 64-bit integer to memory as an 8-bit integer. */\n  export function store8(offset: usize, value: i64, constantOffset?: usize): void;\n  /** Stores a 64-bit integer to memory as a 16-bit integer. */\n  export function store16(offset: usize, value: i64, constantOffset?: usize): void;\n  /** Stores a 64-bit integer to memory as a 32-bit integer. */\n  export function store32(offset: usize, value: i64, constantOffset?: usize): void;\n  /** Stores a 64-bit integer to memory. */\n  export function store(offset: usize, value: i64, constantOffset?: usize): void;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare var isize: i32 | i64;\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace u8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u8;\n  /** Largest representable value. */\n  export const MAX_VALUE: u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace u16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u16;\n  /** Largest representable value. */\n  export const MAX_VALUE: u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i32;\ndeclare namespace u32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u32;\n  /** Largest representable value. */\n  export const MAX_VALUE: u32;\n}\n/** Converts any other numeric value to a 64-bit unsigned integer. */\ndeclare function u64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i64;\ndeclare namespace u64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u64;\n  /** Largest representable value. */\n  export const MAX_VALUE: u64;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare var usize: u32 | u64;\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): bool;\ndeclare namespace bool {\n  /** Smallest representable value. */\n  export const MIN_VALUE: bool;\n  /** Largest representable value. */\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): f32;\ndeclare namespace f32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f32;\n  /** Largest representable value. */\n  export const MAX_VALUE: f32;\n  /** Smallest normalized positive value. */\n  export const MIN_POSITIVE_VALUE: f32;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n  /** Returns the floating-point remainder of `x / y` (rounded towards zero). */\n  export function mod(x: f32, y: f32): f32;\n  /** Returns the floating-point remainder of `x / y` (rounded to nearest). */\n  export function rem(x: f32, y: f32): f32;\n  /** Loads a 32-bit float from memory. */\n  export function load(offset: usize, constantOffset?: usize): f32;\n  /** Stores a 32-bit float to memory. */\n  export function store(offset: usize, value: f32, constantOffset?: usize): void;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): f64;\ndeclare namespace f64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f64;\n  /** Largest representable value. */\n  export const MAX_VALUE: f64;\n  /** Smallest normalized positive value. */\n  export const MIN_POSITIVE_VALUE: f64;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n  /** Loads a 64-bit float from memory. */\n  export function load(offset: usize, constantOffset?: usize): f64;\n  /** Stores a 64-bit float to memory. */\n  export function store(offset: usize, value: f64, constantOffset?: usize): void;\n}\n\n// User-defined diagnostic macros\n\n/** Emits a user-defined diagnostic error when encountered. */\ndeclare function ERROR(message?: any): void;\n/** Emits a user-defined diagnostic warning when encountered. */\ndeclare function WARNING(message?: any): void;\n/** Emits a user-defined diagnostic info when encountered. */\ndeclare function INFO(message?: any): void;\n\n// Polyfills\n\n/** Performs the sign-agnostic reverse bytes **/\ndeclare function bswap<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | isize | usize>(value: T): T;\n/** Performs the sign-agnostic reverse bytes only for last 16-bit **/\ndeclare function bswap16<T = i8 | u8 | i16 | u16 | i32 | u32>(value: T): T;\n\n// Standard library\n\n/** Memory operations. */\ndeclare namespace memory {\n  /** Returns the current memory size in units of pages. One page is 64kb. */\n  export function size(): i32;\n  /** Grows linear memory by a given unsigned delta of pages. One page is 64kb. Returns the previous memory size in units of pages or `-1` on failure. */\n  export function grow(value: i32): i32;\n  /** Sets n bytes beginning at the specified destination in memory to the specified byte value. */\n  export function fill(dst: usize, value: u8, count: usize): void;\n  /** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\n  export function copy(dst: usize, src: usize, n: usize): void;\n  /** Copies elements from a passive element segment to a table. */\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void;\n  /** Prevents further use of a passive element segment. */\n  // export function drop(segmentIndex: u32): void;\n  /** Copies elements from one region of a table to another region. */\n  export function allocate(size: usize): usize;\n  /** Disposes a chunk of memory by its pointer. */\n  export function free(ptr: usize): void;\n  /** Compares two chunks of memory. Returns `0` if equal, otherwise the difference of the first differing bytes. */\n  export function compare(vl: usize, vr: usize, n: usize): i32;\n  /** Resets the allocator to its initial state, if supported. */\n  export function reset(): void;\n}\n\n/** Garbage collector operations. */\ndeclare namespace gc {\n  /** Allocates a managed object identified by its visitor function. */\n  export function allocate(size: usize, visitFn: (ref: usize) => void): usize;\n  /** Performs a full garbage collection cycle. */\n  export function collect(): void;\n  /** Must be called when a managed object becomes a child of another one. */\n  export function link(parentRef: usize, childRef: usize): void;\n  /** Must be called when a managed object is found reachable. */\n  export function mark(ref: usize): void;\n}\n\n/** Table operations. */\ndeclare namespace table {\n  /** Copies elements from a passive element segment to a table. */\n  // export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void;\n  /** Prevents further use of a passive element segment. */\n  // export function drop(elementIndex: u32): void;\n  /** Copies elements from one region of a table to another region. */\n  // export function copy(dest: u32, src: u32, n: u32): void;\n}\n\n/** Class representing a generic, fixed-length raw binary data buffer. */\ndeclare class ArrayBuffer {\n  /** The size, in bytes, of the array. */\n  readonly byteLength: i32;\n  /** Constructs a new array buffer of the given length in bytes. */\n  constructor(length: i32, unsafe?: bool);\n  /** Returns a copy of this array buffer's bytes from begin, inclusive, up to end, exclusive. */\n  slice(begin?: i32, end?: i32): ArrayBuffer;\n}\n\n/** Interface for a typed view on an array buffer. */\ninterface ArrayBufferView<T> {\n  [key: number]: T;\n  /** The {@link ArrayBuffer} referenced by this view. */\n  readonly buffer: ArrayBuffer;\n  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteOffset: i32;\n  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteLength: i32;\n}\n\n/* @internal */\ndeclare abstract class TypedArray<T> implements ArrayBufferView<T> {\n  [key: number]: T;\n  /** Number of bytes per element. */\n  static readonly BYTES_PER_ELEMENT: usize;\n  /** Constructs a new typed array. */\n  constructor(length: i32);\n  /** The {@link ArrayBuffer} referenced by this view. */\n  readonly buffer: ArrayBuffer;\n  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteOffset: i32;\n  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteLength: i32;\n  /** The length (in elements). */\n  readonly length: i32;\n  /** Returns a new TypedArray of this type on the same ArrayBuffer from begin inclusive to end exclusive. */\n  subarray(begin?: i32, end?: i32): this;\n}\n\n/** An array of twos-complement 8-bit signed integers. */\ndeclare class Int8Array extends TypedArray<i8> {}\n/** An array of 8-bit unsigned integers. */\ndeclare class Uint8Array extends TypedArray<u8> {}\n/** An array of twos-complement 16-bit signed integers. */\ndeclare class Int16Array extends TypedArray<i16> {}\n/** An array of 16-bit unsigned integers. */\ndeclare class Uint16Array extends TypedArray<u16> {}\n/** An array of twos-complement 32-bit signed integers. */\ndeclare class Int32Array extends TypedArray<i32> {}\n/** An array of 32-bit unsigned integers. */\ndeclare class Uint32Array extends TypedArray<u32> {}\n/** An array of twos-complement 64-bit signed integers. */\ndeclare class Int64Array extends TypedArray<i64> {}\n/** An array of 64-bit unsigned integers. */\ndeclare class Uint64Array extends TypedArray<u64> {}\n/** An array of 32-bit floating point numbers. */\ndeclare class Float32Array extends TypedArray<f32> {}\n/** An array of 64-bit floating point numbers. */\ndeclare class Float64Array extends TypedArray<f64> {}\n\n/** Class representing a sequence of values of type `T`. */\ndeclare class Array<T> {\n  [key: number]: T;\n  /** Current length of the array. */\n  length: i32;\n  /** Constructs a new array. */\n  constructor(capacity?: i32);\n  every(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool;\n  findIndex(predicate: (element: T, index: i32, array?: Array<T>) => bool): i32;\n  includes(searchElement: T, fromIndex?: i32): bool;\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): void;\n  pop(): T;\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void;\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U>;\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T>;\n  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\n  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\n  shift(): T;\n  some(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool;\n  unshift(element: T): i32;\n  slice(from: i32, to?: i32): T[];\n  splice(start: i32, deleteCount?: i32): void;\n  reverse(): T[];\n  sort(comparator?: (a: T, b: T) => i32): this;\n}\n\n/** Class representing a C-like array of values of type `T` with limited capabilities. */\ndeclare class CArray<T> {\n  [key: number]: T;\n  private constructor();\n}\n\n/** Class representing a sequence of characters. */\ndeclare class String {\n\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(cp: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n\n  readonly length: i32;\n  readonly lengthUTF8: i32;\n\n  charAt(index: u32): string;\n  charCodeAt(index: u32): u16;\n  concat(other: string): string;\n  endsWith(other: string): bool;\n  indexOf(other: string, fromIndex?: i32): u32;\n  lastIndexOf(other: string, fromIndex?: i32): i32;\n  includes(other: string): bool;\n  startsWith(other: string): bool;\n  substr(start: u32, length?: u32): string;\n  substring(start: u32, end?: u32): string;\n  trim(): string;\n  trimLeft(): string;\n  trimRight(): string;\n  repeat(count?: i32): string;\n  toString(): string;\n  toUTF8(): usize;\n}\n\n/** Class for representing a runtime error. Base class of all errors. */\ndeclare class Error {\n\n  /** Error name. */\n  name: string;\n\n  /** Message provided on construction. */\n  message: string;\n\n  /** Stack trace. */\n  stack: string;\n\n  /** Constructs a new error, optionally with a message. */\n  constructor(message?: string);\n}\n\n/** Class for indicating an error when a value is not in the set or range of allowed values. */\ndeclare class RangeError extends Error { }\n\ninterface Boolean {}\ninterface Function {}\ninterface IArguments {}\ninterface Number {}\ninterface Object {}\ninterface RegExp {}\n\ndeclare class Map<K,V> {\n  readonly size: i32;\n  has(key: K): bool;\n  set(key: K, value: V): void;\n  delete(key: K): bool;\n  clear(): void;\n}\n\ndeclare class Set<T> {\n  readonly size: i32;\n  has(value: T): bool;\n  add(value: T): void;\n  delete(value: T): bool;\n  clear(): void;\n}\n\ninterface SymbolConstructor {\n  (description?: string | null): symbol;\n  for(key: string): symbol;\n  keyFor(sym: symbol): string | null;\n}\ndeclare const Symbol: SymbolConstructor;\n\ninterface IMath<T> {\n  /** The base of natural logarithms, e, approximately 2.718. */\n  readonly E: T;\n  /** The natural logarithm of 2, approximately 0.693. */\n  readonly LN2: T;\n  /** The natural logarithm of 10, approximately 2.302. */\n  readonly LN10: T;\n  /** The base 2 logarithm of e, approximately 1.442. */\n  readonly LOG2E: T;\n  /** The base 10 logarithm of e, approximately 0.434. */\n  readonly LOG10E: T;\n  /** The ratio of the circumference of a circle to its diameter, approximately 3.14159. */\n  readonly PI: T;\n  /** The square root of 1/2, approximately 0.707. */\n  readonly SQRT1_2: T;\n  /** The square root of 2, approximately 1.414. */\n  readonly SQRT2: T;\n  /** Returns the absolute value of `x`. */\n  abs(x: T): T;\n  /** Returns the arccosine (in radians) of `x`. */\n  acos(x: T): T;\n  /** Returns the hyperbolic arc-cosine of `x`. */\n  acosh(x: T): T;\n  /** Returns the arcsine (in radians) of `x` */\n  asin(x: T): T;\n  /** Returns the hyperbolic arcsine of `x`. */\n  asinh(x: T): T;\n  /** Returns the arctangent (in radians) of `x`. */\n  atan(x: T): T;\n  /** Returns the arctangent of the quotient of its arguments. */\n  atan2(y: T, x: T): T;\n  /** Returns the hyperbolic arctangent of `x`. */\n  atanh(x: T): T;\n  /** Returns the cube root of `x`. */\n  cbrt(x: T): T;\n  /** Returns the smallest integer greater than or equal to `x`. */\n  ceil(x: T): T;\n  /** Returns the number of leading zero bits in the 32-bit binary representation of `x`. */\n  clz32(x: T): T;\n  /** Returns the cosine (in radians) of `x`. */\n  cos(x: T): T;\n  /** Returns the hyperbolic cosine of `x`. */\n  cosh(x: T): T;\n  /** Returns e to the power of `x`. */\n  exp(x: T): T;\n  /** Returns e to the power of `x`, minus 1. */\n  expm1(x: T): T;\n  /** Returns the largest integer less than or equal to `x`. */\n  floor(x: T): T;\n  /** Returns the nearest 32-bit single precision float representation of `x`. */\n  fround(x: T): f32;\n  /** Returns the square root of the sum of squares of its arguments. */\n  hypot(value1: T, value2: T): T; // TODO: rest\n  /** Returns the result of the C-like 32-bit multiplication of `a` and `b`. */\n  imul(a: T, b: T): T;\n  /** Returns the natural logarithm (base e) of `x`. */\n  log(x: T): T;\n  /** Returns the base 10 logarithm of `x`. */\n  log10(x: T): T;\n  /** Returns the natural logarithm (base e) of 1 + `x`. */\n  log1p(x: T): T;\n  /** Returns the base 2 logarithm of `x`. */\n  log2(x: T): T;\n  /** Returns the largest-valued number of its arguments. */\n  max(value1: T, value2: T): T; // TODO: rest\n  /** Returns the lowest-valued number of its arguments. */\n  min(value1: T, value2: T): T; // TODO: rest\n  /** Returns `base` to the power of `exponent`. */\n  pow(base: T, exponent: T): T;\n  /** Returns a pseudo-random number in the range from 0.0 inclusive up to but not including 1.0. */\n  random(): T;\n  /** Returns the value of `x` rounded to the nearest integer. */\n  round(x: T): T;\n  /** Returns the sign of `x`, indicating whether the number is positive, negative or zero. */\n  sign(x: T): T;\n  /** Returns the sine of `x`. */\n  sin(x: T): T;\n  /** Returns the hyperbolic sine of `x`. */\n  sinh(x: T): T;\n  /** Returns the square root of `x`. */\n  sqrt(x: T): T;\n  /** Returns the tangent of `x`. */\n  tan(x: T): T;\n  /** Returns the hyperbolic tangent of `x`. */\n  tanh(x: T): T;\n  /** Returns the integer part of `x` by removing any fractional digits. */\n  trunc(x: T): T;\n}\n\ninterface INativeMath<T> extends IMath<T> {\n  /** Seeds the random number generator. */\n  seedRandom(value: i64): void;\n  /** Returns the floating-point remainder of `x / y` (rounded towards zero). */\n  mod(x: T, y: T): T;\n  /** Returns the floating-point remainder of `x / y` (rounded to nearest). */\n  rem(x: T, y: T): T;\n}\n\n/** Double precision math imported from JavaScript. */\ndeclare const JSMath: IMath<f64>;\n/** Double precision math implemented natively. */\ndeclare const NativeMath: INativeMath<f64>;\n/** Single precision math implemented natively. */\ndeclare const NativeMathf: INativeMath<f32>;\n/** Alias of {@link NativeMath} or {@link JSMath} respectively. Defaults to `NativeMath`. */\ndeclare const Math: IMath<f64>;\n/** Alias of {@link NativeMathf} or {@link JSMath} respectively. Defaults to `NativeMathf`. */\ndeclare const Mathf: IMath<f32>;\n\n/** Environmental tracing function for debugging purposes. */\ndeclare function trace(msg: string, n?: i32, a0?: f64, a1?: f64, a2?: f64, a3?: f64, a4?: f64): void;\n\n// Decorators\n\n/** Annotates an element as a program global. */\ndeclare function global(target: Function, propertyKey: string, descriptor: any): void;\n\n/** Annotates a method as a binary operator overload for the specified `token`. */\ndeclare function operator(token: string): (target: any, propertyKey: string, descriptor: any) => void;\ndeclare namespace operator {\n  /** Annotates a method as a binary operator overload for the specified `token`. */\n  export function binary(token: string): (target: any, propertyKey: string, descriptor: any) => void;\n  /** Annotates a method as an unary prefix operator overload for the specified `token`. */\n  export function prefix(token: string): (target: any, propertyKey: string, descriptor: any) => void;\n  /** Annotates a method as an unary postfix operator overload for the specified `token`. */\n  export function postfix(token: string): (target: any, propertyKey: string, descriptor: any) => void;\n}\n\n/** Annotates a class as being unmanaged with limited capabilities. */\ndeclare function unmanaged(target: Function): any;\n\n/** Annotates a class as being sealed / non-derivable. */\ndeclare function sealed(target: Function): any;\n\n/** Annotates a method or function as always inlined. */\ndeclare function inline(target: any, propertyKey: any, descriptor: any): any;\n\n/** Annotates an explicit external name of a function or global. */\ndeclare function external(target: any, propertyKey: any, descriptor: any): any;\n",portable:"/**\n * Environment definitions for compiling AssemblyScript to JavaScript using tsc.\n *\n * Note that semantic differences require additional explicit conversions for full compatibility.\n * For example, when casting an i32 to an u8, doing `<u8>(someI32 & 0xff)` will yield the same\n * result when compiling to WebAssembly or JS while `<u8>someI32` alone does nothing in JS.\n *\n * Note that i64's are not portable (JS numbers are IEEE754 doubles with a maximum safe integer\n * value of 2^53-1) and instead require a compatibility layer to work in JS as well, as for example\n * {@link glue/js/i64} respectively {@link glue/wasm/i64}.\n *\n * @module std/portable\n *//***/\n\n/// <reference no-default-lib=\"true\"/>\n\n// Types\n\ndeclare type i8 = number;\ndeclare type i16 = number;\ndeclare type i32 = number;\ndeclare type isize = number;\ndeclare type u8 = number;\ndeclare type u16 = number;\ndeclare type u32 = number;\ndeclare type bool = boolean;\ndeclare type usize = number;\ndeclare type f32 = number;\ndeclare type f64 = number;\n\n// Compiler hints\n\n/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */\ndeclare const ASC_TARGET: i32;\n\n// Builtins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32>(value: T): T;\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */\ndeclare function ctz<T = i32>(value: T): T;\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */\ndeclare function popcnt<T = i32>(value: T): T;\n/** Performs the sign-agnostic rotate left operation on a 32-bit integer. */\ndeclare function rotl<T = i32>(value: T, shift: T): T;\n/** Performs the sign-agnostic rotate right operation on a 32-bit integer. */\ndeclare function rotr<T = i32>(value: T, shift: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\ndeclare function copysign<T = f32 | f64>(x: T, y: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\ndeclare function nearest<T = f32 | f64>(value: T): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Loads a value of the specified type from memory. Type must be `u8`. */\ndeclare function load<T = u8>(ptr: usize, constantOffset?: usize): T;\n/** Stores a value of the specified type to memory. Type must be `u8`. */\ndeclare function store<T = u8>(ptr: usize, value: T, constantOffset?: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. */\ndeclare function unreachable(): any; // sic\n\n/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */\ndeclare const NaN: f32 | f64;\n/** Positive infinity as a 32-bit or 64-bit float depending on context. */\ndeclare const Infinity: f32 | f64;\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */\ndeclare function unchecked<T>(value: T): T;\n/** Tests if a 32-bit or 64-bit float is `NaN`. */\ndeclare function isNaN<T = f32 | f64>(value: T): bool;\n/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */\ndeclare function isFinite<T = f32 | f64>(value: T): bool;\n/** Tests if the specified value is a valid integer. Can't distinguish an integer from an integral float. */\ndeclare function isInteger(value: any): value is number;\n/** Tests if the specified value is a valid float. Can't distinguish a float from an integer. */\ndeclare function isFloat(value: any): value is number;\n/** Tests if the specified value is of a reference type. */\ndeclare function isReference(value: any): value is object | string;\n/** Tests if the specified value can be used as a string. */\ndeclare function isString(value: any): value is string | String;\n/** Tests if the specified value can be used as an array. */\ndeclare function isArray(value: any): value is Array<any>;\n/** Traps if the specified value is not true-ish, otherwise returns the value. */\ndeclare function assert<T>(isTrueish: T | null, message?: string): T;\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses an integer string to a 32-bit integer. */\ndeclare function parseI32(str: string, radix?: i32): i32;\n/** Parses a floating point string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n/** Returns the 64-bit floating-point remainder of `x/y`. */\ndeclare function fmod(x: f64, y: f64): f64;\n/** Returns the 32-bit floating-point remainder of `x/y`. */\ndeclare function fmodf(x: f32, y: f32): f32;\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace i8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i8;\n  /** Largest representable value. */\n  export const MAX_VALUE: i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace i16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i16;\n  /** Largest representable value. */\n  export const MAX_VALUE: i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i32;\ndeclare namespace i32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i32;\n  /** Largest representable value. */\n  export const MAX_VALUE: i32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare function isize(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): isize;\ndeclare namespace isize {\n  /** Smallest representable value. */\n  export const MIN_VALUE: isize;\n  /** Largest representable value. */\n  export const MAX_VALUE: isize;\n}\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace u8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u8;\n  /** Largest representable value. */\n  export const MAX_VALUE: u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace u16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u16;\n  /** Largest representable value. */\n  export const MAX_VALUE: u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i32;\ndeclare namespace u32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u32;\n  /** Largest representable value. */\n  export const MAX_VALUE: u32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare function usize(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): isize;\ndeclare namespace usize {\n  /** Smallest representable value. */\n  export const MIN_VALUE: usize;\n  /** Largest representable value. */\n  export const MAX_VALUE: usize;\n}\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): bool;\ndeclare namespace bool {\n  /** Smallest representable value. */\n  export const MIN_VALUE: bool;\n  /** Largest representable value. */\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): f32;\ndeclare namespace f32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f32;\n  /** Largest representable value. */\n  export const MAX_VALUE: f32;\n  /** Smallest normalized positive value. */\n  export const MIN_POSITIVE_VALUE: f32;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): f64;\ndeclare namespace f64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f64;\n  /** Largest representable value. */\n  export const MAX_VALUE: f64;\n  /** Smallest normalized positive value. */\n  export const MIN_POSITIVE_VALUE: f64;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n}\n\n// Polyfills\n\n/** [Polyfill] Performs the sign-agnostic reverse bytes **/\ndeclare function bswap<T = i32 | u32 | isize | usize>(value: T): T;\n/** [Polyfill] Performs the sign-agnostic reverse bytes only for last 16-bit **/\ndeclare function bswap16<T = i16 | u16 | i32 | u32>(value: T): T;\n\n// Standard library\n\n/** Memory operations. */\ndeclare namespace memory {\n  /** Allocates a chunk of memory of the specified size and returns a pointer to it. */\n  function allocate(size: usize): usize;\n  /** Disposes a chunk of memory by its pointer. */\n  function free(ptr: usize): void;\n  /** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\n  function copy(dst: usize, src: usize, n: usize): void;\n  /** Resets the allocator to its initial state, if supported. */\n  function reset(): void;\n}\n\n/** Class representing a generic, fixed-length raw binary data buffer. */\ndeclare class ArrayBuffer {\n  /** The size, in bytes, of the array. */\n  readonly byteLength: i32;\n  /** Constructs a new array buffer of the given length in bytes. */\n  constructor(length: i32);\n  /** Returns a copy of this array buffer's bytes from begin, inclusive, up to end, exclusive. */\n  slice(begin?: i32, end?: i32): ArrayBuffer;\n}\n\ndeclare class Array<T> {\n  [key: number]: T;\n  length: i32;\n  constructor(capacity?: i32);\n  every(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool;\n  findIndex(predicate: (element: T, index: i32, array?: Array<T>) => bool): i32;\n  includes(searchElement: T, fromIndex?: i32): bool;\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): void;\n  pop(): T;\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void;\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U>;\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T>;\n  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\n  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\n  shift(): T;\n  some(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool;\n  unshift(element: T): i32;\n  slice(from?: i32, to?: i32): T[];\n  splice(start: i32, deleteCount?: i32): void;\n  reverse(): T[];\n  sort(comparator?: (a: T, b: T) => i32): this;\n\n  join(delim: string): string;\n}\n\ndeclare class Uint8Array extends Array<u8> {}\ndeclare class Uint16Array extends Array<u16> {}\ndeclare class Uint32Array extends Array<u32> {}\ndeclare class Int8Array extends Array<i8> {}\ndeclare class Int16Array extends Array<i16> {}\ndeclare class Int32Array extends Array<i32> {}\ndeclare class Float32Array extends Array<f32> {}\ndeclare class Float64Array extends Array<f64> {}\n\ndeclare class String {\n\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(cp: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n\n  readonly length: i32;\n\n  private constructor();\n\n  indexOf(other: string, fromIndex?: i32): i32;\n  lastIndexOf(other: string, fromIndex?: i32): i32;\n  includes(other: string): bool;\n  charAt(index: i32): string;\n  charCodeAt(index: i32): i32;\n  substring(from: i32, to?: i32): string;\n  startsWith(other: string): bool;\n  endsWith(other: string): bool;\n  replace(search: string, replacement: string): string;\n  repeat(count?: i32): string;\n  toString(): string;\n}\n\ninterface Boolean {}\n\ndeclare class Number {\n  private constructor();\n  toString(radix?: i32): string;\n}\n\ninterface Object {}\n\ninterface Function {}\n\ninterface RegExp {}\n\ninterface IArguments {}\n\ndeclare class Error {\n  constructor(message: string);\n  message: string;\n  stack: string | null;\n}\n\ndeclare class Set<T> {\n  constructor(entries?: T[]);\n  readonly size: i32;\n  has(value: T): bool;\n  add(value: T): void;\n  delete(value: T): bool;\n  clear(): void;\n  [Symbol.iterator](): Iterator<T>;\n}\n\ndeclare class Map<K,V> {\n  constructor(entries?: [K, V][]);\n  readonly size: i32;\n  set(key: K, value: V): void;\n  has(key: K): bool;\n  get(key: K): V | null;\n  clear(): void;\n  entries(): Iterable<[K, V]>;\n  keys(): Iterable<K>;\n  values(): Iterable<V>;\n  [Symbol.iterator](): Iterator<[K,V]>;\n}\n\ninterface SymbolConstructor {\n  (description?: string | null): symbol;\n  for(key: string): symbol;\n  keyFor(sym: symbol): string | null;\n  readonly iterator: symbol;\n}\ndeclare const Symbol: SymbolConstructor;\n\ninterface Iterable<T> {\n  [Symbol.iterator](): Iterator<T>;\n}\n\ninterface Iterator<T> {}\n\ninterface IMath {\n  readonly E: f64;\n  readonly LN2: f64;\n  readonly LN10: f64;\n  readonly LOG2E: f64;\n  readonly LOG10E: f64;\n  readonly PI: f64;\n  readonly SQRT1_2: f64;\n  readonly SQRT2: f64;\n  abs(x: f64): f64;\n  acos(x: f64): f64;\n  acosh(x: f64): f64;\n  asin(x: f64): f64;\n  asinh(x: f64): f64;\n  atan(x: f64): f64;\n  atan2(y: f64, x: f64): f64;\n  atanh(x: f64): f64;\n  cbrt(x: f64): f64;\n  ceil(x: f64): f64;\n  clz32(x: f64): i32;\n  cos(x: f64): f64;\n  cosh(x: f64): f64;\n  exp(x: f64): f64;\n  expm1(x: f64): f64;\n  floor(x: f64): f64;\n  fround(x: f64): f32;\n  hypot(value1: f64, value2: f64): f64; // TODO: see std/math\n  imul(a: f64, b: f64): i32;\n  log(x: f64): f64;\n  log10(x: f64): f64;\n  log1p(x: f64): f64;\n  log2(x: f64): f64;\n  max(value1: f64, value2: f64): f64; // TODO: see std/math\n  min(value1: f64, value2: f64): f64; // TODO: see std/math\n  pow(base: f64, exponent: f64): f64;\n  random(): f64;\n  round(x: f64): f64;\n  sign(x: f64): f64;\n  sin(x: f64): f64;\n  sinh(x: f64): f64;\n  sqrt(x: f64): f64;\n  tan(x: f64): f64;\n  tanh(x: f64): f64;\n  trunc(x: f64): f64;\n}\n\ndeclare const Math: IMath;\ndeclare const Mathf: IMath;\ndeclare const JSMath: IMath;\n\ndeclare namespace console {\n  /** @deprecated */\n  function log(message: string): void;\n}\n"}):(()=>{const e=path.join(".","..","std");return{assembly:fs.readFileSync(path.join(e,"assembly","index.d.ts"),"utf8"),portable:fs.readFileSync(path.join(e,"portable","index.d.ts"),"utf8")}})(),exports.compileString=((e,n)=>{"string"==typeof e&&(e={"input.ts":e});const t=Object.create({stdout:createMemoryStream(),stderr:createMemoryStream(),binary:null,text:null});var r=["--binaryFile","binary","--textFile","text"];return Object.keys(n||{}).forEach(e=>{var t=n[e];Array.isArray(t)?t.forEach(n=>r.push("--"+e,String(n))):r.push("--"+e,String(t))}),exports.main(r.concat(Object.keys(e)),{stdout:t.stdout,stderr:t.stderr,readFile:n=>e.hasOwnProperty(n)?e[n]:null,writeFile:(e,n)=>t[e]=n,listFiles:()=>[]}),t}),exports.main=function(e,n,t){"function"==typeof n?(t=n,n={}):n||(n={});const r=n.stdout||process.stdout,i=n.stderr||process.stderr,s=n.readFile||T,a=n.writeFile||z,o=n.listFiles||A,l=n.stats||createStats();if(!r)throw Error("'options.stdout' must be specified");if(!i)throw Error("'options.stderr' must be specified");const f=optionsUtil.parse(e,exports.options),u=f.options;if(e=f.arguments,u.noColors?colorsUtil.stdout.supported=colorsUtil.stderr.supported=!1:(colorsUtil.stdout=colorsUtil.from(r),colorsUtil.stderr=colorsUtil.from(i)),f.unknown.length&&f.unknown.forEach(e=>{i.write(colorsUtil.stderr.yellow("WARN: ")+"Unknown option '"+e+"'"+EOL)}),f.trailing.length&&i.write(colorsUtil.stderr.yellow("WARN: ")+"Unsupported trailing arguments: "+f.trailing.join(" ")+EOL),t||(t=function(e){var n=0;return e&&(i.write(colorsUtil.stderr.red("ERROR: ")+e.stack.replace(/^ERROR: /i,"")+EOL),n=1),n}),u.version)return r.write("Version "+exports.version+(isDev?"-dev":"")+EOL),t(null);if(u.help||!e.length){var c=u.help?r:i,p=u.help?colorsUtil.stdout:colorsUtil.stderr;return c.write([p.white("SYNTAX"),"  "+p.cyan("asc")+" [entryFile ...] [options]","",p.white("EXAMPLES"),"  "+p.cyan("asc")+" hello.ts","  "+p.cyan("asc")+" hello.ts -b hello.wasm -t hello.wat","  "+p.cyan("asc")+" hello1.ts hello2.ts -b -O > hello.wasm","",p.white("OPTIONS")].concat(optionsUtil.help(exports.options,24,EOL)).join(EOL)+EOL),t(null)}if(!fs.readFileSync){if(s===T)throw Error("'options.readFile' must be specified");if(a===z)throw Error("'options.writeFile' must be specified");if(o===A)throw Error("'options.listFiles' must be specified")}const x=u.baseDir?path.resolve(u.baseDir):".",h=[];u.transform&&u.transform.forEach(e=>h.push(__webpack_require__(4)(path.isAbsolute(e=e.trim())?e:path.join(process.cwd(),e))));var d=null;u.noLib||Object.keys(exports.libraryFiles).forEach(e=>{e.indexOf("/")>=0||(l.parseCount++,l.parseTime+=measure(()=>{d=assemblyscript.parseFile(exports.libraryFiles[e],exports.libraryPrefix+e+".ts",!1,d)}))});const b=[];if(u.lib){let e=u.lib;"string"==typeof e&&(e=e.split(",")),Array.prototype.push.apply(b,e.map(e=>e.trim()));for(let e=0,n=b.length;e<n;++e){let n,r=b[e];r.endsWith(".ts")?(n=[path.basename(r)],r=path.dirname(r)):n=o(r);for(let e=0,i=n.length;e<i;++e){let i=n[e],a=s(path.join(r,i));if(null===a)return t(Error("Library file '"+i+"' not found."));l.parseCount++,l.parseTime+=measure(()=>{d=assemblyscript.parseFile(a,exports.libraryPrefix+i,!1,d)})}}}for(let n=0,r=e.length;n<r;++n){const r=e[n];let a=String(r).replace(/\\/g,"/").replace(/(\.ts|\/)$/,""),o=s(path.join(x,a)+".ts");if(null===o){if(null===(o=s(path.join(x,a,"index.ts"))))return t(Error("Entry file '"+a+".ts' not found."));a+="/index.ts"}else a+=".ts";for(l.parseCount++,l.parseTime+=measure(()=>{d=assemblyscript.parseFile(o,a,!0,d)});null!=(a=d.nextFile());){if(a.startsWith(exports.libraryPrefix)){const e=a.substring(exports.libraryPrefix.length),n=a.substring(exports.libraryPrefix.length)+"/index";if(exports.libraryFiles.hasOwnProperty(e))o=exports.libraryFiles[e],a=exports.libraryPrefix+e+".ts";else if(exports.libraryFiles.hasOwnProperty(n))o=exports.libraryFiles[n],a=exports.libraryPrefix+n+".ts";else for(let t=0,r=b.length;t<r;++t){const r=b[t];if(null!==(o=s(path.join(r,e+".ts")))){a=exports.libraryPrefix+e+".ts";break}if(null!==(o=s(path.join(r,n+".ts")))){a=exports.libraryPrefix+n+".ts";break}}}else{const e=a,n=a+"/index";if(null!==(o=s(path.join(x,e+".ts"))))a=e+".ts";else if(null!==(o=s(path.join(x,n+".ts"))))a=n+".ts";else if(!e.startsWith("."))if(exports.libraryFiles.hasOwnProperty(e))o=exports.libraryFiles[e],a=exports.libraryPrefix+e+".ts";else if(exports.libraryFiles.hasOwnProperty(n))o=exports.libraryFiles[n],a=exports.libraryPrefix+n+".ts";else for(let t=0,r=b.length;t<r;++t){const r=b[t];if(null!==(o=s(path.join(r,e+".ts")))){a=exports.libraryPrefix+e+".ts";break}if(null!==(o=s(path.join(r,n+".ts")))){a=exports.libraryPrefix+n+".ts";break}}}if(null==o)return t(Error("Import file '"+a+".ts' not found."));l.parseCount++,l.parseTime+=measure(()=>{assemblyscript.parseFile(o,a,!1,d)})}if(checkDiagnostics(d,i))return t(Error("Parse error"))}!function(e,...n){h.forEach(t=>{"function"==typeof t[e]&&t[e](...n)})}("afterParse",d);const g=assemblyscript.finishParsing(d);var y=0,m=0;u.optimize&&(y=exports.defaultOptimizeLevel,m=exports.defaultShrinkLevel),"number"==typeof u.optimizeLevel&&(y=u.optimizeLevel),"number"==typeof u.shrinkLevel&&(m=u.shrinkLevel),y=Math.min(Math.max(y,0),3),m=Math.min(Math.max(m,0),2);const v=assemblyscript.createOptions();if(assemblyscript.setTarget(v,0),assemblyscript.setNoTreeShaking(v,u.noTreeShaking),assemblyscript.setNoAssert(v,u.noAssert),assemblyscript.setImportMemory(v,u.importMemory),assemblyscript.setImportTable(v,u.importTable),assemblyscript.setMemoryBase(v,u.memoryBase>>>0),assemblyscript.setSourceMap(v,null!=u.sourceMap),assemblyscript.setOptimizeLevelHints(v,y,m),assemblyscript.setGlobalAlias(v,"Math","NativeMath"),assemblyscript.setGlobalAlias(v,"Mathf","NativeMathf"),assemblyscript.setGlobalAlias(v,"abort","~lib/env/abort"),assemblyscript.setGlobalAlias(v,"trace","~lib/env/trace"),u.use){let e=u.use;for(let n=0,r=e.length;n<r;++n){let r=e[n],i=r.indexOf("=");if(i<0)return t(Error("Global alias '"+r+"' is invalid."));let s=r.substring(0,i).trim(),a=r.substring(i+1).trim();if(!s.length)return t(Error("Global alias '"+r+"' is invalid."));assemblyscript.setGlobalAlias(v,s,a)}}var F,_=u.enable;if(null!=_){"string"==typeof _&&(_=_.split(","));for(let e=0,n=_.length;e<n;++e){let n=_[e].trim(),r=assemblyscript["FEATURE_"+n.replace(/\-/g,"_").toUpperCase()];if(!r)return t(Error("Feature '"+n+"' is unknown."));assemblyscript.enableFeature(v,r)}}if(l.compileCount++,(()=>{try{l.compileTime+=measure(()=>{F=assemblyscript.compileProgram(g,v)})}catch(e){return t(e)}})(),checkDiagnostics(d,i))return F&&F.dispose(),t(Error("Compile error"));if(u.validate&&(l.validateCount++,l.validateTime+=measure(()=>{if(!F.validate())return F.dispose(),t(Error("Validate error"))})),"clamp"===u.trapMode)l.optimizeCount++,l.optimizeTime+=measure(()=>{F.runPasses(["trap-mode-clamp"])});else if("js"===u.trapMode)l.optimizeCount++,l.optimizeTime+=measure(()=>{F.runPasses(["trap-mode-js"])});else if("allow"!==u.trapMode)return F.dispose(),t(Error("Unsupported trap mode"));(y>=3||m>=2)&&(y=4),F.setOptimizeLevel(y),F.setShrinkLevel(m),F.setDebugInfo(!u.noDebug);var E=[];if(u.runPasses&&("string"==typeof u.runPasses&&(u.runPasses=u.runPasses.split(",")),u.runPasses.length&&u.runPasses.forEach(e=>{E.indexOf(e)<0&&E.push(e)})),(y>0||m>0)&&(l.optimizeCount++,l.optimizeTime+=measure(()=>{F.optimize()})),E.length&&(l.optimizeCount++,l.optimizeTime+=measure(()=>{F.runPasses(E.map(e=>e.trim()))})),!u.noEmit){let e=!1,n=!1;if(null!=u.outFile&&(/\.was?t$/.test(u.outFile)&&null==u.textFile?u.textFile=u.outFile:/\.js$/.test(u.outFile)&&null==u.asmjsFile?u.asmjsFile=u.outFile:null==u.binaryFile&&(u.binaryFile=u.outFile)),null!=u.binaryFile){let r,o=null!=u.sourceMap?u.sourceMap.length?u.sourceMap:path.basename(u.binaryFile)+".map":null;if(l.emitCount++,l.emitTime+=measure(()=>{r=F.toBinary(o)}),u.binaryFile.length?a(path.join(x,u.binaryFile),r.output):(S(r.output),e=!0),n=!0,null!=r.sourceMap)if(u.binaryFile.length){let e=JSON.parse(r.sourceMap);e.sourceRoot=exports.sourceMapRoot,e.sources.forEach((n,r)=>{let i=null;if(n.startsWith(exports.libraryPrefix)){let e=n.substring(exports.libraryPrefix.length).replace(/\.ts$/,"");if(exports.libraryFiles.hasOwnProperty(e))i=exports.libraryFiles[e];else for(let e=0,t=b.length;e<t&&null===(i=s(path.join(b[e],n.substring(exports.libraryPrefix.length))));++e);}else i=s(path.join(x,n));if(null===i)return t(Error("Source file '"+n+"' not found."));e.sourceContents||(e.sourceContents=[]),e.sourceContents[r]=i}),a(path.join(x,path.dirname(u.binaryFile),path.basename(o)),JSON.stringify(e))}else i.write("Skipped source map (stdout already occupied)"+EOL)}if(null!=u.asmjsFile){let t;u.asmjsFile.length?(l.emitCount++,l.emitTime+=measure(()=>{t=F.toAsmjs()}),a(path.join(x,u.asmjsFile),t)):e||(l.emitCount++,l.emitTime+=measure(()=>{t=F.toAsmjs()}),S(t),e=!0),n=!0}if(null!=u.idlFile){let t;u.idlFile.length?(l.emitCount++,l.emitTime+=measure(()=>{t=assemblyscript.buildIDL(g)}),a(path.join(x,u.idlFile),t)):e||(l.emitCount++,l.emitTime+=measure(()=>{t=assemblyscript.buildIDL(g)}),S(t),e=!0),n=!0}if(null!=u.tsdFile){let t;u.tsdFile.length?(l.emitCount++,l.emitTime+=measure(()=>{t=assemblyscript.buildTSD(g)}),a(path.join(x,u.tsdFile),t)):e||(l.emitCount++,l.emitTime+=measure(()=>{t=assemblyscript.buildTSD(g)}),S(t),e=!0),n=!0}if(null!=u.textFile||!n){let n;u.textFile&&u.textFile.length?(l.emitCount++,l.emitTime+=measure(()=>{n=F.toText()}),a(path.join(x,u.textFile),n)):e||(l.emitCount++,l.emitTime+=measure(()=>{n=F.toText()}),S(n))}}return F.dispose(),u.measure&&printStats(l,i),t(null);function T(e){try{let n;return l.readCount++,l.readTime+=measure(()=>{n=fs.readFileSync(e,{encoding:"utf8"})}),n}catch(e){return null}}function z(e,n){try{return l.writeCount++,l.writeTime+=measure(()=>{"string"==typeof n?fs.writeFileSync(e,n,{encoding:"utf8"}):fs.writeFileSync(e,n)}),!0}catch(e){return!1}}function A(e){var n;try{return l.readTime+=measure(()=>{n=fs.readdirSync(e).filter(e=>/^(?!.*\.d\.ts$).*\.ts$/.test(e))}),n}catch(e){return[]}}function S(e){S.used||(l.writeCount++,S.used=!0),l.writeTime+=measure(()=>{"string"==typeof e?r.write(e,{encoding:"utf8"}):r.write(e)})}};var argumentSubstitutions={"-O":["--optimize"],"-Os":["--optimize","--shrinkLevel","1"],"-Oz":["--optimize","--shrinkLevel","2"],"-O0":["--optimizeLevel","0","--shrinkLevel","0"],"-O0s":["--optimizeLevel","0","--shrinkLevel","1"],"-O0z":["--optimizeLevel","0","--shrinkLevel","2"],"-O1":["--optimizeLevel","1","--shrinkLevel","0"],"-O1s":["--optimizeLevel","1","--shrinkLevel","1"],"-O1z":["--optimizeLevel","1","--shrinkLevel","2"],"-O2":["--optimizeLevel","2","--shrinkLevel","0"],"-O2s":["--optimizeLevel","2","--shrinkLevel","1"],"-O2z":["--optimizeLevel","2","--shrinkLevel","2"],"-O3":["--optimizeLevel","3","--shrinkLevel","0"],"-O3s":["--optimizeLevel","3","--shrinkLevel","1"],"-O3z":["--optimizeLevel","3","--shrinkLevel","2"]};function checkDiagnostics(e,n){for(var t,r=!1;null!=(t=assemblyscript.nextDiagnostic(e));)n&&n.write(assemblyscript.formatDiagnostic(t,n.isTTY,!0)+EOL+EOL),assemblyscript.isError(t)&&(r=!0);return r}function createStats(){return{readTime:0,readCount:0,writeTime:0,writeCount:0,parseTime:0,parseCount:0,compileTime:0,compileCount:0,emitTime:0,emitCount:0,validateTime:0,validateCount:0,optimizeTime:0,optimizeCount:0}}function measure(e){const n=process.hrtime();e();const t=process.hrtime(n);return 1e9*t[0]+t[1]}function formatTime(e){return e?(e/1e6).toFixed(3)+" ms":"N/A"}function printStats(e,n){function t(e,n){return formatTime(e)}(n||process.stdout).write(["I/O Read  : "+t(e.readTime,e.readCount),"I/O Write : "+t(e.writeTime,e.writeCount),"Parse     : "+t(e.parseTime,e.parseCount),"Compile   : "+t(e.compileTime,e.compileCount),"Emit      : "+t(e.emitTime,e.emitCount),"Validate  : "+t(e.validateTime,e.validateCount),"Optimize  : "+t(e.optimizeTime,e.optimizeCount)].join(EOL)+EOL)}exports.checkDiagnostics=checkDiagnostics,exports.createStats=createStats,process.hrtime||(process.hrtime=__webpack_require__(3)),exports.measure=measure,exports.formatTime=formatTime,exports.printStats=printStats;var allocBuffer=void 0!==global&&global.Buffer?global.Buffer.allocUnsafe||function(e){return new global.Buffer(e)}:function(e){return new Uint8Array(e)};function createMemoryStream(e){var n=[];return n.write=function(n){if(e&&e(n),"string"==typeof n){let e=allocBuffer(utf8.length(n));utf8.write(n,e,0),n=e}this.push(n)},n.reset=function(){n.length=0},n.toBuffer=function(){for(var e=0,n=0,t=this.length;n<t;)e+=this[n++].length;var r=allocBuffer(e);for(e=n=0;n<t;)r.set(this[n],e),e+=this[n].length,++n;return r},n.toString=function(){var e=this.toBuffer();return utf8.read(e,0,e.length)},n}exports.createMemoryStream=createMemoryStream,exports.tscOptions={alwaysStrict:!0,noImplicitAny:!0,noImplicitReturns:!0,noImplicitThis:!0,noEmitOnError:!0,strictNullChecks:!0,experimentalDecorators:!0,target:"esnext",module:"commonjs",noLib:!0,types:[],allowJs:!1}}).call(this,__webpack_require__(0),__webpack_require__(1))},function(e,n,t){e.exports=t(11)}])});
//# sourceMappingURL=asc.js.map