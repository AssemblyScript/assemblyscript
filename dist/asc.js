!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(function(){try{return require("assemblyscript")}catch(e){}}()):"function"==typeof define&&define.amd?define(["assemblyscript"],n):"object"==typeof exports?exports.asc=n(function(){try{return require("assemblyscript")}catch(e){}}()):e.asc=n(e.assemblyscript)}("undefined"!=typeof self?self:this,function(__WEBPACK_EXTERNAL_MODULE__10__){return function(e){var n={};function t(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=e,t.c=n,t.d=function(e,n,i){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:i})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(i,r,function(n){return e[n]}.bind(null,r));return i},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=4)}([function(e,n,t){var i,r;n.nextTick=function(e){setTimeout(e,0)},n.platform=n.arch=n.execPath=n.title="browser",n.pid=1,n.browser=!0,n.env={},n.argv=[],n.binding=function(e){throw new Error("No such module. (Possibly not yet loaded)")},r="/",n.cwd=function(){return r},n.chdir=function(e){i||(i=t(1)),r=i.resolve(e,r)},n.exit=n.kill=n.umask=n.dlopen=n.uptime=n.memoryUsage=n.uvCounters=function(){},n.features={}},function(e,n,t){(function(e){function t(e,n){for(var t=0,i=e.length-1;i>=0;i--){var r=e[i];"."===r?e.splice(i,1):".."===r?(e.splice(i,1),t++):t&&(e.splice(i,1),t--)}if(n)for(;t--;t)e.unshift("..");return e}var i=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,r=function(e){return i.exec(e).slice(1)};function a(e,n){if(e.filter)return e.filter(n);for(var t=[],i=0;i<e.length;i++)n(e[i],i,e)&&t.push(e[i]);return t}n.resolve=function(){for(var n="",i=!1,r=arguments.length-1;r>=-1&&!i;r--){var o=r>=0?arguments[r]:e.cwd();if("string"!=typeof o)throw new TypeError("Arguments to path.resolve must be strings");o&&(n=o+"/"+n,i="/"===o.charAt(0))}return(i?"/":"")+(n=t(a(n.split("/"),function(e){return!!e}),!i).join("/"))||"."},n.normalize=function(e){var i=n.isAbsolute(e),r="/"===o(e,-1);return(e=t(a(e.split("/"),function(e){return!!e}),!i).join("/"))||i||(e="."),e&&r&&(e+="/"),(i?"/":"")+e},n.isAbsolute=function(e){return"/"===e.charAt(0)},n.join=function(){var e=Array.prototype.slice.call(arguments,0);return n.normalize(a(e,function(e,n){if("string"!=typeof e)throw new TypeError("Arguments to path.join must be strings");return e}).join("/"))},n.relative=function(e,t){function i(e){for(var n=0;n<e.length&&""===e[n];n++);for(var t=e.length-1;t>=0&&""===e[t];t--);return n>t?[]:e.slice(n,t-n+1)}e=n.resolve(e).substr(1),t=n.resolve(t).substr(1);for(var r=i(e.split("/")),a=i(t.split("/")),o=Math.min(r.length,a.length),s=o,l=0;l<o;l++)if(r[l]!==a[l]){s=l;break}var f=[];for(l=s;l<r.length;l++)f.push("..");return(f=f.concat(a.slice(s))).join("/")},n.sep="/",n.delimiter=":",n.dirname=function(e){var n=r(e),t=n[0],i=n[1];return t||i?(i&&(i=i.substr(0,i.length-1)),t+i):"."},n.basename=function(e,n){var t=r(e)[2];return n&&t.substr(-1*n.length)===n&&(t=t.substr(0,t.length-n.length)),t},n.extname=function(e){return r(e)[3]};var o="b"==="ab".substr(-1)?function(e,n,t){return e.substr(n,t)}:function(e,n,t){return n<0&&(n=e.length+n),e.substr(n,t)}}).call(this,t(0))},function(e,n){var t;t=function(){return this}();try{t=t||new Function("return this")()}catch(e){"object"==typeof window&&(t=window)}e.exports=t},function(e,n){},function(e,n,t){e.exports=t(5)},function(module,exports,__webpack_require__){(function(process,global){process.browser&&(process.cwd=function(){return"."});const fs=__webpack_require__(3),path=__webpack_require__(1),utf8=__webpack_require__(6),colorsUtil=__webpack_require__(7),optionsUtil=__webpack_require__(8),mkdirp=__webpack_require__(9),EOL="win32"===process.platform?"\r\n":"\n";process.removeAllListeners&&process.removeAllListeners("uncaughtException");var assemblyscript,isDev=!1;function checkDiagnostics(e,n){for(var t,i=!1;null!=(t=assemblyscript.nextDiagnostic(e));)n&&n.write(assemblyscript.formatDiagnostic(t,n.isTTY,!0)+EOL+EOL),assemblyscript.isError(t)&&(i=!0);return i}function createStats(){return{readTime:0,readCount:0,writeTime:0,writeCount:0,parseTime:0,parseCount:0,compileTime:0,compileCount:0,emitTime:0,emitCount:0,validateTime:0,validateCount:0,optimizeTime:0,optimizeCount:0}}function measure(e){const n=process.hrtime();e();const t=process.hrtime(n);return 1e9*t[0]+t[1]}function formatTime(e){return e?(e/1e6).toFixed(3)+" ms":"N/A"}function printStats(e,n){function t(e,n){return formatTime(e)}(n||process.stdout).write(["I/O Read  : "+t(e.readTime,e.readCount),"I/O Write : "+t(e.writeTime,e.writeCount),"Parse     : "+t(e.parseTime,e.parseCount),"Compile   : "+t(e.compileTime,e.compileCount),"Emit      : "+t(e.emitTime,e.emitCount),"Validate  : "+t(e.validateTime,e.validateCount),"Optimize  : "+t(e.optimizeTime,e.optimizeCount)].join(EOL)+EOL)}(()=>{try{assemblyscript=__webpack_require__(10)}catch(e){try{__webpack_require__(!function(){var e=new Error("Cannot find module 'ts-node'");throw e.code="MODULE_NOT_FOUND",e}()).register({project:path.join(".","..","src","tsconfig.json")}),__webpack_require__(!function(){var e=new Error("Cannot find module '../src/glue/js'");throw e.code="MODULE_NOT_FOUND",e}()),assemblyscript=__webpack_require__(!function(){var e=new Error("Cannot find module '../src'");throw e.code="MODULE_NOT_FOUND",e}()),isDev=!0}catch(e_ts){try{assemblyscript=eval("require('./assemblyscript')")}catch(e){throw e.stack=e_ts.stack+"\n---\n"+e.stack,e}}}})(),exports.isBundle=!0,exports.isDev=isDev,exports.version=exports.isBundle?"0.6.0":__webpack_require__(!function(){var e=new Error("Cannot find module '../package.json'");throw e.code="MODULE_NOT_FOUND",e}()).version,exports.options=__webpack_require__(11),exports.sourceMapRoot="assemblyscript:///",exports.libraryPrefix=assemblyscript.LIBRARY_PREFIX,exports.defaultOptimizeLevel=2,exports.defaultShrinkLevel=1,exports.libraryFiles=exports.isBundle?Object({"allocator/arena":'/**\n * Arena Memory Allocator\n *\n * Provides a `memory.reset` function to reset the heap to its initial state. A user has to make\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/arena\n *//***/\n\nimport { AL_MASK, MAX_SIZE_32 } from "../internal/allocator";\n\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\nvar offset: usize = startOffset;\n\n// Memory allocator interface\n\n@global export function __memory_allocate(size: usize): usize {\n  if (size > MAX_SIZE_32) unreachable();\n  var ptr = offset;\n  var newPtr = (ptr + max<usize>(size, 1) + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  if (newPtr > <usize>pagesBefore << 16) {\n    let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) {\n        unreachable(); // out of memory\n      }\n    }\n  }\n  offset = newPtr;\n  return ptr;\n}\n\n@global export function __memory_free(ptr: usize): void { /* nop */ }\n\n@global export function __memory_reset(): void {\n  offset = startOffset;\n}\n',"allocator/buddy":'/**\n * Buddy Memory Allocator.\n * @module std/assembly/allocator/buddy\n *//***/\n\n/*\n  Copyright 2018 Evan Wallace\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the "Software"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n*/// see: https://github.com/evanw/buddy-malloc\n\n/*\n * This file implements a buddy memory allocator, which is an allocator that\n * allocates memory within a fixed linear address range. It spans the address\n * range with a binary tree that tracks free space. Both "malloc" and "free"\n * are O(log N) time where N is the maximum possible number of allocations.\n *\n * The "buddy" term comes from how the tree is used. When memory is allocated,\n * nodes in the tree are split recursively until a node of the appropriate size\n * is reached. Every split results in two child nodes, each of which is the\n * buddy of the other. When a node is freed, the node and its buddy can be\n * merged again if the buddy is also free. This makes the memory available\n * for larger allocations again.\n */\n\n/*\n * Every allocation needs an 8-byte header to store the allocation size while\n * staying 8-byte aligned. The address returned by "malloc" is the address\n * right after this header (i.e. the size occupies the 8 bytes before the\n * returned address).\n */\nconst HEADER_SIZE: usize = 8;\n\n/*\n * The minimum allocation size is 16 bytes because we have an 8-byte header and\n * we need to stay 8-byte aligned.\n */\nconst MIN_ALLOC_LOG2: usize = 4;\nconst MIN_ALLOC: usize = 1 << MIN_ALLOC_LOG2;\n\n/*\n * The maximum allocation size is currently set to 2gb. This is the total size\n * of the heap. It\'s technically also the maximum allocation size because the\n * heap could consist of a single allocation of this size. But of course real\n * heaps will have multiple allocations, so the real maximum allocation limit\n * is at most 1gb.\n */\nconst MAX_ALLOC_LOG2: usize = 30; // 31;\nconst MAX_ALLOC: usize = 1 << MAX_ALLOC_LOG2;\n\n/*\n * Allocations are done in powers of two starting from MIN_ALLOC and ending at\n * MAX_ALLOC inclusive. Each allocation size has a bucket that stores the free\n * list for that allocation size.\n *\n * Given a bucket index, the size of the allocations in that bucket can be\n * found with "(size_t)1 << (MAX_ALLOC_LOG2 - bucket)".\n */\nconst BUCKET_COUNT: usize = MAX_ALLOC_LOG2 - MIN_ALLOC_LOG2 + 1;\n\n/*\n * Free lists are stored as circular doubly-linked lists. Every possible\n * allocation size has an associated free list that is threaded through all\n * currently free blocks of that size. That means MIN_ALLOC must be at least\n * "sizeof(list_t)". MIN_ALLOC is currently 16 bytes, so this will be true for\n * both 32-bit and 64-bit.\n */\n@unmanaged\nclass List {\n  prev: List;\n  next: List;\n  static readonly SIZE: usize = 2 * sizeof<usize>();\n}\n\n/*\n * Each bucket corresponds to a certain allocation size and stores a free list\n * for that size. The bucket at index 0 corresponds to an allocation size of\n * MAX_ALLOC (i.e. the whole address space).\n */\nvar BUCKETS_START: usize = HEAP_BASE;\nvar BUCKETS_END: usize = BUCKETS_START + BUCKET_COUNT * List.SIZE;\n\nfunction buckets$get(index: usize): List {\n  assert(index < BUCKET_COUNT);\n  return changetype<List>(BUCKETS_START + index * List.SIZE);\n}\n\n/*\n * We could initialize the allocator by giving it one free block the size of\n * the entire address space. However, this would cause us to instantly reserve\n * half of the entire address space on the first allocation, since the first\n * split would store a free list entry at the start of the right child of the\n * root. Instead, we have the tree start out small and grow the size of the\n * tree as we use more memory. The size of the tree is tracked by this value.\n */\nvar bucket_limit: usize;\n\n/*\n * This array represents a linearized binary tree of bits. Every possible\n * allocation larger than MIN_ALLOC has a node in this tree (and therefore a\n * bit in this array).\n *\n * Given the index for a node, lineraized binary trees allow you to traverse to\n * the parent node or the child nodes just by doing simple arithmetic on the\n * index:\n *\n * - Move to parent:         index = (index - 1) / 2;\n * - Move to left child:     index = index * 2 + 1;\n * - Move to right child:    index = index * 2 + 2;\n * - Move to sibling:        index = ((index - 1) ^ 1) + 1;\n *\n * Each node in this tree can be in one of several states:\n *\n * - UNUSED (both children are UNUSED)\n * - SPLIT (one child is UNUSED and the other child isn\'t)\n * - USED (neither children are UNUSED)\n *\n * These states take two bits to store. However, it turns out we have enough\n * information to distinguish between UNUSED and USED from context, so we only\n * need to store SPLIT or not, which only takes a single bit.\n *\n * Note that we don\'t need to store any nodes for allocations of size MIN_ALLOC\n * since we only ever care about parent nodes.\n */\nconst SPLIT_COUNT: usize = (1 << (BUCKET_COUNT - 1)) / 8;\nvar NODE_IS_SPLIT_START: usize = BUCKETS_END;\nvar NODE_IS_SPLIT_END: usize = NODE_IS_SPLIT_START + SPLIT_COUNT * sizeof<u8>();\n\nfunction node_is_split$get(index: usize): i32 {\n  assert(index < SPLIT_COUNT);\n  return load<u8>(NODE_IS_SPLIT_START + index);\n}\n\nfunction node_is_split$set(index: usize, state: i32): void {\n  assert(index < SPLIT_COUNT);\n  store<u8>(NODE_IS_SPLIT_START + index, state);\n}\n\n/*\n * This is the starting address of the address range for this allocator. Every\n * returned allocation will be an offset of this pointer from 0 to MAX_ALLOC.\n */\nvar base_ptr: usize;\n\n/*\n * This is the maximum address that has ever been used by the allocator. It\'s\n * used to know when to call "brk" to request more memory from the kernel.\n */\nvar max_ptr: usize;\n\n/*\n * Make sure all addresses before "new_value" are valid and can be used. Memory\n * is allocated in a 2gb address range but that memory is not reserved up\n * front. It\'s only reserved when it\'s needed by calling this function. This\n * will return false if the memory could not be reserved.\n */\nfunction update_max_ptr(new_value: usize): i32 {\n  if (new_value > max_ptr) {\n    // if (brk(new_value)) {\n    //   return 0;\n    // }\n    let oldPages = <i32>memory.size();\n    let newPages = <i32>(((new_value + 0xffff) & ~0xffff) >>> 16);\n    assert(newPages > oldPages);\n    if (memory.grow(newPages - oldPages) < 0) {\n      return 0;\n    }\n    // max_ptr = new_value;\n    max_ptr = <usize>newPages << 16;\n  }\n  return 1;\n}\n\n/*\n * Initialize a list to empty. Because these are circular lists, an "empty"\n * list is an entry where both links point to itself. This makes insertion\n * and removal simpler because they don\'t need any branches.\n */\nfunction list_init(list: List): void {\n  list.prev = list;\n  list.next = list;\n}\n\n/*\n * Append the provided entry to the end of the list. This assumes the entry\n * isn\'t in a list already because it overwrites the linked list pointers.\n */\nfunction list_push(list: List, entry: List): void {\n  var prev = list.prev;\n  entry.prev = prev;\n  entry.next = list;\n  prev.next = entry;\n  list.prev = entry;\n}\n\n/*\n * Remove the provided entry from whichever list it\'s currently in. This\n * assumes that the entry is in a list. You don\'t need to provide the list\n * because the lists are circular, so the list\'s pointers will automatically\n * be updated if the first or last entries are removed.\n */\nfunction list_remove(entry: List): void {\n  var prev = entry.prev;\n  var next = entry.next;\n  prev.next = next;\n  next.prev = prev;\n}\n\n/*\n * Remove and return the first entry in the list or NULL if the list is empty.\n */\nfunction list_pop(list: List): List | null {\n  var back = list.prev;\n  if (back == list) return null;\n  list_remove(back);\n  return back;\n}\n\n/*\n * This maps from the index of a node to the address of memory that node\n * represents. The bucket can be derived from the index using a loop but is\n * required to be provided here since having them means we can avoid the loop\n * and have this function return in constant time.\n */\nfunction ptr_for_node(index: usize, bucket: usize): usize {\n  return base_ptr + ((index - (1 << bucket) + 1) << (MAX_ALLOC_LOG2 - bucket));\n}\n\n/*\n * This maps from an address of memory to the node that represents that\n * address. There are often many nodes that all map to the same address, so\n * the bucket is needed to uniquely identify a node.\n */\nfunction node_for_ptr(ptr: usize, bucket: usize): usize {\n  return ((ptr - base_ptr) >> (MAX_ALLOC_LOG2 - bucket)) + (1 << bucket) - 1;\n}\n\n/*\n * Given the index of a node, this returns the "is split" flag of the parent.\n */\nfunction parent_is_split(index: usize): bool {\n  index = (index - 1) / 2;\n  return ((node_is_split$get(index / 8) >>> <i32>(index % 8)) & 1) == 1;\n}\n\n/*\n * Given the index of a node, this flips the "is split" flag of the parent.\n */\nfunction flip_parent_is_split(index: usize): void {\n  index = (index - 1) / 2;\n  var indexDiv8 = index / 8;\n  node_is_split$set(indexDiv8,\n    node_is_split$get(indexDiv8) ^ <i32>(1 << (index % 8))\n  );\n}\n\n/*\n * Given the requested size passed to "malloc", this function returns the index\n * of the smallest bucket that can fit that size.\n */\nfunction bucket_for_request(request: usize): usize {\n  var bucket = BUCKET_COUNT - 1;\n  var size = MIN_ALLOC;\n\n  while (size < request) {\n    bucket--;\n    size *= 2;\n  }\n\n  return bucket;\n}\n\n/*\n * The tree is always rooted at the current bucket limit. This call grows the\n * tree by repeatedly doubling it in size until the root lies at the provided\n * bucket index. Each doubling lowers the bucket limit by 1.\n */\nfunction lower_bucket_limit(bucket: usize): u32 {\n  while (bucket < bucket_limit) {\n    let root = node_for_ptr(base_ptr, bucket_limit);\n    let right_child: usize;\n\n    /*\n     * If the parent isn\'t SPLIT, that means the node at the current bucket\n     * limit is UNUSED and our address space is entirely free. In that case,\n     * clear the root free list, increase the bucket limit, and add a single\n     * block with the newly-expanded address space to the new root free list.\n     */\n    if (!parent_is_split(root)) {\n      list_remove(changetype<List>(base_ptr));\n      list_init(buckets$get(--bucket_limit));\n      list_push(buckets$get(bucket_limit), changetype<List>(base_ptr));\n      continue;\n    }\n\n    /*\n     * Otherwise, the tree is currently in use. Create a parent node for the\n     * current root node in the SPLIT state with a right child on the free\n     * list. Make sure to reserve the memory for the free list entry before\n     * writing to it. Note that we do not need to flip the "is split" flag for\n     * our current parent because it\'s already on (we know because we just\n     * checked it above).\n     */\n    right_child = ptr_for_node(root + 1, bucket_limit);\n    if (!update_max_ptr(right_child + List.SIZE)) {\n      return 0;\n    }\n    list_push(buckets$get(bucket_limit), changetype<List>(right_child));\n    list_init(buckets$get(--bucket_limit));\n\n    /*\n     * Set the grandparent\'s SPLIT flag so if we need to lower the bucket limit\n     * again, we\'ll know that the new root node we just added is in use.\n     */\n    root = (root - 1) / 2;\n    if (root != 0) {\n      flip_parent_is_split(root);\n    }\n  }\n\n  return 1;\n}\n\n// Memory allocator interface\n\n@global export function __memory_allocate(request: usize): usize {\n  var original_bucket: usize, bucket: usize;\n\n  /*\n   * Make sure it\'s possible for an allocation of this size to succeed. There\'s\n   * a hard-coded limit on the maximum allocation size because of the way this\n   * allocator works.\n   */\n  if (request > MAX_ALLOC - HEADER_SIZE) unreachable();\n\n  /*\n   * Initialize our global state if this is the first call to "malloc". At the\n   * beginning, the tree has a single node that represents the smallest\n   * possible allocation size. More memory will be reserved later as needed.\n   */\n  if (base_ptr == 0) {\n    // base_ptr = max_ptr = (uint8_t *)sbrk(0);\n    base_ptr = (NODE_IS_SPLIT_END + 7) & ~7; // must be aligned\n    max_ptr = <usize>memory.size() << 16; // must grow first\n    bucket_limit = BUCKET_COUNT - 1;\n    if (!update_max_ptr(base_ptr + List.SIZE)) {\n      return 0;\n    }\n    list_init(buckets$get(BUCKET_COUNT - 1));\n    list_push(buckets$get(BUCKET_COUNT - 1), changetype<List>(base_ptr));\n  }\n\n  /*\n   * Find the smallest bucket that will fit this request. This doesn\'t check\n   * that there\'s space for the request yet.\n   */\n  bucket = bucket_for_request(request + HEADER_SIZE);\n  original_bucket = bucket;\n\n  /*\n   * Search for a bucket with a non-empty free list that\'s as large or larger\n   * than what we need. If there isn\'t an exact match, we\'ll need to split a\n   * larger one to get a match.\n   */\n  while (bucket + 1 != 0) {\n    let size: usize, bytes_needed: usize, i: usize;\n    let ptr: usize;\n\n    /*\n     * We may need to grow the tree to be able to fit an allocation of this\n     * size. Try to grow the tree and stop here if we can\'t.\n     */\n    if (!lower_bucket_limit(bucket)) {\n      return 0;\n    }\n\n    /*\n     * Try to pop a block off the free list for this bucket. If the free list\n     * is empty, we\'re going to have to split a larger block instead.\n     */\n    ptr = changetype<usize>(list_pop(buckets$get(bucket)));\n    if (!ptr) {\n      /*\n       * If we\'re not at the root of the tree or it\'s impossible to grow the\n       * tree any more, continue on to the next bucket.\n       */\n      if (bucket != bucket_limit || bucket == 0) {\n        bucket--;\n        continue;\n      }\n\n      /*\n       * Otherwise, grow the tree one more level and then pop a block off the\n       * free list again. Since we know the root of the tree is used (because\n       * the free list was empty), this will add a parent above this node in\n       * the SPLIT state and then add the new right child node to the free list\n       * for this bucket. Popping the free list will give us this right child.\n       */\n      if (!lower_bucket_limit(bucket - 1)) {\n        return 0;\n      }\n      ptr = changetype<usize>(list_pop(buckets$get(bucket)));\n    }\n\n    /*\n     * Try to expand the address space first before going any further. If we\n     * have run out of space, put this block back on the free list and fail.\n     */\n    size = 1 << (MAX_ALLOC_LOG2 - bucket);\n    bytes_needed = bucket < original_bucket ? size / 2 + List.SIZE : size;\n    if (!update_max_ptr(ptr + bytes_needed)) {\n      list_push(buckets$get(bucket), changetype<List>(ptr));\n      return 0;\n    }\n\n    /*\n     * If we got a node off the free list, change the node from UNUSED to USED.\n     * This involves flipping our parent\'s "is split" bit because that bit is\n     * the exclusive-or of the UNUSED flags of both children, and our UNUSED\n     * flag (which isn\'t ever stored explicitly) has just changed.\n     *\n     * Note that we shouldn\'t ever need to flip the "is split" bit of our\n     * grandparent because we know our buddy is USED so it\'s impossible for our\n     * grandparent to be UNUSED (if our buddy chunk was UNUSED, our parent\n     * wouldn\'t ever have been split in the first place).\n     */\n    i = node_for_ptr(ptr, bucket);\n    if (i != 0) {\n      flip_parent_is_split(i);\n    }\n\n    /*\n     * If the node we got is larger than we need, split it down to the correct\n     * size and put the new unused child nodes on the free list in the\n     * corresponding bucket. This is done by repeatedly moving to the left\n     * child, splitting the parent, and then adding the right child to the free\n     * list.\n     */\n    while (bucket < original_bucket) {\n      i = i * 2 + 1;\n      bucket++;\n      flip_parent_is_split(i);\n      list_push(\n        buckets$get(bucket),\n        changetype<List>(ptr_for_node(i + 1, bucket))\n      );\n    }\n\n    /*\n     * Now that we have a memory address, write the block header (just the size\n     * of the allocation) and return the address immediately after the header.\n     */\n    store<usize>(ptr, request);\n    return ptr + HEADER_SIZE;\n  }\n\n  return 0;\n}\n\n@global export function __memory_free(ptr: usize): void {\n  var bucket: usize, i: usize;\n\n  /*\n   * Ignore any attempts to free a NULL pointer.\n   */\n  if (!ptr) {\n    return;\n  }\n\n  /*\n   * We were given the address returned by "malloc" so get back to the actual\n   * address of the node by subtracting off the size of the block header. Then\n   * look up the index of the node corresponding to this address.\n   */\n  ptr = ptr - HEADER_SIZE;\n  bucket = bucket_for_request(load<usize>(ptr) + HEADER_SIZE);\n  i = node_for_ptr(ptr, bucket);\n\n  /*\n   * Traverse up to the root node, flipping USED blocks to UNUSED and merging\n   * UNUSED buddies together into a single UNUSED parent.\n   */\n  while (i != 0) {\n    /*\n     * Change this node from UNUSED to USED. This involves flipping our\n     * parent\'s "is split" bit because that bit is the exclusive-or of the\n     * UNUSED flags of both children, and our UNUSED flag (which isn\'t ever\n     * stored explicitly) has just changed.\n     */\n    flip_parent_is_split(i);\n\n    /*\n     * If the parent is now SPLIT, that means our buddy is USED, so don\'t merge\n     * with it. Instead, stop the iteration here and add ourselves to the free\n     * list for our bucket.\n     *\n     * Also stop here if we\'re at the current root node, even if that root node\n     * is now UNUSED. Root nodes don\'t have a buddy so we can\'t merge with one.\n     */\n    if (parent_is_split(i) || bucket == bucket_limit) {\n      break;\n    }\n\n    /*\n     * If we get here, we know our buddy is UNUSED. In this case we should\n     * merge with that buddy and continue traversing up to the root node. We\n     * need to remove the buddy from its free list here but we don\'t need to\n     * add the merged parent to its free list yet. That will be done once after\n     * this loop is finished.\n     */\n    list_remove(changetype<List>(ptr_for_node(((i - 1) ^ 1) + 1, bucket)));\n    i = (i - 1) / 2;\n    bucket--;\n  }\n\n  /*\n   * Add ourselves to the free list for our bucket. We add to the back of the\n   * list because "malloc" takes from the back of the list and we want a "free"\n   * followed by a "malloc" of the same size to ideally use the same address\n   * for better memory locality.\n   */\n  list_push(buckets$get(bucket), changetype<List>(ptr_for_node(i, bucket)));\n}\n',"allocator/emscripten":"/**\n * Emscripten Memory Allocator.\n *\n * Uses Emscripten's exported _malloc and _free implementations, i.e., when linking with\n * Emscripten-compiled programs that already provide these. Differs from 'system' in that their\n * names are prefixed with an underscore.\n *\n * @module std/assembly/allocator/emscripten\n *//***/\n\ndeclare function _malloc(size: usize): usize;\ndeclare function _free(ptr: usize): void;\n\n// Memory allocator interface\n\n@global export function __memory_allocate(size: usize): usize {\n  return _malloc(size);\n}\n\n@global export function __memory_free(ptr: usize): void {\n  _free(ptr);\n}\n","allocator/system":"/**\n * System Memory Allocator.\n *\n * Uses the environment's malloc and free implementations, i.e., when linking with other C-like\n * programs that already provide these.\n *\n * @module std/assembly/allocator/system\n *//***/\n\ndeclare function malloc(size: usize): usize;\ndeclare function free(ptr: usize): void;\n\n// Memory allocator interface\n\n@global export function __memory_allocate(size: usize): usize {\n  return malloc(size);\n}\n\n@global export function __memory_free(ptr: usize): void {\n  free(ptr);\n}\n","allocator/tlsf":"/**\n * Two-Level Segregate Fit Memory Allocator.\n *\n * A general purpose dynamic memory allocator specifically designed to meet real-time requirements.\n * Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/tlsf\n *//***/\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─╫─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴─────────╨─────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\nimport {\n  AL_BITS,\n  AL_SIZE,\n  AL_MASK\n} from \"../internal/allocator\";\n\nconst SL_BITS: u32 = 5;\nconst SL_SIZE: usize = 1 << <usize>SL_BITS;\n\nconst SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\nconst SB_SIZE: usize = 1 << <usize>SB_BITS;\n\nconst FL_BITS: u32 = (sizeof<usize>() == sizeof<u32>()\n  ? 30 // ^= up to 1GB per block\n  : 32 // ^= up to 4GB per block\n) - SB_BITS;\n\n// ╒════════════════ Block structure layout (32-bit) ══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤\n// │                          size                             │L│F│ ◄─┐ info\n// ╞═══════════════════════════════════════════════════════════╧═╧═╡   │      ┐\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                ... unused free space >= 0 ...                 │   │    = 0\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤   │\n// │                        if free: jump ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ MIN SIZE ┘\n// F: FREE, L: LEFT_FREE\n\n/** Tag indicating that this block is free. */\nconst FREE: usize = 1 << 0;\n/** Tag indicating that this block's left block is free. */\nconst LEFT_FREE: usize = 1 << 1;\n/** Mask to obtain all tags. */\nconst TAGS: usize = FREE | LEFT_FREE;\n\n/** Block structure. */\n@unmanaged\nclass Block {\n\n  /** Info field holding this block's size and tags. */\n  info: usize;\n\n  /** End offset of the {@link Block#info} field. User data starts here. */\n  static readonly INFO: usize = (sizeof<usize>() + AL_MASK) & ~AL_MASK;\n\n  /** Previous free block, if any. Only valid if free. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free. */\n  next: Block | null;\n\n  /** Minimum size of a block, excluding {@link Block#info}. */\n  static readonly MIN_SIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK;// prev + next + jump\n\n  /** Maximum size of a used block, excluding {@link Block#info}. */\n  static readonly MAX_SIZE: usize = 1 << (FL_BITS + SB_BITS);\n\n  /** Gets this block's left (free) block in memory. */\n  get left(): Block {\n    assert(this.info & LEFT_FREE); // must be free to contain a jump\n    return assert(\n      load<Block>(changetype<usize>(this) - sizeof<usize>())\n    ); // can't be null\n  }\n\n  /** Gets this block's right block in memory. */\n  get right(): Block {\n    assert(this.info & ~TAGS); // can't skip beyond the tail block\n    return assert(\n      changetype<Block>(\n        changetype<usize>(this) + Block.INFO + (this.info & ~TAGS)\n      )\n    ); // can't be null\n  }\n}\n\n// ╒════════════════ Root structure layout (32-bit) ═══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                              ...                              │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[22] P                         │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[736]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                            tailRef                            │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map, P: Possibly padded if 64-bit\n\nassert((1 << SL_BITS) <= 32); // second level must fit into 32 bits\n\n/** Root structure. */\n@unmanaged\nclass Root {\n\n  /** First level bitmap. */\n  flMap: usize = 0;\n\n  /** Start offset of second level maps. */\n  private static readonly SL_START: usize = sizeof<usize>();\n\n  // Using *one* SL map per *FL bit*\n\n  /** Gets the second level map for the specified first level. */\n  getSLMap(fl: usize): u32 {\n    assert(fl < FL_BITS); // fl out of range\n    return load<u32>(changetype<usize>(this) + fl * 4, Root.SL_START);\n  }\n\n  /** Sets the second level map for the specified first level. */\n  setSLMap(fl: usize, value: u32): void {\n    assert(fl < FL_BITS); // fl out of range\n    store<u32>(changetype<usize>(this) + fl * 4, value, Root.SL_START);\n  }\n\n  /** End offset of second level maps. */\n  private static readonly SL_END: usize = Root.SL_START + FL_BITS * 4;\n\n  // Using *number bits per SL* heads per *FL bit*\n\n  /** Start offset of FL/SL heads. */\n  private static readonly HL_START: usize = (Root.SL_END + AL_MASK) & ~AL_MASK;\n\n  /** Gets the head of the specified first and second level index. */\n  getHead(fl: usize, sl: u32): Block | null {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    return changetype<Block>(load<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , Root.HL_START));\n  }\n\n  /** Sets the head of the specified first and second level index. */\n  setHead(fl: usize, sl: u32, value: Block | null): void {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    store<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , changetype<usize>(value)\n    , Root.HL_START);\n  }\n\n  /** End offset of FL/SL heads. */\n  private static readonly HL_END: usize = (\n    Root.HL_START + FL_BITS * SL_SIZE * sizeof<usize>()\n  );\n\n  get tailRef(): usize { return load<usize>(0, Root.HL_END); }\n  set tailRef(value: usize) { store<usize>(0, value, Root.HL_END); }\n\n  /** Total size of the {@link Root} structure. */\n  static readonly SIZE: usize = Root.HL_END + sizeof<usize>();\n\n  /** Inserts a previously used block back into the free list. */\n  insert(block: Block): void {\n    // check as much as possible here to prevent invalid free blocks\n    assert(block); // cannot be null\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size: usize;\n    assert(\n      (size = block.info & ~TAGS) >= Block.MIN_SIZE && size < Block.MAX_SIZE\n    ); // must be valid, not necessary to compute yet if noAssert=true\n\n    var right: Block = assert(block.right); // can't be null\n    var rightInfo = right.info;\n\n    // merge with right block if also free\n    if (rightInfo & FREE) {\n      this.remove(right);\n      block.info = (blockInfo += Block.INFO + (rightInfo & ~TAGS));\n      right = block.right;\n      rightInfo = right.info;\n      // jump is set below\n    }\n\n    // merge with left block if also free\n    if (blockInfo & LEFT_FREE) {\n      let left: Block = assert(block.left); // can't be null\n      let leftInfo = left.info;\n      assert(leftInfo & FREE); // must be free according to tags\n      this.remove(left);\n      left.info = (leftInfo += Block.INFO + (blockInfo & ~TAGS));\n      block = left;\n      blockInfo = leftInfo;\n      // jump is set below\n    }\n\n    right.info = rightInfo | LEFT_FREE;\n    this.setJump(block, right);\n    // right is no longer used now, hence rightInfo is not synced\n\n    size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // perform insertion\n    var head = this.getHead(fl, sl);\n    block.prev = null;\n    block.next = head;\n    if (head) head.prev = block;\n    this.setHead(fl, sl, block);\n\n    // update first and second level maps\n    this.flMap |= (1 << fl);\n    this.setSLMap(fl, this.getSLMap(fl) | (1 << sl));\n  }\n\n  /**\n   * Removes a free block from FL/SL maps. Does not alter left/jump because it\n   * is likely that splitting is performed afterwards, invalidating any changes\n   * again.\n   */\n  private remove(block: Block): void {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // link previous and next free block\n    var prev = block.prev;\n    var next = block.next;\n    if (prev) prev.next = next;\n    if (next) next.prev = prev;\n\n    // update head if we are removing it\n    if (block == this.getHead(fl, sl)) {\n      this.setHead(fl, sl, next);\n\n      // clear second level map if head is empty now\n      if (!next) {\n        let slMap = this.getSLMap(fl);\n        this.setSLMap(fl, slMap &= ~(1 << sl));\n\n        // clear first level map if second level is empty now\n        if (!slMap) this.flMap &= ~(1 << fl);\n      }\n    }\n  }\n\n  /** Searches for a free block of at least the specified size. */\n  search(size: usize): Block | null {\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE);\n\n    // mapping_search\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      // (*) size += (1 << (fls<usize>(size) - SL_BITS)) - 1;\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n      // (*) instead of rounding up, use next second level list for better fit\n      if (sl < SL_SIZE - 1) ++sl;\n      else ++fl, sl = 0;\n    }\n\n    // search second level\n    var slMap = this.getSLMap(fl) & (~0 << sl);\n    var head: Block | null;\n    if (!slMap) {\n      // search next larger first level\n      let flMap = this.flMap & (~0 << (fl + 1));\n      if (!flMap) {\n        head = null;\n      } else {\n        fl = ffs<usize>(flMap);\n        slMap = assert(this.getSLMap(fl)); // can't be zero if fl points here\n        head = this.getHead(fl, ffs<u32>(slMap));\n      }\n    } else {\n      head = this.getHead(fl, ffs<u32>(slMap));\n    }\n    return head;\n  }\n\n  /** Links a free left with its right block in memory. */\n  private setJump(left: Block, right: Block): void {\n    assert(left.info & FREE);       // must be free\n    assert(left.right == right);    // right block must match\n    assert(right.info & LEFT_FREE); // right block must be tagged as LEFT_FREE\n    store<Block>(\n      changetype<usize>(right) - sizeof<usize>()\n    , left); // last word in left block's (free) data region\n  }\n\n  /**\n   * Uses the specified free block, removing it from internal maps and\n   * splitting it if possible, and returns its data pointer.\n   */\n  use(block: Block, size: usize): usize {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free so we can use it\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n    assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n    this.remove(block);\n\n    // split if the block can hold another MIN_SIZE block\n    var remaining = (blockInfo & ~TAGS) - size;\n    if (remaining >= Block.INFO + Block.MIN_SIZE) {\n      block.info = size | (blockInfo & LEFT_FREE); // also discards FREE\n\n      let spare = changetype<Block>(\n        changetype<usize>(block) + Block.INFO + size\n      );\n      spare.info = (remaining - Block.INFO) | FREE; // not LEFT_FREE\n      this.insert(spare); // also sets jump\n\n    // otherwise tag block as no longer FREE and right as no longer LEFT_FREE\n    } else {\n      block.info = blockInfo & ~FREE;\n      let right: Block = assert(block.right); // can't be null (tail)\n      right.info &= ~LEFT_FREE;\n    }\n\n    return changetype<usize>(block) + Block.INFO;\n  }\n\n  /** Adds more memory to the pool. */\n  addMemory(start: usize, end: usize): bool {\n    assert(start <= end);\n    assert(!(start & AL_MASK)); // must be aligned\n    assert(!(end & AL_MASK)); // must be aligned\n\n    var tailRef = this.tailRef;\n    var tailInfo: usize = 0;\n    if (tailRef) {\n      assert(start >= tailRef + sizeof<usize>()); // starts after tail\n\n      // merge with current tail if adjacent\n      if (start - Block.INFO == tailRef) {\n        start -= Block.INFO;\n        tailInfo = changetype<Block>(tailRef).info;\n      }\n\n    } else {\n      assert(start >= changetype<usize>(this) + Root.SIZE); // starts after root\n    }\n\n    // check if size is large enough for a free block and the tail block\n    var size = end - start;\n    if (size < Block.INFO + Block.MIN_SIZE + Block.INFO) {\n      return false;\n    }\n\n    // left size is total minus its own and the zero-length tail's header\n    var leftSize = size - 2 * Block.INFO;\n    var left = changetype<Block>(start);\n    left.info = leftSize | FREE | (tailInfo & LEFT_FREE);\n    left.prev = null;\n    left.next = null;\n\n    // tail is a zero-length used block\n    var tail = changetype<Block>(start + size - Block.INFO);\n    tail.info = 0 | LEFT_FREE;\n    this.tailRef = changetype<usize>(tail);\n\n    this.insert(left); // also merges with free left before tail / sets jump\n\n    return true;\n  }\n}\n\n/** Determines the first (LSB to MSB) set bit's index of a word. */\nfunction ffs<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  return ctz<T>(word);  // differs from ffs only for 0\n}\n\n/** Determines the last (LSB to MSB) set bit's index of a word. */\nfunction fls<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  const inv: T = (sizeof<T>() << 3) - 1;\n  return inv - clz<T>(word);\n}\n\n/** Reference to the initialized {@link Root} structure, once initialized. */\nvar ROOT: Root = changetype<Root>(0);\n\n// Memory allocator interface\n\n/** Allocates a chunk of memory. */\n@global export function __memory_allocate(size: usize): usize {\n\n  // initialize if necessary\n  var root = ROOT;\n  if (!root) {\n    let rootOffset = (HEAP_BASE + AL_MASK) & ~AL_MASK;\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>((((rootOffset + Root.SIZE) + 0xffff) & ~0xffff) >>> 16);\n    if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n    ROOT = root = changetype<Root>(rootOffset);\n    root.tailRef = 0;\n    root.flMap = 0;\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n      root.setSLMap(fl, 0);\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n        root.setHead(fl, sl, null);\n      }\n    }\n    root.addMemory((rootOffset + Root.SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\n  }\n\n  // search for a suitable block\n  if (size > Block.MAX_SIZE) unreachable();\n\n  // 32-bit MAX_SIZE is 1 << 30 and itself aligned, hence the following can't overflow MAX_SIZE\n  size = max<usize>((size + AL_MASK) & ~AL_MASK, Block.MIN_SIZE);\n\n  var block = root.search(size);\n  if (!block) {\n\n    // request more memory\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) {\n        unreachable(); // out of memory\n      }\n    }\n    let pagesAfter = memory.size();\n    root.addMemory(<usize>pagesBefore << 16, <usize>pagesAfter << 16);\n    block = assert(root.search(size)); // must be found now\n  }\n\n  assert((block.info & ~TAGS) >= size);\n  return root.use(<Block>block, size);\n}\n\n/** Frees the chunk of memory at the specified address. */\n@global export function __memory_free(data: usize): void {\n  if (data) {\n    let root = ROOT;\n    if (root) {\n      let block = changetype<Block>(data - Block.INFO);\n      let blockInfo = block.info;\n      assert(!(blockInfo & FREE)); // must be used\n      block.info = blockInfo | FREE;\n      root.insert(changetype<Block>(data - Block.INFO));\n    }\n  }\n}\n\n@global export function __memory_reset(): void {\n  unreachable();\n}\n",array:'import {\n  MAX_BLENGTH,\n  HEADER_SIZE,\n  allocateUnsafe,\n  reallocateUnsafe,\n  LOAD,\n  STORE\n} from "./internal/arraybuffer";\n\nimport {\n  allocateUnsafe as allocateUnsafeString,\n  freeUnsafe as freeUnsafeString,\n  copyUnsafe as copyUnsafeString\n} from "./internal/string";\n\nimport {\n  COMPARATOR,\n  SORT\n} from "./internal/sort";\n\nimport {\n  itoa,\n  dtoa,\n  itoa_stream,\n  dtoa_stream,\n  MAX_DOUBLE_LENGTH\n} from "./internal/number";\n\nimport {\n  isArray as builtin_isArray\n} from "./builtins";\n\nexport class Array<T> {\n  [key: number]: T; // compatibility only\n\n  /* @internal */ buffer_: ArrayBuffer;\n  /* @internal */ length_: i32;\n\n  @inline static isArray<U>(value: U): bool {\n    return builtin_isArray(value) && value !== null;\n  }\n\n  constructor(length: i32 = 0) {\n    const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n    if (<u32>length > <u32>MAX_LENGTH) throw new RangeError("Invalid array length");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    this.buffer_ = buffer;\n    this.length_ = length;\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      0,\n      <usize>byteLength\n    );\n  }\n\n  @inline\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(length: i32) {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>length > <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length > <u32>MAX_LENGTH) throw new RangeError("Invalid array length");\n      buffer = reallocateUnsafe(buffer, length << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = length;\n  }\n\n  every(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (!callbackfn(LOAD<T>(this.buffer_, index), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (element: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (predicate(LOAD<T>(this.buffer_, index), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator("[]")\n  private __get(index: i32): T {\n    var buffer = this.buffer_;\n    return <u32>index < <u32>(buffer.byteLength >>> alignof<T>())\n      ? LOAD<T>(buffer, index)\n      : <T>unreachable();\n  }\n\n  @operator("{}")\n  private __unchecked_get(index: i32): T {\n    return LOAD<T>(this.buffer_, index);\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: T): void {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>index >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>index >= <u32>MAX_LENGTH) throw new Error("Invalid array length");\n      buffer = reallocateUnsafe(buffer, (index + 1) << alignof<T>());\n      this.buffer_ = buffer;\n      this.length_ = index + 1;\n    }\n    STORE<T>(buffer, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  @operator("{}=")\n  private __unchecked_set(index: i32, value: T): void {\n    STORE<T>(this.buffer_, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var buffer = this.buffer_;\n    var len    = this.length_;\n\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n\n    if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          changetype<usize>(buffer) + start + HEADER_SIZE,\n          <u8>value,\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        STORE<T>(buffer, start, value);\n      }\n    }\n    return this;\n  }\n\n  @inline\n  includes(searchElement: T, fromIndex: i32 = 0): bool {\n    return this.indexOf(searchElement, fromIndex) >= 0;\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var buffer = this.buffer_;\n    while (fromIndex < length) {\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex; // no need to clamp\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var buffer = this.buffer_;\n    while (fromIndex >= 0) {                           // ^\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(element: T): i32 {\n    var length = this.length_;\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error("Invalid array length");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = newLength;\n    STORE<T>(buffer, length, element);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  concat(items: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, items.length_, items === null);\n    var outLen = thisLen + otherLen;\n    var out = new Array<T>(outLen);\n\n    if (thisLen) {\n      memory.copy(\n        changetype<usize>(out.buffer_)  + HEADER_SIZE,\n        changetype<usize>(this.buffer_) + HEADER_SIZE,\n        <usize>thisLen << alignof<T>()\n      );\n    }\n    if (otherLen) {\n      memory.copy(\n        changetype<usize>(out.buffer_)   + HEADER_SIZE + (<usize>thisLen << alignof<T>()),\n        changetype<usize>(items.buffer_) + HEADER_SIZE,\n        <usize>otherLen << alignof<T>()\n      );\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var buffer = this.buffer_;\n    var len = this.length_;\n\n        end   = min<i32>(end, len);\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    if (from < to && to < (from + count)) {\n      from += count - 1;\n      to   += count - 1;\n      while (count) {\n        STORE<T>(buffer, to, LOAD<T>(buffer, from));\n        --from, --to, --count;\n      }\n    } else {\n      memory.copy(\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>to << alignof<T>()),\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>from << alignof<T>()),\n        <usize>count << alignof<T>()\n      );\n    }\n    return this;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError("Array is empty");\n    var element = LOAD<T>(this.buffer_, --length);\n    this.length_ = length;\n    return element;\n  }\n\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      callbackfn(LOAD<T>(this.buffer_, index), index, this);\n    }\n  }\n\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var length = this.length_;\n    var result = new Array<U>(length);\n    var buffer = result.buffer_;\n    for (let index = 0; index < min(length, this.length_); ++index) {\n      STORE<U>(buffer, index, callbackfn(LOAD<T>(this.buffer_, index), index, this));\n    }\n    return result;\n  }\n\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = new Array<T>();\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      let value = LOAD<T>(this.buffer_, index);\n      if (callbackfn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      accum = callbackfn(accum, LOAD<T>(this.buffer_, index), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = this.length_ - 1; index >= 0; --index) {\n      accum = callbackfn(accum, LOAD<T>(this.buffer_, index), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError("Array is empty");\n    var buffer = this.buffer_;\n    var element = LOAD<T>(buffer, 0);\n    var lastIndex = length - 1;\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    STORE<T>(buffer, lastIndex, <T>null);\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (callbackfn(LOAD<T>(this.buffer_, index), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(element: T): i32 {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var length = this.length_;\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error("Invalid array length");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      capacity = buffer.byteLength >>> alignof<T>();\n      this.buffer_ = buffer;\n    }\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      changetype<usize>(buffer) + HEADER_SIZE,\n      <usize>(capacity - 1) << alignof<T>()\n    );\n    STORE<T>(buffer, 0, element);\n    this.length_ = newLength;\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var len = this.length_;\n    begin = begin < 0 ? max(begin + len, 0) : min(begin, len);\n    end = end < 0 ? max(end + len, 0) : min(end, len);\n    len = max(end - begin, 0);\n    var sliced = new Array<T>(len);\n    if (len) {\n      memory.copy(\n        changetype<usize>(sliced.buffer_) + HEADER_SIZE,\n        changetype<usize>(this.buffer_) + HEADER_SIZE + (<usize>begin << alignof<T>()),\n        <usize>len << alignof<T>()\n      );\n    }\n    return sliced;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var length  = this.length_;\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\n    var buffer  = this.buffer_;\n    var spliced = new Array<T>(deleteCount);\n    var source  = changetype<usize>(buffer) + HEADER_SIZE + (<usize>start << alignof<T>());\n    memory.copy(\n      changetype<usize>(spliced.buffer_) + HEADER_SIZE,\n      source,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (length != offset) {\n      memory.copy(\n        source,\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>offset << alignof<T>()),\n        <usize>(length - offset) << alignof<T>()\n      );\n    }\n    this.length_ = length - deleteCount;\n    return spliced;\n  }\n\n  reverse(): Array<T> {\n    var buffer = this.buffer_;\n    for (let front = 0, back = this.length_ - 1; front < back; ++front, --back) {\n      let temp = LOAD<T>(buffer, front);\n      STORE<T>(buffer, front, LOAD<T>(buffer, back));\n      STORE<T>(buffer, back, temp);\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    // TODO remove this when flow will allow trackcing null\n    assert(comparator); // The comparison function must be a function\n\n    var length = this.length_;\n    if (length <= 1) return this;\n    var buffer = this.buffer_;\n    if (length == 2) {\n      let a = LOAD<T>(buffer, 1); // a = arr[1]\n      let b = LOAD<T>(buffer, 0); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        STORE<T>(buffer, 1, b);   // arr[1] = b;\n        STORE<T>(buffer, 0, a);   // arr[0] = a;\n      }\n      return this;\n    }\n    SORT<T>(buffer, 0, length, comparator);\n    return this;\n  }\n\n  join(separator: string = ","): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return "";\n    var result = "";\n    var value: T;\n    var buffer = this.buffer_;\n    var sepLen = separator.length;\n    var hasSeparator = sepLen != 0;\n    if (value instanceof bool) {\n      if (!lastIndex) return select<string>("true", "false", LOAD<T,bool>(buffer, 0));\n\n      let valueLen = 5; // max possible length of element len("false")\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T,bool>(buffer, i);\n        valueLen = 4 + <i32>(!value);\n        copyUnsafeString(result, offset, select<string>("true", "false", value), 0, valueLen);\n        offset += valueLen;\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T,bool>(buffer, lastIndex);\n      valueLen = 4 + <i32>(!value);\n      copyUnsafeString(result, offset, select<string>("true", "false", value), 0, valueLen);\n      offset += valueLen;\n\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isInteger<T>()) {\n      if (!lastIndex) return changetype<string>(itoa<T>(LOAD<T>(buffer, 0)));\n\n      const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + <i32>isSigned<T>();\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T>(buffer, lastIndex);\n      offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isFloat<T>()) {\n      if (!lastIndex) return changetype<string>(dtoa(LOAD<T,f64>(buffer, 0)));\n\n      const valueLen = MAX_DOUBLE_LENGTH;\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T,f64>(buffer, i);\n        offset += dtoa_stream(changetype<usize>(result), offset, value);\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T,f64>(buffer, lastIndex);\n      offset += dtoa_stream(changetype<usize>(result), offset, value);\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isString<T>()) {\n      if (!lastIndex) return LOAD<string>(buffer, 0);\n\n      let estLen = 0;\n      for (let i = 0, len = lastIndex + 1; i < len; ++i) {\n        estLen += LOAD<string>(buffer, i).length;\n      }\n      let offset = 0;\n      let result = allocateUnsafeString(estLen + sepLen * lastIndex);\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<string>(buffer, i);\n        if (value) {\n          let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\n          copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\n          offset += valueLen;                                   // tslint:disable-line:no-unsafe-any\n        }\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<string>(buffer, lastIndex);\n      if (value) {\n        let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\n        copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\n      }\n      return result;\n    } else if (isArray<T>()) {\n      if (!lastIndex) {\n        value = LOAD<T>(buffer, 0);\n        return value ? value.join(separator) : ""; // tslint:disable-line:no-unsafe-any\n      }\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\n        if (hasSeparator) result += separator;\n      }\n      value = LOAD<T>(buffer, lastIndex);\n      if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\n      return result;\n    } else if (isReference<T>()) { // References\n      if (!lastIndex) return "[object Object]";\n      const valueLen = 15; // max possible length of element len("[object Object]")\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        if (value) {\n          copyUnsafeString(result, offset, changetype<String>("[object Object]"), 0, valueLen);\n          offset += valueLen;\n        }\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      if (LOAD<T>(buffer, lastIndex)) {\n        copyUnsafeString(result, offset, changetype<String>("[object Object]"), 0, valueLen);\n        offset += valueLen;\n      }\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else {\n      assert(false); // Unsupported generic typename\n    }\n  }\n\n  @inline\n  toString(): string {\n    return this.join();\n  }\n\n  private __gc(): void {\n    var buffer = this.buffer_;\n    __gc_mark(changetype<usize>(buffer)); // tslint:disable-line\n    if (isManaged<T>()) {\n      let offset: usize = 0;\n      let end = <usize>this.length_ << alignof<usize>();\n      while (offset < end) {\n        __gc_mark(load<usize>(changetype<usize>(buffer) + offset, HEADER_SIZE)); // tslint:disable-line\n        offset += sizeof<usize>();\n      }\n    }\n  }\n}\n',arraybuffer:'import {\n  HEADER_SIZE,\n  MAX_BLENGTH,\n  allocateUnsafe\n} from "./internal/arraybuffer";\n\nimport {\n  Uint8ClampedArray,\n  Uint8Array,\n  Int8Array,\n  Uint16Array,\n  Int16Array,\n  Uint32Array,\n  Int32Array,\n  Uint64Array,\n  Int64Array\n} from "./typedarray";\n\nimport {\n  DataView\n} from "./dataview";\n\n@sealed\nexport class ArrayBuffer {\n\n  readonly byteLength: i32; // capped to [0, MAX_LENGTH]\n\n  @inline static isView<T>(value: T): bool {\n    if (value === null) return false;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  // @unsafe\n  @inline get data(): usize { return changetype<usize>(this) + HEADER_SIZE; }\n\n  constructor(length: i32, unsafe: bool = false) {\n    if (<u32>length > <u32>MAX_BLENGTH) throw new RangeError("Invalid array buffer length");\n    var buffer = allocateUnsafe(length);\n    if (!unsafe) memory.fill(changetype<usize>(buffer) + HEADER_SIZE, 0, <usize>length);\n    return buffer;\n  }\n\n  slice(begin: i32 = 0, end: i32 = MAX_BLENGTH): ArrayBuffer {\n    var len = this.byteLength;\n    begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n    end = end < 0 ? max(len + end, 0) : min(end, len);\n    len = max(end - begin, 0);\n    var buffer = allocateUnsafe(len);\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + begin,\n      len\n    );\n    return buffer;\n  }\n\n  toString(): string {\n    return "[object ArrayBuffer]";\n  }\n}\n',"bindings/Date":"export declare function UTC(\n  // NOTE: Using i32 below saves us a f64.convert_s instruction and moves the responsibility for\n  // converting the value to the WASM/JS boundary.\n  year: i32,\n  month: i32,\n  day: i32,\n  hour: i32,\n  minute: i32,\n  second: i32,\n  millisecond: f64\n): f64;\nexport declare function now(): f64;\n","bindings/Math":"export declare const E: f64;\nexport declare const LN2: f64;\nexport declare const LN10: f64;\nexport declare const LOG2E: f64;\nexport declare const LOG10E: f64;\nexport declare const PI: f64;\nexport declare const SQRT1_2: f64;\nexport declare const SQRT2: f64;\n\nexport declare function abs(x: f64): f64;\nexport declare function acos(x: f64): f64;\nexport declare function acosh(x: f64): f64;\nexport declare function asin(x: f64): f64;\nexport declare function asinh(x: f64): f64;\nexport declare function atan(x: f64): f64;\nexport declare function atan2(y: f64, x: f64): f64;\nexport declare function atanh(x: f64): f64;\nexport declare function cbrt(x: f64): f64;\nexport declare function ceil(x: f64): f64;\nexport declare function clz32(x: f64): f64;\nexport declare function cos(x: f64): f64;\nexport declare function cosh(x: f64): f64;\nexport declare function exp(x: f64): f64;\nexport declare function expm1(x: f64): f64;\nexport declare function floor(x: f64): f64;\nexport declare function fround(x: f64): f32;\nexport declare function hypot(value1: f64, value2: f64): f64; // TODO: rest\nexport declare function imul(a: f64, b: f64): f64;\nexport declare function log(x: f64): f64;\nexport declare function log10(x: f64): f64;\nexport declare function log1p(x: f64): f64;\nexport declare function log2(x: f64): f64;\nexport declare function max(value1: f64, value2: f64): f64; // TODO: rest\nexport declare function min(value1: f64, value2: f64): f64; // TODO: rest\nexport declare function pow(base: f64, exponent: f64): f64;\nexport declare function random(): f64;\nexport declare function round(x: f64): f64;\nexport declare function sign(x: f64): f64;\nexport declare function sin(x: f64): f64;\nexport declare function sinh(x: f64): f64;\nexport declare function sqrt(x: f64): f64;\nexport declare function tan(x: f64): f64;\nexport declare function tanh(x: f64): f64;\nexport declare function trunc(x: f64): f64;\n","bindings/wasi_unstable":"// see: https://wasi.dev\n\n/* tslint:disable:max-line-length */\n\n// helper types to be more explicit\ntype char = u8;\ntype ptr<T> = usize; // all pointers are usize'd\ntype struct<T> = T;  // structs are references already in AS\n\n/** Read command-line argument data. */\nexport declare function args_get(\n  /** Input: Pointer to a buffer to write the argument pointers. */\n  argv: ptr<ptr<char>>,\n  /** Input: Pointer to a buffer to write the argument string data. */\n  argv_buf: ptr<char>\n): errno;\n\n/** Return command-line argument data sizes. */\nexport declare function args_sizes_get(\n  /** Output: Number of arguments. */\n  argc: ptr<usize>,\n  /** Output: Size of the argument string data. */\n  argv_buf_size: ptr<usize>\n): errno;\n\n/** Return the resolution of a clock. */\nexport declare function clock_res_get(\n  /** Input: The clock for which to return the resolution. */\n  clock: clockid,\n  /** Output: The resolution of the clock. */\n  resolution: ptr<timestamp>\n): errno;\n\n/** Return the time value of a clock. */\nexport declare function clock_time_get(\n  /** Input: Cock for which to return the time. */\n  clock: clockid,\n  /** Input: Maximum lag (exclusive) that the returned time value may have, compared to its actual value. */\n  precision: timestamp,\n  /** Output: Time value of the clock. */\n  time: ptr<timestamp>\n): errno;\n\n/** Read environment variable data. */\nexport declare function environ_get(\n  /** Input: Pointer to a buffer to write the environment variable pointers. */\n  environ: ptr<usize>,\n  /** Input: Pointer to a buffer to write the environment variable string data. */\n  environ_buf: usize\n): errno;\n\n/** Return command-line argument data sizes. */\nexport declare function environ_sizes_get(\n  /** Output: The number of environment variables. */\n  environ_count: ptr<usize>,\n  /** Output: The size of the environment variable string data. */\n  environ_buf_size: ptr<usize>\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\nexport declare function fd_advise(\n  /** Input: The file descriptor for the file for which to provide file advisory information. */\n  fd: fd,\n  /** Input: The offset within the file to which the advisory applies. */\n  offset: filesize,\n  /** Input: The length of the region to which the advisory applies. */\n  len: filesize,\n  /** Input: The advice. */\n  advice: advice\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\nexport declare function fd_allocate(\n  /** Input: The file descriptor for the file in which to allocate space. */\n  fd: fd,\n  /** Input: The offset at which to start the allocation. */\n  offset: filesize,\n  /** Input: The length of the area that is allocated. */\n  len: filesize\n): errno;\n\n/** Close a file descriptor. */\nexport declare function fd_close(\n  /** Input: The file descriptor to close. */\n  fd: fd\n): errno;\n\n/** Synchronize the data of a file to disk. */\nexport declare function fd_datasync(\n  /** Input: The file descriptor of the file to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Get the attributes of a file descriptor. */\nexport declare function fd_fdstat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file descriptor's attributes are stored. */\n  buf: struct<fdstat>\n): errno;\n\n/** Adjust the flags associated with a file descriptor. */\nexport declare function fd_fdstat_set_flags(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the file descriptor flags. */\n  flags: fdflags\n): errno;\n\n/** Adjust the rights associated with a file descriptor. */\nexport declare function fd_fdstat_set_rights(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_base: rights,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_inheriting: rights\n): errno;\n\n/** Return the attributes of an open file. */\nexport declare function fd_filestat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros. */\nexport declare function fd_filestat_set_size(\n  /** Input: A file descriptor for the file to adjust. */\n  fd: fd,\n  /** Input: The desired file size. */\n  size: filesize\n): errno;\n\n/** Adjust the timestamps of an open file or directory. */\nexport declare function fd_filestat_set_times(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Read from a file descriptor, without using and updating the file descriptor's offset. */\nexport declare function fd_pread(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors in which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors in which to store data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to read. */\n  offset: filesize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\nexport declare function fd_prestat_get(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: The buffer where the description is stored. */\n  buf: struct<prestat>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\nexport declare function fd_prestat_dir_name(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: Buffer into which to write the preopened directory name. */\n  path: ptr<char>,\n  /** Input: Length of the buffer into which to write the preopened directory name. */\n  path_len: usize\n): errno;\n\n/** Write to a file descriptor, without using and updating the file descriptor's offset. */\nexport declare function fd_pwrite(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to write. */\n  offset: filesize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/** Read from a file descriptor. */\nexport declare function fd_read(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors to which to store data. */\n  iovs_len: usize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Read directory entries from a directory. */\nexport declare function fd_readdir(\n  /** Input: Directory from which to read the directory entries. */\n  fd: fd,\n  /** Input: Buffer where directory entries are stored. */\n  buf: ptr<struct<dirent>>,\n  /** Input: Length of the buffer where directory entries are stored. */\n  buf_len: usize,\n  /** Input: Location within the directory to start reading. */\n  cookie: dircookie,\n  /** Output: Number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Atomically replace a file descriptor by renumbering another file descriptor. */\nexport declare function fd_renumber(\n  /** Input: The file descriptor to renumber. */\n  from: fd,\n  /** Input: The file descriptor to overwrite. */\n  to: fd\n): errno;\n\n/** Move the offset of a file descriptor. */\nexport declare function fd_seek(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The number of bytes to move. */\n  offset: filedelta,\n  /** Input: The base from which the offset is relative. */\n  whence: whence,\n  /** Output: The new offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Synchronize the data and metadata of a file to disk. */\nexport declare function fd_sync(\n  /** Input: The file descriptor of the file containing the data and metadata to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Return the current offset of a file descriptor. */\nexport declare function fd_tell(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Output: The current offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Write to a file descriptor. */\nexport declare function fd_write(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/* Create a directory. */\nexport declare function path_create_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path at which to create the directory. */\n  path: ptr<char>,\n  /** Input: The path at which to create the directory. */\n  path_len: usize\n): errno;\n\n/** Return the attributes of a file or directory. */\nexport declare function path_filestat_get(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to inspect. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to inspect. */\n  path_len: usize,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the timestamps of a file or directory. */\nexport declare function path_filestat_set_times(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to operate on. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to operate on. */\n  path_len: usize,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Create a hard link. */\nexport declare function path_link(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  old_flags: lookupflags,\n  /** Input: The source path from which to link. */\n  old_path: ptr<char>,\n  /** Input: The source path from which to link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path at which to create the hard link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the hard link. */\n  new_path_len: usize\n): errno;\n\n/** Open a file or directory. */\nexport declare function path_open(\n  /** Input: The working directory at which the resolution of the path starts. */\n  dirfd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  dirflags: lookupflags,\n  /** Input: The path of the file or directory to open. */\n  path: ptr<char>,\n  /** Input: The length of the path of the file or directory to open. */\n  path_len: usize,\n  /** Input: The method by which to open the file. */\n  oflags: oflags,\n  /** Input: The initial base rights that apply to operations using the file descriptor itself. */\n  fs_rights_base: rights,\n  /** Input: The initial inheriting rights that apply to file descriptors derived from it. */\n  fs_rights_inheriting: rights,\n  /** Input: The initial flags of the file descriptor. */\n  fs_flags: fdflags,\n  /** Output: The file descriptor of the file that has been opened. */\n  fd: ptr<fd>\n): errno;\n\n/** Read the contents of a symbolic link. */\nexport declare function path_readlink(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path of the symbolic link from which to read. */\n  path: ptr<char>,\n  /** Input: The length of the path of the symbolic link from which to read. */\n  path_len: usize,\n  /** Input: The buffer to which to write the contents of the symbolic link. */\n  buf: ptr<char>,\n  /** Input: The length of the buffer to which to write the contents of the symbolic link. */\n  buf_len: usize,\n  /** Output: The number of bytes placed in the buffer. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Remove a directory. */\nexport declare function path_remove_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a directory to remove. */\n  path: ptr<char>,\n  /** Input: The length of the path to a directory to remove. */\n  path_len: usize\n): errno;\n\n/** Rename a file or directory. */\nexport declare function path_rename(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: The source path of the file or directory to rename. */\n  old_path: ptr<char>,\n  /** Input: The length of the source path of the file or directory to rename. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path to which to rename the file or directory. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path to which to rename the file or directory. */\n  new_path_len: usize\n): errno;\n\n/** Create a symbolic link. */\nexport declare function path_symlink(\n  /** Input: The contents of the symbolic link. */\n  old_path: ptr<char>,\n  /** Input: The length of the contents of the symbolic link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The destination path at which to create the symbolic link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the symbolic link. */\n  new_path_len: usize\n): errno;\n\n/** Unlink a file. */\nexport declare function path_unlink_file(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a file to unlink. */\n  path: ptr<char>,\n  /** Input: The length of the path to a file to unlink. */\n  path_len: usize\n): errno;\n\n/** Concurrently poll for the occurrence of a set of events. */\nexport declare function poll_oneoff(\n  /** Input: The events to which to subscribe. */\n  in_: ptr<struct<subscription>>,\n  /** Input: The events that have occurred. */\n  out: ptr<struct<event>>,\n  /** Input: Both the number of subscriptions and events. */\n  nsubscriptions: usize,\n  /** Output: The number of events stored. */\n  nevents: ptr<usize>\n): errno;\n\n/** Terminate the process normally. An exit code of 0 indicates successful termination of the program. The meanings of other values is dependent on the environment. */\nexport declare function proc_exit(\n  /** Input: The exit code returned by the process. */\n  rval: u32\n): void;\n\n/** Send a signal to the process of the calling thread. */\nexport declare function proc_raise(\n  /** Input: The signal condition to trigger. */\n  sig: signal\n): errno;\n\n/** Write high-quality random data into a buffer. */\nexport declare function random_get(\n  /** Input: The buffer to fill with random data. */\n  buf: usize,\n  /** Input: The length of the buffer to fill with random data. */\n  buf_len: usize\n): errno;\n\n/** Temporarily yield execution of the calling thread. */\nexport declare function sched_yield(): errno;\n\n/** Receive a message from a socket. */\nexport declare function sock_recv(\n  /** Input: The socket on which to receive data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  ri_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to store data. */\n  ri_data_len: usize,\n  /** Input: Message flags. */\n  ri_flags: riflags,\n  /** Output: Number of bytes stored in `ri_data`. */\n  ro_datalen: ptr<usize>,\n  /** Output: Message flags. */\n  ro_flags: ptr<roflags>\n): errno;\n\n/** Send a message on a socket. */\nexport declare function sock_send(\n  /** Input: The socket on which to send data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to retrieve data */\n  si_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to retrieve data */\n  si_data_len: usize,\n  /** Input: Message flags. */\n  si_flags: siflags,\n  /** Output: Number of bytes transmitted. */\n  so_datalen: ptr<usize>\n): errno;\n\n/** Shut down socket send and receive channels. */\nexport declare function sock_shutdown(\n  /** Input: The socket on which to shutdown channels. */\n  sock: fd,\n  /** Input: Which channels on the socket to shut down. */\n  how: sdflags\n): errno;\n\n// === Types ======================================================================================\n\n/** File or memory access pattern advisory information. */\nexport namespace advice {\n  /** The application has no advice to give on its behavior with respect to the specified data. */\n  // @ts-ignore: decorator\n  @inline\n  export const NORMAL: advice = 0;\n  /** The application expects to access the specified data sequentially from lower offsets to higher offsets. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEQUENTIAL : advice = 1;\n  /** The application expects to access the specified data in a random order. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANDOM: advice = 2;\n  /** The application expects to access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const WILLNEED: advice = 3;\n  /** The application expects that it will not access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const DONTNEED: advice = 4;\n  /** The application expects to access the specified data once and then not reuse it thereafter. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOREUSE: advice = 5;\n}\nexport type advice = u8;\n\n/** Identifiers for clocks. */\nexport namespace clockid {\n  /** The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z. */\n  // @ts-ignore: decorator\n  @inline\n  export const REALTIME: clockid = 0;\n  /** The store-wide monotonic clock. Absolute value has no meaning. */\n  // @ts-ignore: decorator\n  @inline\n  export const MONOTONIC: clockid = 1;\n  /** The CPU-time clock associated with the current process. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROCESS_CPUTIME_ID: clockid = 2;\n  /** The CPU-time clock associated with the current thread. */\n  // @ts-ignore: decorator\n  @inline\n  export const THREAD_CPUTIME_ID: clockid = 3;\n}\nexport type clockid = u32;\n\n/** Identifier for a device containing a file system. Can be used in combination with `inode` to uniquely identify a file or directory in the filesystem. */\nexport type device = u64;\n\n/** A reference to the offset of a directory entry. */\nexport type dircookie = u64;\n\n/** A directory entry. */\n@unmanaged export class dirent {\n  /** The offset of the next directory entry stored in this directory. */\n  next: dircookie;\n  /** The serial number of the file referred to by this directory entry. */\n  ino: inode;\n  /** The length of the name of the directory entry. */\n  namlen: u32;\n  /** The type of the file referred to by this directory entry. */\n  type: filetype;\n  private __padding0: u16;\n}\n\n/** Error codes returned by functions. */\nexport namespace errno {\n  /** No error occurred. System call completed successfully. */\n  // @ts-ignore: decorator\n  @inline\n  export const SUCCESS: errno = 0;\n  /** Argument list too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const TOOBIG: errno = 1;\n  /** Permission denied. */\n  // @ts-ignore: decorator\n  @inline\n  export const ACCES: errno = 2;\n  /** Address in use. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRINUSE: errno = 3;\n  /** Address not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRNOTAVAIL: errno = 4;\n  /** Address family not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const AFNOSUPPORT: errno = 5;\n  /** Resource unavailable, or operation would block. */\n  // @ts-ignore: decorator\n  @inline\n  export const AGAIN: errno = 6;\n  /** Connection already in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALREADY: errno = 7;\n  /** Bad file descriptor. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADF: errno = 8;\n  /** Bad message. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADMSG: errno = 9;\n  /** Device or resource busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUSY: errno = 10;\n  /** Operation canceled. */\n  // @ts-ignore: decorator\n  @inline\n  export const CANCELED: errno = 11;\n  /** No child processes. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHILD: errno = 12;\n  /** Connection aborted. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNABORTED: errno = 13;\n  /** Connection refused. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNREFUSED: errno = 14;\n  /** Connection reset. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNRESET: errno = 15;\n  /** Resource deadlock would occur. */\n  // @ts-ignore: decorator\n  @inline\n  export const DEADLK: errno = 16;\n  /** Destination address required. */\n  // @ts-ignore: decorator\n  @inline\n  export const DESTADDRREQ: errno = 17;\n  /** Mathematics argument out of domain of function. */\n  // @ts-ignore: decorator\n  @inline\n  export const DOM: errno = 18;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const DQUOT: errno = 19;\n  /** File exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXIST: errno = 20;\n  /** Bad address. */\n  // @ts-ignore: decorator\n  @inline\n  export const FAULT: errno = 21;\n  /** File too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const FBIG: errno = 22;\n  /** Host is unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const HOSTUNREACH: errno = 23;\n  /** Identifier removed. */\n  // @ts-ignore: decorator\n  @inline\n  export const IDRM: errno = 24;\n  /** Illegal byte sequence. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILSEQ: errno = 25;\n  /** Operation in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const INPROGRESS: errno = 26;\n  /** Interrupted function. */\n  // @ts-ignore: decorator\n  @inline\n  export const INTR: errno = 27;\n  /** Invalid argument. */\n  // @ts-ignore: decorator\n  @inline\n  export const INVAL: errno = 28;\n  /** I/O error. */\n  // @ts-ignore: decorator\n  @inline\n  export const IO: errno = 29;\n  /** Socket is connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISCONN: errno = 30;\n  /** Is a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISDIR: errno = 31;\n  /** Too many levels of symbolic links. */\n  // @ts-ignore: decorator\n  @inline\n  export const LOOP: errno = 32;\n  /** File descriptor value too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MFILE: errno = 33;\n  /** Too many links. */\n  // @ts-ignore: decorator\n  @inline\n  export const MLINK: errno = 34;\n  /** Message too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MSGSIZE: errno = 35;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const MULTIHOP: errno = 36;\n  /** Filename too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const NAMETOOLONG: errno = 37;\n  /** Network is down. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETDOWN: errno = 38;\n  /** Connection aborted by network. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETRESET: errno = 39;\n  /** Network unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETUNREACH: errno = 40;\n  /** Too many files open in system. */\n  // @ts-ignore: decorator\n  @inline\n  export const NFILE: errno = 41;\n  /** No buffer space available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOBUFS: errno = 42;\n  /** No such device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NODEV: errno = 43;\n  /** No such file or directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOENT: errno = 44;\n  /** Executable file format error. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOEXEC: errno = 45;\n  /** No locks available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLCK: errno = 46;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLINK: errno = 47;\n  /** Not enough space. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMEM: errno = 48;\n  /** No message of the desired type. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMSG: errno = 49;\n  /** Protocol not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOPROTOOPT: errno = 50;\n  /** No space left on device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSPC: errno = 51;\n  /** Function not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSYS: errno = 52;\n  /** The socket is not connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCONN: errno = 53;\n  /** Not a directory or a symbolic link to a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTDIR: errno = 54;\n  /** Directory not empty. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTEMPTY: errno = 55;\n  /** State not recoverable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTRECOVERABLE: errno = 56;\n  /** Not a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSOCK: errno = 57;\n  /** Not supported, or operation not supported on socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSUP: errno = 58;\n  /** Inappropriate I/O control operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTTY: errno = 59;\n  /** No such device or address. */\n  // @ts-ignore: decorator\n  @inline\n  export const NXIO: errno = 60;\n  /** Value too large to be stored in data type. */\n  // @ts-ignore: decorator\n  @inline\n  export const OVERFLOW: errno = 61;\n  /** Previous owner died. */\n  // @ts-ignore: decorator\n  @inline\n  export const OWNERDEAD: errno = 62;\n  /** Operation not permitted. */\n  // @ts-ignore: decorator\n  @inline\n  export const PERM: errno = 63;\n  /** Broken pipe. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: errno = 64;\n  /** Protocol error. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTO: errno = 65;\n  /** Protocol not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTONOSUPPORT: errno = 66;\n  /** Protocol wrong type for socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTOTYPE: errno = 67;\n  /** Result too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANGE: errno = 68;\n  /** Read-only file system. */\n  // @ts-ignore: decorator\n  @inline\n  export const ROFS: errno = 69;\n  /** Invalid seek. */\n  // @ts-ignore: decorator\n  @inline\n  export const SPIPE: errno = 70;\n  /** No such process. */\n  // @ts-ignore: decorator\n  @inline\n  export const SRCH: errno = 71;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const STALE: errno = 72;\n  /** Connection timed out. */\n  // @ts-ignore: decorator\n  @inline\n  export const TIMEDOUT: errno = 73;\n  /** Text file busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const TXTBSY: errno = 74;\n  /** Cross-device link. */\n  // @ts-ignore: decorator\n  @inline\n  export const XDEV: errno = 75;\n  /** Extension: Capabilities insufficient. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCAPABLE: errno = 76;\n}\nexport type errno = u16;\n\n/** An event that occurred. */\n@unmanaged export abstract class event {\n  /** User-provided value that got attached to `subscription#userdata`. */\n  userdata: userdata;\n  /** If non-zero, an error that occurred while processing the subscription request. */\n  error: errno;\n  /* The type of the event that occurred. */\n  type: eventtype;\n  private __padding0: u16;\n}\n\n/** An event that occurred when type is `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\n@unmanaged export class rwevent extends event {\n  /* The number of bytes available for reading or writing. */\n  nbytes: filesize;\n  /* The state of the file descriptor. */\n  flags: eventrwflags;\n  private __padding1: u32;\n}\n\n/** The state of the file descriptor subscribed to with `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\nexport namespace eventrwflags {\n  /** The peer of this socket has closed or disconnected. */\n  // @ts-ignore: decorator\n  @inline\n  export const HANGUP: eventrwflags = 1;\n}\nexport type eventrwflags = u16;\n\n/** Type of a subscription to an event or its occurrence. */\nexport namespace eventtype {\n  /** The time value of clock has reached the timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const CLOCK: eventtype = 0;\n  /** File descriptor has data available for reading. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: eventtype = 1;\n  /** File descriptor has capacity available for writing */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: eventtype = 2;\n}\nexport type eventtype = u8;\n\n/** Exit code generated by a process when exiting. */\nexport type exitcode = u32;\n\n/** A file descriptor number. */\nexport type fd = u32;\n\n/** File descriptor flags. */\nexport namespace fdflags {\n  /** Append mode: Data written to the file is always appended to the file's end. */\n  // @ts-ignore: decorator\n  @inline\n  export const APPEND: fdflags = 1;\n  /** Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized. */\n  // @ts-ignore: decorator\n  @inline\n  export const DSYNC: fdflags = 2;\n  /** Non-blocking mode. */\n  // @ts-ignore: decorator\n  @inline\n  export const NONBLOCK: fdflags = 4;\n  /** Synchronized read I/O operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RSYNC: fdflags = 8;\n  /** Write according to synchronized I/O file integrity completion. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYNC: fdflags = 16;\n}\nexport type fdflags = u16;\n\n/** File descriptor attributes. */\n@unmanaged export class fdstat {\n  /** File type. */\n  filetype: filetype;\n  /** File descriptor flags. */\n  flags: fdflags;\n  /** Rights that apply to this file descriptor. */\n  rights_base: rights;\n  /** Maximum set of rights that may be installed on new file descriptors that are created through this file descriptor, e.g., through `path_open`. */\n  rights_inheriting: rights;\n}\n\n/** Relative offset within a file. */\nexport type filedelta = i64;\n\n/** Non-negative file size or length of a region within a file. */\nexport type filesize = u64;\n\n/** File attributes. */\n@unmanaged export class filestat {\n  /** Device ID of device containing the file. */\n  dev: device;\n  /** File serial number. */\n  ino: inode;\n  /** File type. */\n  filetype: filetype;\n  /** Number of hard links to the file. */\n  nlink: linkcount;\n  /** For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link. */\n  size: filesize;\n  /** Last data access timestamp. */\n  atim: timestamp;\n  /** Last data modification timestamp. */\n  mtim: timestamp;\n  /** Last file status change timestamp. */\n  ctim: timestamp;\n}\n\n/** The type of a file descriptor or file. */\nexport namespace filetype {\n  /** The type of the file descriptor or file is unknown or is different from any of the other types specified. */\n  // @ts-ignore: decorator\n  @inline\n  export const UNKNOWN: filetype = 0;\n  /** The file descriptor or file refers to a block device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const BLOCK_DEVICE: filetype = 1;\n  /** The file descriptor or file refers to a character device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHARACTER_DEVICE: filetype = 2;\n  /** The file descriptor or file refers to a directory inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: filetype = 3;\n  /** The file descriptor or file refers to a regular file inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const REGULAR_FILE: filetype = 4;\n  /** The file descriptor or file refers to a datagram socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_DGRAM: filetype = 5;\n  /** The file descriptor or file refers to a byte-stream socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_STREAM: filetype = 6;\n  /** The file refers to a symbolic link inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMBOLIC_LINK: filetype = 7;\n}\nexport type filetype = u8;\n\n/** Which file time attributes to adjust. */\nexport namespace fstflags {\n  /** Adjust the last data access timestamp to the value stored in `filestat#st_atim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM: fstflags = 1;\n  /** Adjust the last data access timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM_NOW: fstflags = 2;\n  /** Adjust the last data modification timestamp to the value stored in `filestat#st_mtim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM: fstflags = 4;\n  /** Adjust the last data modification timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM_NOW: fstflags = 8;\n}\nexport type fstflags = u16;\n\n/** File serial number that is unique within its file system. */\nexport type inode = u64;\n\n/** A region of memory for scatter/gather reads. */\n@unmanaged export class iovec {\n  /** The address of the buffer to be filled. */\n  buf: usize;\n  /** The length of the buffer to be filled. */\n  buf_len: usize;\n}\n\n/** Number of hard links to an inode. */\nexport type linkcount = u32;\n\n/** Flags determining the method of how paths are resolved. */\nexport namespace lookupflags {\n  /** As long as the resolved path corresponds to a symbolic link, it is expanded. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMLINK_FOLLOW: lookupflags = 1;\n}\nexport type lookupflags = u32;\n\n/** Open flags. */\nexport namespace oflags {\n  /** Create file if it does not exist. */\n  // @ts-ignore: decorator\n  @inline\n  export const CREAT: oflags = 1;\n  /** Fail if not a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: oflags = 2;\n  /** Fail if file already exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXCL: oflags = 4;\n  /** Truncate file to size 0. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRUNC: oflags = 8;\n}\nexport type oflags = u16;\n\n// TODO: undocumented\nexport namespace preopentype {\n  // @ts-ignore: decorator\n  @inline\n  export const DIR: preopentype = 0;\n}\nexport type preopentype = u8;\n\n// TODO: undocumented\nexport abstract class prestat {\n  type: preopentype;\n}\n\n// TODO: undocumented\nexport class dirprestat extends prestat {\n  name_len: usize;\n}\n\n/** Flags provided to `sock_recv`. */\nexport namespace riflags {\n  /** Returns the message without removing it from the socket's receive queue. */\n  // @ts-ignore: decorator\n  @inline\n  export const PEEK: riflags = 1;\n  /** On byte-stream sockets, block until the full amount of data can be returned. */\n  // @ts-ignore: decorator\n  @inline\n  export const WAITALL: riflags = 2;\n}\nexport type riflags = u16;\n\n/** File descriptor rights, determining which actions may be performed. */\nexport namespace rights {\n  /** The right to invoke `fd_datasync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_DATASYNC: rights = 1;\n  /** The right to invoke `fd_read` and `sock_recv`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: rights = 2;\n  /** The right to invoke `fd_seek`. This flag implies `rights.FD_TELL`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SEEK: rights = 4;\n  /** The right to invoke `fd_fdstat_set_flags`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FDSTAT_SET_FLAGS: rights = 8;\n  /** The right to invoke `fd_sync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SYNC: rights = 16;\n  /** The right to invoke `fd_seek` in such a way that the file offset remains unaltered (i.e., `whence.CUR` with offset zero), or to invoke `fd_tell`). */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_TELL: rights = 32;\n  /** The right to invoke `fd_write` and `sock_send`. If `rights.FD_SEEK` is set, includes the right to invoke `fd_pwrite`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: rights = 64;\n  /** The right to invoke `fd_advise`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ADVISE: rights = 128;\n  /** The right to invoke `fd_allocate`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ALLOCATE: rights = 256;\n  /** The right to invoke `path_create_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_DIRECTORY: rights = 512;\n  /** If `rights.PATH_OPEN` is set, the right to invoke `path_open` with `oflags.CREAT`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_FILE: rights = 1024;\n  /** The right to invoke `path_link` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_SOURCE: rights = 2048;\n  /** The right to invoke `path_link` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_TARGET: rights = 4096;\n  /** The right to invoke `path_open`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_OPEN: rights = 8192;\n  /** The right to invoke `fd_readdir`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READDIR: rights = 16384;\n  /** The right to invoke `path_readlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_READLINK: rights = 32768;\n  /** The right to invoke `path_rename` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_SOURCE: rights = 65536;\n  /** The right to invoke `path_rename` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_TARGET: rights = 131072;\n  /** The right to invoke `path_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_GET: rights = 262144;\n  /** The right to change a file's size (there is no `path_filestat_set_size`). If `rights.PATH_OPEN` is set, includes the right to invoke `path_open` with `oflags.TRUNC`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_SIZE: rights = 524288;\n  /** The right to invoke `path_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_TIMES: rights = 1048576;\n  /** The right to invoke `fd_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_GET: rights = 2097152;\n  /** The right to invoke `fd_filestat_set_size`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_SIZE: rights = 4194304;\n  /** The right to invoke `fd_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_TIMES: rights = 8388608;\n  /** The right to invoke `path_symlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const RIGHT_PATH_SYMLINK: rights = 16777216;\n  /** The right to invoke `path_remove_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_REMOVE_DIRECTORY: rights = 33554432;\n  /** The right to invoke `path_unlink_file`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_UNLINK_FILE: rights = 67108864;\n  /** If `rights.FD_READ` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_READ`. If `rights.FD_WRITE` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_WRITE`. */\n  // @ts-ignore: decorator\n  @inline\n  export const POLL_FD_READWRITE: rights = 134217728;\n  /** The right to invoke `sock_shutdown`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCK_SHUTDOWN: rights = 268435456;\n}\nexport type rights = u64;\n\n/** Flags returned by `sock_recv`. */\nexport namespace roflags {\n  /** Message data has been truncated. */\n  // @ts-ignore: decorator\n  @inline\n  export const DATA_TRUNCATED: roflags = 1;\n}\nexport type roflags = u16;\n\n/** Which channels on a socket to shut down. */\nexport namespace sdflags {\n  /** Disables further receive operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RD: sdflags = 1;\n  /** Disables further send operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const WR: sdflags = 2;\n}\nexport type sdflags = u8;\n\n/** Flags provided to `sock_send`. */\nexport namespace siflags {\n  // As there are currently no flags defined, it must be set to zero.\n}\nexport type siflags = u16;\n\n/** Signal condition. */\nexport namespace signal {\n  /** Hangup. */\n  // @ts-ignore: decorator\n  @inline\n  export const HUP: signal = 1;\n  /** Terminate interrupt signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const INT: signal = 2;\n  /** Terminal quit signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const QUIT: signal = 3;\n  /** Illegal instruction. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILL: signal = 4;\n  /** Trace/breakpoint trap. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRAP: signal = 5;\n  /** Process abort signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABRT: signal = 6;\n  /** Access to an undefined portion of a memory object. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUS: signal = 7;\n  /** Erroneous arithmetic operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const FPE: signal = 8;\n  /** Kill. */\n  // @ts-ignore: decorator\n  @inline\n  export const KILL: signal = 9;\n  /** User-defined signal 1. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR1: signal = 10;\n  /** Invalid memory reference. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEGV: signal = 11;\n  /** User-defined signal 2. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR2: signal = 12;\n  /** Write on a pipe with no one to read it. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: signal = 13;\n  /** Alarm clock. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALRM: signal = 14;\n  /** Termination signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TERM: signal = 15;\n  /** Child process terminated, stopped, or continued. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHLD: signal = 16;\n  /** Continue executing, if stopped. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONT: signal = 17;\n  /** Stop executing. */\n  // @ts-ignore: decorator\n  @inline\n  export const STOP: signal = 18;\n  /** Terminal stop signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TSTP: signal = 19;\n  /** Background process attempting read. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTIN: signal = 20;\n  /** Background process attempting write. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTOU: signal = 21;\n  /** High bandwidth data is available at a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const URG: signal = 22;\n  /** CPU time limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XCPU: signal = 23;\n  /** File size limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XFSZ: signal = 24;\n  /** Virtual timer expired. */\n  // @ts-ignore: decorator\n  @inline\n  export const VTALRM: signal = 25;\n  // @ts-ignore: decorator\n  @inline\n  export const PROF: signal = 26;\n  // @ts-ignore: decorator\n  @inline\n  export const WINCH: signal = 27;\n  // @ts-ignore: decorator\n  @inline\n  export const POLL: signal = 28;\n  // @ts-ignore: decorator\n  @inline\n  export const PWR: signal = 29;\n  /** Bad system call. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYS: signal = 30;\n}\nexport type signal = u8;\n\n/** Flags determining how to interpret the timestamp provided in `subscription_t::u.clock.timeout. */\nexport namespace subclockflags {\n  /** If set, treat the timestamp provided in `clocksubscription` as an absolute timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABSTIME: subclockflags = 1;\n}\nexport type subclockflags = u16;\n\n/** Subscription to an event. */\n@unmanaged export abstract class subscription {\n  /** User-provided value that is attached to the subscription. */\n  userdata: userdata;\n  /** The type of the event to which to subscribe. */\n  type: eventtype;\n  private __padding0: u32;\n}\n\n/* Subscription to an event of type `eventtype.CLOCK`.**/\n@unmanaged export class clocksubscription extends subscription {\n  /** The user-defined unique identifier of the clock. */\n  identifier: userdata;\n  /** The clock against which to compare the timestamp. */\n  clock_id: clockid;\n  /** The absolute or relative timestamp. */\n  timeout: timestamp;\n  /** The amount of time that the implementation may wait additionally to coalesce with other events. */\n  precision: timestamp;\n  /** Flags specifying whether the timeout is absolute or relative. */\n  flags: subclockflags;\n  private __padding1: u32;\n}\n\n/* Subscription to an event of type `eventtype.FD_READ` or `eventtype.FD_WRITE`.**/\n@unmanaged export class fdsubscription extends subscription {\n  /** The file descriptor on which to wait for it to become ready for reading or writing. */\n  fd: fd;\n}\n\n/** Timestamp in nanoseconds. */\nexport type timestamp = u64;\n\n/** User-provided value that may be attached to objects that is retained when extracted from the implementation. */\nexport type userdata = u64;\n\n/** The position relative to which to set the offset of the file descriptor. */\nexport namespace whence {\n  /** Seek relative to current position. */\n  // @ts-ignore: decorator\n  @inline\n  export const CUR: whence = 0;\n  /** Seek relative to end-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const END: whence = 1;\n  /** Seek relative to start-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET: whence = 2;\n}\nexport type whence = u8;\n","bindings/wasi":'export * from "./wasi_unstable";\n',builtins:"/* tslint:disable */\n\n@builtin @inline export const NaN: f64 = 0 / 0;\n@builtin @inline export const Infinity: f64 = 1 / 0;\n\n@builtin export declare function isInteger<T>(value?: T): bool;\n@builtin export declare function isFloat<T>(value?: T): bool;\n@builtin export declare function isSigned<T>(value?: T): bool;\n@builtin export declare function isReference<T>(value?: T): bool;\n@builtin export declare function isString<T>(value?: T): bool;\n@builtin export declare function isArray<T>(value?: T): bool;\n@builtin export declare function isArrayLike<T>(value?: T): bool;\n@builtin export declare function isFunction<T>(value?: T): bool;\n@builtin export declare function isNullable<T>(value?: T): bool;\n@builtin export declare function isDefined(expression: void): bool;\n@builtin export declare function isConstant(expression: void): bool;\n@builtin export declare function isManaged<T>(value?: T): bool;\n@inline export function isNaN<T>(value: T): bool { return value != value; }\n@inline export function isFinite<T>(value: T): bool { return value - value == 0; }\n\n@builtin export declare function clz<T>(value: T): T;\n@builtin export declare function ctz<T>(value: T): T;\n@builtin export declare function popcnt<T>(value: T): T;\n@builtin export declare function rotl<T>(value: T, shift: T): T;\n@builtin export declare function rotr<T>(value: T, shift: T): T;\n@builtin export declare function abs<T>(value: T): T;\n@builtin export declare function max<T>(left: T, right: T): T;\n@builtin export declare function min<T>(left: T, right: T): T;\n@builtin export declare function ceil<T>(value: T): T;\n@builtin export declare function floor<T>(value: T): T;\n@builtin export declare function copysign<T>(left: T, right: T): T;\n@builtin export declare function nearest<T>(value: T): T;\n@builtin export declare function reinterpret<T>(value: void): T;\n@builtin export declare function sqrt<T>(value: T): T;\n@builtin export declare function trunc<T>(value: T): T;\n@builtin export declare function load<T>(offset: usize, immOffset?: usize, immAlign?: usize): T;\n@builtin export declare function store<T>(offset: usize, value: void, immOffset?: usize, immAlign?: usize): void;\n@builtin export declare function sizeof<T>(): usize; // | u32 / u64\n@builtin export declare function alignof<T>(): usize; // | u32 / u64\n@builtin export declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n@builtin export declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n@builtin export declare function unreachable(): void;\n@builtin export declare function changetype<T>(value: void): T;\n@builtin export declare function assert<T>(isTrueish: T, message?: string): T;\n@builtin export declare function unchecked<T>(expr: T): T;\n@builtin export declare function call_indirect<T>(target: void, ...args: void[]): T;\n@builtin export declare function instantiate<T>(...args: void[]): T;\n\nexport namespace atomic {\n  @builtin export declare function load<T>(offset: usize, immOffset?: usize): T;\n  @builtin export declare function store<T>(offset: usize, value: T, immOffset?: usize): void;\n  @builtin export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n  @builtin export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n  @builtin export declare function notify(ptr: usize, count: i32): i32;\n}\n\n@lazy export const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n@builtin export declare function i8(value: void): i8;\nexport namespace i8 {\n  @lazy export const MIN_VALUE: i8 = -128;\n  @lazy export const MAX_VALUE: i8 =  127;\n}\n\n@builtin export declare function i16(value: void): i16;\nexport namespace i16 {\n  @lazy export const MIN_VALUE: i16 = -32768;\n  @lazy export const MAX_VALUE: i16 =  32767;\n}\n\n@builtin export declare function i32(value: void): i32;\nexport namespace i32 {\n  @lazy export const MIN_VALUE: i32 = -2147483648;\n  @lazy export const MAX_VALUE: i32 =  2147483647;\n  @builtin export declare function clz(value: i32): i32;\n  @builtin export declare function ctz(value: i32): i32;\n  @builtin export declare function popcnt(value: i32): i32;\n  @builtin export declare function rotl(value: i32, shift: i32): i32;\n  @builtin export declare function rotr(value: i32, shift: i32): i32;\n  @builtin export declare function reinterpret_f32(value: f32): i32;\n  @builtin export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function store8(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store16(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  \n  export namespace atomic {\n    @builtin export declare function load8_u(offset: usize, immOffset?: usize): i32;\n    @builtin export declare function load16_u(offset: usize, immOffset?: usize): i32;\n    @builtin export declare function load(offset: usize, immOffset?: usize): i32;\n    @builtin export declare function store8(offset: usize, value: i32, immOffset?: usize): void;\n    @builtin export declare function store16(offset: usize, value: i32, immOffset?: usize): void;\n    @builtin export declare function store(offset: usize, value: i32, immOffset?: usize): void;\n    @builtin export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n      @builtin export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n    export namespace rmw16 {\n      @builtin export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n    export namespace rmw {\n      @builtin export declare function add(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function sub(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function and(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function or(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xor(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xchg(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function cmpxchg(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n@builtin export declare function i64(value: void): i64;\nexport namespace i64 {\n  @lazy export const MIN_VALUE: i64 = -9223372036854775808;\n  @lazy export const MAX_VALUE: i64 =  9223372036854775807;\n  @builtin export declare function clz(value: i64): i64;\n  @builtin export declare function ctz(value: i64): i64;\n  @builtin export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load32_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load32_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load(offset: usize, immOffset?: usize): i64;\n  @builtin export declare function popcnt(value: i64): i64;\n  @builtin export declare function rotl(value: i64, shift: i64): i64;\n  @builtin export declare function rotr(value: i64, shift: i64): i64;\n  @builtin export declare function reinterpret_f64(value: f64): i64;\n  @builtin export declare function store8(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store16(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store32(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n    @builtin export declare function load8_u(offset: usize, immOffset?: usize): i64;\n    @builtin export declare function load16_u(offset: usize, immOffset?: usize): i64;\n    @builtin export declare function load32_u(offset: usize, immOffset?: usize): i64;\n    @builtin export declare function load(offset: usize, immOffset?: usize): i64;\n    @builtin export declare function store8(offset: usize, value: i64, immOffset?: usize): void;\n    @builtin export declare function store16(offset: usize, value: i64, immOffset?: usize): void;\n    @builtin export declare function store32(offset: usize, value: i64, immOffset?: usize): void;\n    @builtin export declare function store(offset: usize, value: i64, immOffset?: usize): void;\n    @builtin export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    export namespace rmw16 {\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    export namespace rmw32 {\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    export namespace rmw {\n      @builtin export declare function add(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function sub(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function and(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function or(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xor(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xchg(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function cmpxchg(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n@builtin export declare function isize(value: void): isize;\nexport namespace isize {\n  @lazy export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n  @lazy export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n@builtin export declare function u8(value: void): u8;\nexport namespace u8 {\n  @lazy export const MIN_VALUE: u8 = 0;\n  @lazy export const MAX_VALUE: u8 = 255;\n}\n\n@builtin export declare function u16(value: void): u16;\nexport namespace u16 {\n  @lazy export const MIN_VALUE: u16 = 0;\n  @lazy export const MAX_VALUE: u16 = 65535;\n}\n\n@builtin export declare function u32(value: void): u32;\nexport namespace u32 {\n  @lazy export const MIN_VALUE: u32 = 0;\n  @lazy export const MAX_VALUE: u32 = 4294967295;\n}\n\n@builtin export declare function u64(value: void): u64;\nexport namespace u64 {\n  @lazy export const MIN_VALUE: u64 = 0;\n  @lazy export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n@builtin export declare function usize(value: void): usize;\nexport namespace usize {\n  @lazy export const MIN_VALUE: usize = 0;\n  @lazy export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n@builtin export declare function bool(value: void): bool;\nexport namespace bool {\n  @lazy export const MIN_VALUE: bool = false;\n  @lazy export const MAX_VALUE: bool = true;\n}\n\n@builtin export declare function f32(value: void): f32;\nexport namespace f32 {\n  @lazy export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n  @lazy export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n  @lazy export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n  @lazy export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n  @lazy export const MIN_SAFE_INTEGER: f32 = -16777215;\n  @lazy export const MAX_SAFE_INTEGER: f32 =  16777215;\n  @builtin export declare function abs(value: f32): f32;\n  @builtin export declare function ceil(value: f32): f32;\n  @builtin export declare function copysign(x: f32, y: f32): f32;\n  @builtin export declare function floor(value: f32): f32;\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f32;\n  @builtin export declare function max(left: f32, right: f32): f32;\n  @builtin export declare function min(left: f32, right: f32): f32;\n  @builtin export declare function nearest(value: f32): f32;\n  @builtin export declare function reinterpret_i32(value: i32): f32;\n  @builtin export declare function sqrt(value: f32): f32;\n  @builtin export declare function store(offset: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function trunc(value: f32): f32;\n}\n\n@builtin export declare function f64(value: void): f64;\nexport namespace f64 {\n  @lazy export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n  @lazy export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n  @lazy export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n  @lazy export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n  @lazy export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n  @lazy export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n  @builtin export declare function abs(value: f64): f64;\n  @builtin export declare function ceil(value: f64): f64;\n  @builtin export declare function copysign(x: f64, y: f64): f64;\n  @builtin export declare function floor(value: f64): f64;\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f64;\n  @builtin export declare function max(left: f64, right: f64): f64;\n  @builtin export declare function min(left: f64, right: f64): f64;\n  @builtin export declare function nearest(value: f64): f64;\n  @builtin export declare function reinterpret_i64(value: i64): f64;\n  @builtin export declare function sqrt(value: f64): f64;\n  @builtin export declare function store(offset: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function trunc(value: f64): f64;\n}\n\n@builtin export declare function v128(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\nexport namespace v128 {\n  @builtin export declare function splat<T>(x: T): v128;\n  @builtin export declare function extract_lane<T>(x: v128, idx: u8): T;\n  @builtin export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n  @builtin export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): v128;\n  @builtin export declare function store(offset: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function add<T>(a: v128, b: v128): v128;\n  @builtin export declare function sub<T>(a: v128, b: v128): v128;\n  @builtin export declare function mul<T>(a: v128, b: v128): v128; // except i64\n  @builtin export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n  @builtin export declare function neg<T>(a: v128): v128;\n  @builtin export declare function add_saturate<T>(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate<T>(a: v128, b: v128): v128;\n  @builtin export declare function shl<T>(a: v128, b: i32): v128;\n  @builtin export declare function shr<T>(a: v128, b: i32): v128;\n  @builtin export declare function and(a: v128, b: v128): v128;\n  @builtin export declare function or(a: v128, b: v128): v128;\n  @builtin export declare function xor(a: v128, b: v128): v128;\n  @builtin export declare function not(a: v128): v128;\n  @builtin export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n  @builtin export declare function any_true<T>(a: v128): bool;\n  @builtin export declare function all_true<T>(a: v128): bool;\n  @builtin export declare function min<T>(a: v128, b: v128): v128; // f32, f64 only\n  @builtin export declare function max<T>(a: v128, b: v128): v128; // f32, f64 only\n  @builtin export declare function abs<T>(a: v128): v128; // f32, f64 only\n  @builtin export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n  @builtin export declare function eq<T>(a: v128, b: v128): v128;\n  @builtin export declare function ne<T>(a: v128, b: v128): v128;\n  @builtin export declare function lt<T>(a: v128, b: v128): v128;\n  @builtin export declare function le<T>(a: v128, b: v128): v128;\n  @builtin export declare function gt<T>(a: v128, b: v128): v128;\n  @builtin export declare function ge<T>(a: v128, b: v128): v128;\n  @builtin export declare function convert<T>(a: v128): v128;\n  @builtin export declare function trunc<T>(a: v128): v128;\n}\n\n@builtin export declare function i8x16(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\nexport namespace i8x16 {\n  @builtin export declare function splat(x: i8): v128;\n  @builtin export declare function extract_lane_s(x: v128, idx: u8): i8;\n  @builtin export declare function extract_lane_u(x: v128, idx: u8): u8;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function add_saturate_s(a: v128, b: v128): v128;\n  @builtin export declare function add_saturate_u(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate_s(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate_u(a: v128, b: v128): v128;\n  @builtin export declare function shl(a: v128, b: i32): v128;\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\n  @builtin export declare function any_true(a: v128): bool;\n  @builtin export declare function all_true(a: v128): bool;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\n  @builtin export declare function le_s(a: v128, b: v128): v128;\n  @builtin export declare function le_u(a: v128, b: v128): v128;\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\n}\n\n@builtin export declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\nexport namespace i16x8 {\n  @builtin export declare function splat(x: i16): v128;\n  @builtin export declare function extract_lane_s(x: v128, idx: u8): i16;\n  @builtin export declare function extract_lane_u(x: v128, idx: u8): u16;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function add_saturate_s(a: v128, b: v128): v128;\n  @builtin export declare function add_saturate_u(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate_s(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate_u(a: v128, b: v128): v128;\n  @builtin export declare function shl(a: v128, b: i32): v128;\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\n  @builtin export declare function any_true(a: v128): bool;\n  @builtin export declare function all_true(a: v128): bool;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\n  @builtin export declare function le_s(a: v128, b: v128): v128;\n  @builtin export declare function le_u(a: v128, b: v128): v128;\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\n}\n\n@builtin export declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\nexport namespace i32x4 {\n  @builtin export declare function splat(x: i32): v128;\n  @builtin export declare function extract_lane(x: v128, idx: u8): i32;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function shl(a: v128, b: i32): v128;\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\n  @builtin export declare function any_true(a: v128): bool;\n  @builtin export declare function all_true(a: v128): bool;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\n  @builtin export declare function le_s(a: v128, b: v128): v128;\n  @builtin export declare function le_u(a: v128, b: v128): v128;\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\n  @builtin export declare function trunc_s_f32x4_sat(a: v128): v128;\n  @builtin export declare function trunc_u_f32x4_sat(a: v128): v128;\n}\n\n@builtin export declare function i64x2(a: i64, b: i64): v128;\nexport namespace i64x2 {\n  @builtin export declare function splat(x: i64): v128;\n  @builtin export declare function extract_lane(x: v128, idx: u8): i64;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function shl(a: v128, b: i32): v128;\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\n  @builtin export declare function any_true(a: v128): bool;\n  @builtin export declare function all_true(a: v128): bool;\n  @builtin export declare function trunc_s_f64x2_sat(a: v128): v128;\n  @builtin export declare function trunc_u_f64x2_sat(a: v128): v128;\n}\n\n@builtin export declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\nexport namespace f32x4 {\n  @builtin export declare function splat(x: f32): v128;\n  @builtin export declare function extract_lane(x: v128, idx: u8): f32;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function div(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function min(a: v128, b: v128): v128;\n  @builtin export declare function max(a: v128, b: v128): v128;\n  @builtin export declare function abs(a: v128): v128;\n  @builtin export declare function sqrt(a: v128): v128;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt(a: v128, b: v128): v128;\n  @builtin export declare function le(a: v128, b: v128): v128;\n  @builtin export declare function gt(a: v128, b: v128): v128;\n  @builtin export declare function ge(a: v128, b: v128): v128;\n  @builtin export declare function convert_s_i32x4(a: v128): v128;\n  @builtin export declare function convert_u_i32x4(a: v128): v128;\n}\n\n@builtin export declare function f64x2(a: f64, b: f64): v128;\nexport namespace f64x2 {\n  @builtin export declare function splat(x: f64): v128;\n  @builtin export declare function extract_lane(x: v128, idx: u8): f64;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function div(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function min(a: v128, b: v128): v128;\n  @builtin export declare function max(a: v128, b: v128): v128;\n  @builtin export declare function abs(a: v128): v128;\n  @builtin export declare function sqrt(a: v128): v128;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt(a: v128, b: v128): v128;\n  @builtin export declare function le(a: v128, b: v128): v128;\n  @builtin export declare function gt(a: v128, b: v128): v128;\n  @builtin export declare function ge(a: v128, b: v128): v128;\n  @builtin export declare function convert_s_i64x2(a: v128): v128;\n  @builtin export declare function convert_u_i64x2(a: v128): v128;\n}\n\nexport namespace v8x16 {\n  @builtin export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8, l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8): v128;\n}\n\n@builtin export declare function start(): void;\n","collector/itcm":'/**\n * Incremental Tri-Color-Marking Garbage Collector.\n *\n * @module std/assembly/collector/itcm\n *//***/\n\n// Largely based on Bach Le\'s μgc, see: https://github.com/bullno1/ugc\n\n@inline const TRACE = false;\n\n/** Size of a managed object header. */\n@inline export const HEADER_SIZE: usize = (offsetof<ManagedObject>() + AL_MASK) & ~AL_MASK;\n\nimport { AL_MASK, MAX_SIZE_32 } from "../internal/allocator";\nimport { iterateRoots } from "../gc";\n\n/** Collector states. */\nconst enum State {\n  /** Not yet initialized. */\n  INIT = 0,\n  /** Currently transitioning from SWEEP to MARK state. */\n  IDLE = 1,\n  /** Currently marking reachable objects. */\n  MARK = 2,\n  /** Currently sweeping unreachable objects. */\n  SWEEP = 3\n}\n\n/** Current collector state. */\nvar state = State.INIT;\n/** Current white color value. */\nvar white = 0;\n\n// From and to spaces\nvar fromSpace: ManagedObjectList;\nvar toSpace: ManagedObjectList;\nvar iter: ManagedObject;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┴─┤      ┐\n// │                              next                       │0│ C │ ◄─┐ = nextWithColor\n// ├─────────────────────────────────────────────────────────┴─┴───┤   │ usize\n// │                              prev                             │ ◄─┘\n// ├───────────────────────────────────────────────────────────────┤\n// │                             hookFn                            │\n// ╞═══════════════════════════════════════════════════════════════╡ SIZE ┘ ◄─ user-space reference\n// │                          ... data ...                         │\n// └───────────────────────────────────────────────────────────────┘\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object\'s data. */\n@unmanaged class ManagedObject {\n\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize;\n\n  /** Pointer to the previous object. */\n  prev: ManagedObject;\n\n  /** Class-specific hook function called with the user-space reference. */\n  hookFn: (ref: usize) => void;\n\n  /** Gets the pointer to the next object. */\n  get next(): ManagedObject {\n    return changetype<ManagedObject>(this.nextWithColor & ~3);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: ManagedObject) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & 3);\n  }\n\n  /** Gets this object\'s color. */\n  get color(): i32 {\n    return this.nextWithColor & 3;\n  }\n\n  /** Sets this object\'s color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~3) | color;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    var next = this.next;\n    var prev = this.prev;\n    if (TRACE) trace("   unlink", 3, objToRef(prev), objToRef(this), objToRef(next));\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (TRACE) trace("   makeGray", 1, objToRef(this));\n    const gray = 2;\n    if (this == iter) iter = this.prev;\n    this.unlink();\n    toSpace.push(this);\n    this.nextWithColor = (this.nextWithColor & ~3) | gray;\n  }\n}\n\n/** A list of managed objects. Used for the from and to spaces. */\n@unmanaged class ManagedObjectList extends ManagedObject {\n\n  /** Inserts an object. */\n  push(obj: ManagedObject): void {\n    var prev = this.prev;\n    if (TRACE) trace("   push", 3, objToRef(prev), objToRef(obj), objToRef(this));\n    obj.next = this;\n    obj.prev = prev;\n    prev.next = obj;\n    this.prev = obj;\n  }\n\n  /** Clears this list. */\n  clear(): void {\n    if (TRACE) trace("   clear", 1, objToRef(this));\n    this.nextWithColor = changetype<usize>(this);\n    this.prev = this;\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): void {\n  var obj: ManagedObject;\n  switch (state) {\n    case State.INIT: {\n      if (TRACE) trace("gc~step/INIT");\n      fromSpace = changetype<ManagedObjectList>(memory.allocate(HEADER_SIZE));\n      fromSpace.hookFn = changetype<(ref: usize) => void>(<u32>-1); // would error\n      fromSpace.clear();\n      toSpace = changetype<ManagedObjectList>(memory.allocate(HEADER_SIZE));\n      toSpace.hookFn = changetype<(ref: usize) => void>(<u32>-1); // would error\n      toSpace.clear();\n      iter = toSpace;\n      state = State.IDLE;\n      if (TRACE) trace("gc~state = IDLE");\n      // fall-through\n    }\n    case State.IDLE: {\n      if (TRACE) trace("gc~step/IDLE");\n      iterateRoots(__gc_mark);\n      state = State.MARK;\n      if (TRACE) trace("gc~state = MARK");\n      break;\n    }\n    case State.MARK: {\n      obj = iter.next;\n      if (obj !== toSpace) {\n        if (TRACE) trace("gc~step/MARK iterate", 1, objToRef(obj));\n        iter = obj;\n        obj.color = <i32>!white;\n        // if (TRACE) {\n        //   trace("   next/prev/hook", 3,\n        //     changetype<usize>(obj.next),\n        //     changetype<usize>(obj.prev),\n        //     changetype<u32>(obj.hookFn)\n        //   );\n        // }\n        obj.hookFn(objToRef(obj));\n      } else {\n        if (TRACE) trace("gc~step/MARK finish");\n        iterateRoots(__gc_mark);\n        obj = iter.next;\n        if (obj === toSpace) {\n          let from = fromSpace;\n          fromSpace = toSpace;\n          toSpace = from;\n          white = <i32>!white;\n          iter = from.next;\n          state = State.SWEEP;\n          if (TRACE) trace("gc~state = SWEEP");\n        }\n      }\n      break;\n    }\n    case State.SWEEP: {\n      obj = iter;\n      if (obj !== toSpace) {\n        if (TRACE) trace("gc~step/SWEEP free", 1, objToRef(obj));\n        iter = obj.next;\n        if (changetype<usize>(obj) >= HEAP_BASE) memory.free(changetype<usize>(obj));\n      } else {\n        if (TRACE) trace("gc~step/SWEEP finish");\n        toSpace.clear();\n        state = State.IDLE;\n        if (TRACE) trace("gc~state = IDLE");\n      }\n      break;\n    }\n  }\n}\n\n@inline function refToObj(ref: usize): ManagedObject {\n  return changetype<ManagedObject>(ref - HEADER_SIZE);\n}\n\n@inline function objToRef(obj: ManagedObject): usize {\n  return changetype<usize>(obj) + HEADER_SIZE;\n}\n\n// Garbage collector interface\n\n@global export function __gc_allocate(\n  size: usize,\n  markFn: (ref: usize) => void\n): usize {\n  if (TRACE) trace("gc.allocate", 1, size);\n  if (size > MAX_SIZE_32 - HEADER_SIZE) unreachable();\n  step(); // also makes sure it\'s initialized\n  var obj = changetype<ManagedObject>(memory.allocate(HEADER_SIZE + size));\n  obj.hookFn = markFn;\n  obj.color = white;\n  fromSpace.push(obj);\n  return objToRef(obj);\n}\n\n@global export function __gc_link(parentRef: usize, childRef: usize): void {\n  if (TRACE) trace("gc.link", 2, parentRef, childRef);\n  var parent = refToObj(parentRef);\n  if (parent.color == <i32>!white && refToObj(childRef).color == white) parent.makeGray();\n}\n\n@global export function __gc_mark(ref: usize): void {\n  if (TRACE) trace("gc.mark", 1, ref);\n  if (ref) {\n    let obj = refToObj(ref);\n    if (obj.color == white) obj.makeGray();\n  }\n}\n\n@global export function __gc_collect(): void {\n  if (TRACE) trace("gc.collect");\n  // begin collecting if not yet collecting\n  switch (state) {\n    case State.INIT:\n    case State.IDLE: step();\n  }\n  // finish the cycle\n  while (state != State.IDLE) step();\n}\n',dataview:'import {\n  HEADER_SIZE,\n  MAX_BLENGTH\n} from "./internal/arraybuffer";\n\nexport class DataView {\n\n  constructor(\n    readonly buffer: ArrayBuffer,\n    readonly byteOffset: i32 = 0,\n    readonly byteLength: i32 = i32.MIN_VALUE // FIXME\n  ) {\n    if (byteLength === i32.MIN_VALUE) byteLength = buffer.byteLength - byteOffset; // FIXME\n    if (<u32>byteOffset > <u32>MAX_BLENGTH) throw new RangeError("Invalid byteOffset");\n    if (<u32>byteLength > <u32>MAX_BLENGTH) throw new RangeError("Invalid byteLength");\n    if (byteOffset + byteLength > buffer.byteLength) throw new RangeError("Invalid length");\n  }\n\n  getFloat32(byteOffset: i32, littleEndian: boolean = false): f32 {\n    checkOffset(byteOffset, 4, this.byteLength);\n    return littleEndian\n      ? load<f32>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, HEADER_SIZE)\n      : reinterpret<f32>(\n          bswap<u32>(\n            load<u32>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, HEADER_SIZE)\n          )\n        );\n  }\n\n  getFloat64(byteOffset: i32, littleEndian: boolean = false): f64 {\n    checkOffset(byteOffset, 8, this.byteLength);\n    return littleEndian\n      ? load<f64>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, HEADER_SIZE)\n      : reinterpret<f64>(\n          bswap(\n            load<u64>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, HEADER_SIZE)\n          )\n        );\n  }\n\n  getInt8(byteOffset: i32): i8 {\n    checkOffset(byteOffset, 1, this.byteLength);\n    return load<i8>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, HEADER_SIZE);\n  }\n\n  getInt16(byteOffset: i32, littleEndian: boolean = false): i16 {\n    checkOffset(byteOffset, 2, this.byteLength);\n    var result: i16 = load<i16>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, HEADER_SIZE);\n    return littleEndian ? result : bswap<i16>(result);\n  }\n\n  getInt32(byteOffset: i32, littleEndian: boolean = false): i32 {\n    checkOffset(byteOffset, 4, this.byteLength);\n    var result = load<i32>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, HEADER_SIZE);\n    return littleEndian ? result : bswap<i32>(result);\n  }\n\n  getUint8(byteOffset: i32): u8 {\n    checkOffset(byteOffset, 1, this.byteLength);\n    return load<u8>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, HEADER_SIZE);\n  }\n\n  getUint16(byteOffset: i32, littleEndian: boolean = false): u16 {\n    checkOffset(byteOffset, 2, this.byteLength);\n    var result: u16 = load<u16>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, HEADER_SIZE);\n    return littleEndian ? result : bswap<u16>(result);\n  }\n\n  getUint32(byteOffset: i32, littleEndian: boolean = false): u32 {\n    checkOffset(byteOffset, 4, this.byteLength);\n    var result = load<u32>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, HEADER_SIZE);\n    return littleEndian ? result : bswap<u32>(result);\n  }\n\n  setFloat32(byteOffset: i32, value: f32, littleEndian: boolean = false): void {\n    checkOffset(byteOffset, 4, this.byteLength);\n    if (littleEndian) {\n      store<f32>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, value, HEADER_SIZE);\n    } else {\n      store<u32>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset,\n        bswap(\n          reinterpret<u32>(value)\n        ),\n        HEADER_SIZE\n      );\n    }\n  }\n\n  setFloat64(byteOffset: i32, value: f64, littleEndian: boolean = false): void {\n    checkOffset(byteOffset, 8, this.byteLength);\n    if (littleEndian) {\n      store<f64>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, value, HEADER_SIZE);\n    } else {\n      store<u64>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset,\n        bswap(\n          reinterpret<u64>(value)\n        ),\n        HEADER_SIZE\n      );\n    }\n  }\n\n  setInt8(byteOffset: i32, value: i8): void {\n    checkOffset(byteOffset, 1, this.byteLength);\n    store<i8>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, value, HEADER_SIZE);\n  }\n\n  setInt16(byteOffset: i32, value: i16, littleEndian: boolean = false): void {\n    checkOffset(byteOffset, 2, this.byteLength);\n    store<i16>(\n      changetype<usize>(this.buffer) + this.byteOffset + byteOffset,\n      littleEndian ? value : bswap(value),\n      HEADER_SIZE\n    );\n  }\n\n  setInt32(byteOffset: i32, value: i32, littleEndian: boolean = false): void {\n    checkOffset(byteOffset, 4, this.byteLength);\n    store<i32>(\n      changetype<usize>(this.buffer) + this.byteOffset + byteOffset,\n      littleEndian ? value : bswap(value),\n      HEADER_SIZE\n    );\n  }\n\n  setUint8(byteOffset: i32, value: u8): void {\n    checkOffset(byteOffset, 1, this.byteLength);\n    store<u8>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, value, HEADER_SIZE);\n  }\n\n  setUint16(byteOffset: i32, value: u16, littleEndian: boolean = false): void {\n    checkOffset(byteOffset, 2, this.byteLength);\n    store<u16>(\n      changetype<usize>(this.buffer) + this.byteOffset + byteOffset,\n      littleEndian ? value : bswap(value),\n      HEADER_SIZE\n    );\n  }\n\n  setUint32(byteOffset: i32, value: u32, littleEndian: boolean = false): void {\n    checkOffset(byteOffset, 4, this.byteLength);\n    store<u32>(\n      changetype<usize>(this.buffer) + this.byteOffset + byteOffset,\n      littleEndian ? value : bswap(value),\n      HEADER_SIZE\n    );\n  }\n\n  // Non-standard additions that make sense in WebAssembly, but won\'t work in JS:\n\n  getInt64(byteOffset: i32, littleEndian: boolean = false): i64 {\n    checkOffset(byteOffset, 8, this.byteLength);\n    var result = load<i64>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, HEADER_SIZE);\n    return littleEndian ? result : bswap(result);\n  }\n\n  getUint64(byteOffset: i32, littleEndian: boolean = false): u64 {\n    checkOffset(byteOffset, 8, this.byteLength);\n    var result = load<u64>(changetype<usize>(this.buffer) + this.byteOffset + byteOffset, HEADER_SIZE);\n    return littleEndian ? result : bswap(result);\n  }\n\n  setInt64(byteOffset: i32, value: i64, littleEndian: boolean = false): void {\n    checkOffset(byteOffset, 8, this.byteLength);\n    store<i64>(\n      changetype<usize>(this.buffer) + this.byteOffset + byteOffset,\n      littleEndian ? value : bswap(value),\n      HEADER_SIZE\n    );\n  }\n\n  setUint64(byteOffset: i32, value: u64, littleEndian: boolean = false): void {\n    checkOffset(byteOffset, 8, this.byteLength);\n    store<u64>(\n      changetype<usize>(this.buffer) + this.byteOffset + byteOffset,\n      littleEndian ? value : bswap(value),\n      HEADER_SIZE\n    );\n  }\n\n  toString(): string {\n    return "[object DataView]";\n  }\n}\n\n@inline function checkOffset(byteOffset: i32, n: i32, byteLength: i32): void {\n  // n and byteLength must be known to be in bounds\n  if (<u32>byteOffset > <u32>MAX_BLENGTH || byteOffset + n > byteLength) throw new Error("Offset out of bounds");\n}\n',date:'import {\n  UTC as Date_UTC,\n  now as Date_now\n} from "./bindings/Date";\n\nexport class Date {\n\n  @inline static UTC(\n    year: i32,\n    month: i32 = 0,\n    day: i32 = 1,\n    hour: i32 = 0,\n    minute: i32 = 0,\n    second: i32 = 0,\n    millisecond: i64 = 0\n  ): i64 {\n    return <i64>Date_UTC(year, month, day, hour, minute, second, <f64>millisecond);\n  }\n\n  @inline static now(): i64 {\n    return <i64>Date_now();\n  }\n\n  private value: i64;\n\n  constructor(value: i64) {\n    this.value = value;\n  }\n\n  getTime(): i64 {\n    return this.value;\n  }\n\n  setTime(value: i64): i64 {\n    this.value = value;\n    return value;\n  }\n}\n',diagnostics:"/* tslint:disable */\n\n@builtin export declare function ERROR(message?: void): void;\n@builtin export declare function WARNING(message?: void): void;\n@builtin export declare function INFO(message?: void): void;\n",env:"declare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n",error:'export class Error {\n\n  name: string  = "Error";\n  stack: string = ""; // TODO\n\n  constructor(\n    public message: string = ""\n  ) {}\n\n  toString(): string {\n    var message = this.message;\n    return message.length\n      ? this.name + ": " + message\n      : this.name;\n  }\n}\n\nexport class RangeError extends Error {\n  constructor(message: string = "") {\n    super(message);\n    this.name = "RangeError";\n  }\n}\n\nexport class TypeError extends Error {\n  constructor(message: string = "") {\n    super(message);\n    this.name = "TypeError";\n  }\n}\n\nexport class SyntaxError extends Error {\n  constructor(message: string = "") {\n    super(message);\n    this.name = "SyntaxError";\n  }\n}\n',gc:"/* tslint:disable */\n\n@builtin export declare function iterateRoots(fn: (ref: usize) => void): void;\n\nexport namespace gc {\n\n  export function collect(): void {\n    if (isDefined(__gc_collect)) { __gc_collect(); return; }\n    WARNING(\"Calling 'gc.collect' requires a garbage collector to be present.\");\n    unreachable();\n  }\n}\n","internal/allocator":"/** Number of alignment bits. */\n@inline export const AL_BITS: u32 = 3;\n/** Number of possible alignment values. */\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n/** Mask to obtain just the alignment bits. */\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n/** Maximum 32-bit allocation size. */\n@inline export const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","internal/arraybuffer":'import {\n  AL_MASK,\n  MAX_SIZE_32\n } from "./allocator";\n\n/** Size of an ArrayBuffer header. */\n@inline export const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\n/** Maximum byte length of an ArrayBuffer. */\n@inline export const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\n\nfunction computeSize(byteLength: i32): usize {\n  // round up to power of 2, with HEADER_SIZE=8:\n  // 0            -> 2^3  = 8\n  // 1..8         -> 2^4  = 16\n  // 9..24        -> 2^5  = 32\n  // ...\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\n}\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\n  var buffer: usize;\n  if (isManaged<ArrayBuffer>()) {\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\n  } else {\n    buffer = memory.allocate(computeSize(byteLength));\n  }\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>("byteLength"));\n  return changetype<ArrayBuffer>(buffer);\n}\n\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\n  var oldByteLength = buffer.byteLength;\n  if (newByteLength > oldByteLength) {\n    assert(newByteLength <= MAX_BLENGTH);\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>("byteLength"));\n    } else { // slow path: copy to new buffer\n      let newBuffer = allocateUnsafe(newByteLength);\n      memory.copy(\n        changetype<usize>(newBuffer) + HEADER_SIZE,\n        changetype<usize>(buffer) + HEADER_SIZE,\n        <usize>oldByteLength\n      );\n      if (!isManaged<ArrayBuffer>()) {\n        memory.free(changetype<usize>(buffer));\n      }\n      buffer = newBuffer;\n    }\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\n      0,\n      <usize>(newByteLength - oldByteLength)\n    );\n  } else if (newByteLength < oldByteLength) { // fast path: override size\n    // TBD: worth to copy and release if size is significantly less than before?\n    assert(newByteLength >= 0);\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>("byteLength"));\n  }\n  return buffer;\n}\n\n// The helpers below use two different types in order to emit loads and stores that load respectively\n// store one type to/from memory while returning/taking the desired output/input type. This allows to\n// emit instructions like\n//\n// * `i32.load8` ^= `<i32>load<i8>(...)` that reads an i8 but returns an i32, or\n// * `i64.load32_s` ^= `<i64>load<i32>(...)`) that reads a 32-bit as a 64-bit integer\n//\n// without having to emit an additional instruction for conversion purposes. The second parameter\n// can be omitted for references and other loads and stores that simply return the exact type.\n\n@inline export function LOAD<T,TOut = T>(buffer: ArrayBuffer, index: i32, byteOffset: i32 = 0): TOut {\n  return <TOut>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, HEADER_SIZE);\n}\n\n@inline export function STORE<T,TIn = T>(buffer: ArrayBuffer, index: i32, value: TIn, byteOffset: i32 = 0): void {\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, value, HEADER_SIZE);\n}\n',"internal/hash":'import {\n  HEADER_SIZE\n} from "./string";\n\n/** Computes the 32-bit hash of a value of any type. */\n@inline\nexport function HASH<T>(key: T): u32 {\n  // branch-level tree-shaking makes this a `(return (call ...))`\n  if (isString(key)) {\n    return hashStr(key);\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(key));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(key));\n  } else {\n    if (sizeof<T>() == 1) return hash8 (<u32>key);\n    if (sizeof<T>() == 2) return hash16(<u32>key);\n    if (sizeof<T>() == 4) return hash32(<u32>key);\n    if (sizeof<T>() == 8) return hash64(<u64>key);\n  }\n  unreachable();\n}\n\n// FNV-1a 32-bit as a starting point, see: http://isthe.com/chongo/tech/comp/fnv/\n\n@inline const FNV_OFFSET: u32 = 2166136261;\n@inline const FNV_PRIME: u32 = 16777619;\n\nfunction hash8(key: u32): u32 {\n  return (FNV_OFFSET ^ key) * FNV_PRIME;\n}\n\nfunction hash16(key: u32): u32 {\n  var v = FNV_OFFSET;\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\n  v = (v ^ ( key >>  8        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hash32(key: u32): u32 {\n  var v = FNV_OFFSET;\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((key >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((key >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( key >> 24        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hash64(key: u64): u32 {\n  var l = <u32> key;\n  var h = <u32>(key >>> 32);\n  var v = FNV_OFFSET;\n  v = (v ^ ( l        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((l >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((l >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( l >> 24        )) * FNV_PRIME;\n  v = (v ^ ( h        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((h >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((h >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( h >> 24        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hashStr(key: string): u32 {\n  var v = FNV_OFFSET;\n  for (let i: usize = 0, k: usize = key.length << 1; i < k; ++i) {\n    v = (v ^ <u32>load<u8>(changetype<usize>(key) + i, HEADER_SIZE)) * FNV_PRIME;\n  }\n  return v;\n}\n',"internal/memory":"// this function will go away once `memory.copy` becomes an intrinsic\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// this function will go away once `memory.copy` becomes an intrinsic\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (src + n <= dest || dest + n <= src) {\n    memcpy(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// this function will go away once `memory.fill` becomes an intrinsic\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n\n  // fill head and tail with minimal branching\n  if (!n) return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2) return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6) return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8) return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8) return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24) return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n  if (vl == vr) return 0;\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\n    n--; vl++; vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n","internal/number":'import {\n  CharCode,\n  allocateUnsafe as allocateUnsafeString,\n  freeUnsafe as freeUnsafeString,\n  HEADER_SIZE as STRING_HEADER_SIZE\n} from "./string";\n\nimport {\n  LOAD\n} from "./arraybuffer";\n\n@inline export const MAX_DOUBLE_LENGTH = 28;\n\n@lazy @inline const POWERS10: u32[] = [\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n];\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  "00", "01", "02", "03", "04", "05", "06", "07", "08", "09",\n  "10", "11", "12", "13", "14", "15", "16", "17", "18", "19",\n  "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",\n  "30", "31", "32", "33", "34", "35", "36", "37", "38", "39",\n  "40", "41", "42", "43", "44", "45", "46", "47", "48", "49",\n  "50", "51", "52", "53", "54", "55", "56", "57", "58", "59",\n  "60", "61", "62", "63", "64", "65", "66", "67", "68", "69",\n  "70", "71", "72", "73", "74", "75", "76", "77", "78", "79",\n  "80", "81", "82", "83", "84", "85", "86", "87", "88", "89",\n  "90", "91", "92", "93", "94", "95", "96", "97", "98", "99"\n*/\n@lazy @inline const DIGITS: u32[] = [\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n];\n\n@lazy @inline const EXP_POWERS: i16[] = [\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n];\n\n// 1e-348, 1e-340, ..., 1e340\n@lazy @inline const FRC_POWERS: u64[] = [\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n];\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    let l: u32 = 32 - clz<u32>(value); // log2\n    let t = l * 1233 >>> 12; // log10\n\n    let lutbuf = <ArrayBuffer>POWERS10.buffer_;\n    let power  = LOAD<u32>(lutbuf, t);\n    t -= <u32>(value < power);\n    return t + 1;\n  } else {\n    if (value < 100000) {\n      if (value < 100) {\n        return select<u32>(1, 2, value < 10);\n      } else {\n        let m = select<u32>(4, 5, value < 10000);\n        return select<u32>(3, m, value < 1000);\n      }\n    } else {\n      if (value < 10000000) {\n        return select<u32>(6, 7, value < 1000000);\n      } else {\n        let m = select<u32>(9, 10, value < 1000000000);\n        return select<u32>(8, m, value < 100000000);\n      }\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64(value: u64): u32 {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    let l: u32 = 64 - <u32>clz<u64>(value); // log2\n    let t = l * 1233 >>> 12; // log10\n\n    let lutbuf = <ArrayBuffer>POWERS10.buffer_;\n    let power  = LOAD<u32,u64>(lutbuf, t - 10);\n    t -= <u32>(value < 10000000000 * power);\n    return t + 1;\n  } else {\n    if (value < 1000000000000000) {\n      if (value < 1000000000000) {\n        return select<u32>(11, 12, value < 100000000000);\n      } else {\n        let m = select<u32>(14, 15, value < 100000000000000);\n        return select<u32>(13, m, value < 10000000000000);\n      }\n    } else {\n      if (value < 100000000000000000) {\n        return select<u32>(16, 17, value < 10000000000000000);\n      } else {\n        let m = select<u32>(19, 20, value < 10000000000000000000);\n        return select<u32>(18, m, value < 1000000000000000000);\n      }\n    }\n  }\n}\n\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\n  var lutbuf = <ArrayBuffer>DIGITS.buffer_;\n\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = LOAD<u32,u64>(lutbuf, d1);\n    let digits2 = LOAD<u32,u64>(lutbuf, d2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = LOAD<u32>(lutbuf, d1);\n    store<u32>(buffer + (offset << 1), digits, STRING_HEADER_SIZE);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = LOAD<u32>(lutbuf, num);\n    store<u32>(buffer + (offset << 1), digits, STRING_HEADER_SIZE);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit, STRING_HEADER_SIZE);\n  }\n}\n\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\n  var lutbuf = <ArrayBuffer>DIGITS.buffer_;\n\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = LOAD<u32,u64>(lutbuf, c1);\n    let digits2 = LOAD<u32,u64>(lutbuf, c2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n\n    digits1 = LOAD<u32,u64>(lutbuf, b1);\n    digits2 = LOAD<u32,u64>(lutbuf, b2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n  }\n\n  utoa32_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_simple<T>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = t;\n    offset -= 1;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r, STRING_HEADER_SIZE);\n  } while (num);\n}\n\n@inline\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa32_lut(buffer, num, offset);\n  }\n}\n\n@inline\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa64_lut(buffer, num, offset);\n  }\n}\n\nexport function utoa32(value: u32): String {\n  if (!value) return "0";\n\n  var decimals = decimalCount32(value);\n  var buffer   = allocateUnsafeString(decimals);\n\n  utoa32_core(changetype<usize>(buffer), value, decimals);\n  return buffer;\n}\n\nexport function itoa32(value: i32): String {\n  if (!value) return "0";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var decimals = decimalCount32(value) + <u32>sign;\n  var buffer   = allocateUnsafeString(decimals);\n\n  utoa32_core(changetype<usize>(buffer), value, decimals);\n  if (sign) store<u16>(changetype<usize>(buffer), CharCode.MINUS, STRING_HEADER_SIZE);\n\n  return buffer;\n}\n\nexport function utoa64(value: u64): String {\n  if (!value) return "0";\n\n  var buffer: String;\n  if (value <= u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32);\n    buffer = allocateUnsafeString(decimals);\n    utoa32_core(changetype<usize>(buffer), val32, decimals);\n  } else {\n    let decimals = decimalCount64(value);\n    buffer = allocateUnsafeString(decimals);\n    utoa64_core(changetype<usize>(buffer), value, decimals);\n  }\n  return buffer;\n}\n\nexport function itoa64(value: i64): String {\n  if (!value) return "0";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var buffer: String;\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32) + <u32>sign;\n    buffer = allocateUnsafeString(decimals);\n    utoa32_core(changetype<usize>(buffer), val32, decimals);\n  } else {\n    let decimals = decimalCount64(value) + <u32>sign;\n    buffer = allocateUnsafeString(decimals);\n    utoa64_core(changetype<usize>(buffer), value, decimals);\n  }\n  if (sign) store<u16>(changetype<usize>(buffer), CharCode.MINUS, STRING_HEADER_SIZE);\n\n  return buffer;\n}\n\nexport function itoa<T>(value: T): String {\n  if (!isInteger<T>()) {\n    assert(false); // unexpecteble non-integer generic type\n  } else {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        return itoa32(<i32>value);\n      } else {\n        return itoa64(<i64>value);\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        return utoa32(<u32>value);\n      } else {\n        return utoa64(<u64>value);\n      }\n    }\n  }\n}\n\n@lazy var _K: i32 = 0;\n// @lazy var _frc: u64 = 0;\n@lazy var _exp: i32 = 0;\n@lazy var _frc_minus: u64 = 0;\n@lazy var _frc_plus:  u64 = 0;\n@lazy var _frc_pow: u64 = 0;\n@lazy var _exp_pow: i32 = 0;\n\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + <i32>(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp, STRING_HEADER_SIZE);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit, STRING_HEADER_SIZE);\n}\n\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n      k += <i32>(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  var frcPowers = <ArrayBuffer>FRC_POWERS.buffer_;\n  var expPowers = <ArrayBuffer>EXP_POWERS.buffer_;\n  _frc_pow = LOAD<u64>(frcPowers, index);\n  _exp_pow = LOAD<i16,i32>(expPowers, index);\n}\n\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = <i32>((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (<u64>(exp != 0) << 52) + sid;\n      exp = select<i32>(exp, 1, exp != 0) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp,      exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n  var wp_w_exp = mp_exp;\n\n  var p1 = <u32>(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  var powers10 = <ArrayBuffer>POWERS10.buffer_;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d, STRING_HEADER_SIZE);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, LOAD<u32,u64>(powers10, kappa) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (1) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d, STRING_HEADER_SIZE);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= LOAD<u32,u64>(powers10, -kappa);\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n\n  return len;\n}\n\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign), STRING_HEADER_SIZE);\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16), STRING_HEADER_SIZE);\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0, STRING_HEADER_SIZE);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16), STRING_HEADER_SIZE);\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + STRING_HEADER_SIZE + 2,\n      ptr + STRING_HEADER_SIZE,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT, STRING_HEADER_SIZE);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + STRING_HEADER_SIZE + (offset << 1),\n      buffer + STRING_HEADER_SIZE,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16), STRING_HEADER_SIZE);\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0, STRING_HEADER_SIZE);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, STRING_HEADER_SIZE + 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + STRING_HEADER_SIZE + 4,\n      buffer + STRING_HEADER_SIZE + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, STRING_HEADER_SIZE + 2);\n    store<u16>(buffer + len, CharCode.e,   STRING_HEADER_SIZE + 2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nexport function dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = <i32>(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS, STRING_HEADER_SIZE);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n      len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return "0.0";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return "NaN";\n    return select<String>("-Infinity", "Infinity", value < 0);\n  }\n  var buffer = allocateUnsafeString(MAX_DOUBLE_LENGTH);\n  var length = dtoa_core(changetype<usize>(buffer), value);\n  var result = buffer.substring(0, length);\n  freeUnsafeString(buffer);\n  return result;\n}\n\nexport function itoa_stream<T>(buffer: usize, offset: usize, value: T): u32 {\n  buffer += (offset << 1);\n  if (!value) {\n    store<u16>(buffer, CharCode._0, STRING_HEADER_SIZE);\n    return 1;\n  }\n  var decimals: u32 = 0;\n  if (isSigned<T>()) {\n    let sign = value < 0;\n    if (sign) value = -value;\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value) + <u32>sign;\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32) + <u32>sign;\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value) + <u32>sign;\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n    if (sign) store<u16>(buffer, CharCode.MINUS, STRING_HEADER_SIZE);\n  } else {\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value);\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32);\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value);\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_stream(buffer: usize, offset: usize, value: f64): u32 {\n  buffer += (offset << 1);\n  if (value == 0.0) {\n    store<u16>(buffer, CharCode._0,  STRING_HEADER_SIZE + 0);\n    store<u16>(buffer, CharCode.DOT, STRING_HEADER_SIZE + 2);\n    store<u16>(buffer, CharCode._0,  STRING_HEADER_SIZE + 4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N, STRING_HEADER_SIZE + 0);\n      store<u16>(buffer, CharCode.a, STRING_HEADER_SIZE + 2);\n      store<u16>(buffer, CharCode.N, STRING_HEADER_SIZE + 4);\n      return 3;\n    } else {\n      let sign = <i32>(value < 0);\n      let len  = 8 + sign;\n      let source = changetype<usize>(select<String>("-Infinity", "Infinity", sign));\n      memory.copy(buffer + STRING_HEADER_SIZE, source + STRING_HEADER_SIZE, len << 1);\n      return len;\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n',"internal/sort":"import {\n  LOAD,\n  STORE\n} from \"./arraybuffer\";\n\nimport {\n  compareUnsafe\n} from \"./string\";\n\n/** Obtains the default comparator for the specified value type. */\n@inline\nexport function COMPARATOR<T>(): (a: T, b: T) => i32 {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a: T, b: T): i32 => (<i32>(a - b));\n    } else {\n      return (a: T, b: T): i32 => (<i32>(a > b) - <i32>(a < b));\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a: T, b: T): i32 => {\n        var ia = reinterpret<i32>(a);\n        var ib = reinterpret<i32>(b);\n        ia ^= (ia >> 31) >>> 1;\n        ib ^= (ib >> 31) >>> 1;\n        return <i32>(ia > ib) - <i32>(ia < ib);\n      };\n    } else {\n      return (a: T, b: T): i32 => {\n        var ia = reinterpret<i64>(a);\n        var ib = reinterpret<i64>(b);\n        ia ^= (ia >> 63) >>> 1;\n        ib ^= (ib >> 63) >>> 1;\n        return <i32>(ia > ib) - <i32>(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a: T, b: T): i32 => {\n      if (a === b || a === null || b === null) return 0;\n      var alen = (<string>a).length;\n      var blen = (<string>b).length;\n      if (!alen && !blen) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      return compareUnsafe(<string>a, 0, <string>b, 0, <usize>min(alen, blen));\n    };\n  } else {\n    return (a: T, b: T): i32 => (<i32>(a > b) - <i32>(a < b));\n  }\n}\n\n@inline\nexport function SORT<T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32,\n  length: i32,\n  comparator: (a: T, b: T) => i32\n): void {\n  if (isReference<T>()) {\n    // TODO replace this to faster stable sort (TimSort) when it implemented\n    insertionSort<T>(buffer, byteOffset, length, comparator);\n  } else {\n    if (length < 256) {\n      insertionSort<T>(buffer, byteOffset, length, comparator);\n    } else {\n      weakHeapSort<T>(buffer, byteOffset, length, comparator);\n    }\n  }\n}\n\n/** Sorts an Array with the 'Insertion Sort' algorithm. */\nfunction insertionSort<T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32,\n  length: i32,\n  comparator: (a: T, b: T) => i32\n): void {\n  for (let i = 0; i < length; i++) {\n    let a = LOAD<T>(buffer, i, byteOffset);       // a = arr[i]\n    let j = i - 1;\n    while (j >= 0) {\n      let b = LOAD<T>(buffer, j, byteOffset);     // b = arr[j]\n      if (comparator(a, b) < 0) {\n        STORE<T>(buffer, j-- + 1, b, byteOffset); // arr[j + 1] = b\n      } else break;\n    }\n    STORE<T>(buffer, j + 1, a, byteOffset);       // arr[j + 1] = a\n  }\n}\n\n/** Sorts an Array with the 'Weak Heap Sort' algorithm. */\nfunction weakHeapSort<T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32,\n  length: i32,\n  comparator: (a: T, b: T) => i32\n): void {\n  const shift32 = alignof<u32>();\n\n  var bitsetSize = (length + 31) >> 5 << shift32;\n  var bitset = memory.allocate(bitsetSize); // indexed in 32-bit chunks below\n  memory.fill(bitset, 0, bitsetSize);\n\n  // see: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.21.1863&rep=rep1&type=pdf\n\n  for (let i = length - 1; i > 0; i--) {\n    let j = i;\n    while ((j & 1) == (load<u32>(bitset + (j >> 6 << shift32)) >> (j >> 1 & 31) & 1)) j >>= 1;\n\n    let p = j >> 1;\n    let a = LOAD<T>(buffer, p, byteOffset);  // a = arr[p]\n    let b = LOAD<T>(buffer, i, byteOffset);  // b = arr[i]\n    if (comparator(a, b) < 0) {\n      store<u32>(\n        bitset + (i >> 5 << shift32),\n        load<u32>(bitset + (i >> 5 << shift32)) ^ (1 << (i & 31))\n      );\n      STORE<T>(buffer, i, a, byteOffset);    // arr[i] = a\n      STORE<T>(buffer, p, b, byteOffset);    // arr[p] = b\n    }\n  }\n\n  for (let i = length - 1; i >= 2; i--) {\n    let a = LOAD<T>(buffer, 0, byteOffset);\n    STORE<T>(buffer, 0, LOAD<T>(buffer, i, byteOffset), byteOffset);\n    STORE<T>(buffer, i, a, byteOffset);\n\n    let x = 1, y: i32;\n    while ((y = (x << 1) + ((load<u32>(bitset + (x >> 5 << shift32)) >> (x & 31)) & 1)) < i) x = y;\n\n    while (x > 0) {\n      a = LOAD<T>(buffer, 0, byteOffset);     // a = arr[0]\n      let b = LOAD<T>(buffer, x, byteOffset); // b = arr[x]\n\n      if (comparator(a, b) < 0) {\n        store<u32>(\n          bitset + (x >> 5 << shift32),\n          load<u32>(bitset + (x >> 5 << shift32)) ^ (1 << (x & 31))\n        );\n        STORE<T>(buffer, x, a, byteOffset);    // arr[x] = a\n        STORE<T>(buffer, 0, b, byteOffset);    // arr[0] = b\n      }\n      x >>= 1;\n    }\n  }\n\n  memory.free(bitset);\n\n  var t = LOAD<T>(buffer, 1, byteOffset); // t = arr[1]\n  STORE<T>(buffer, 1, LOAD<T>(buffer, 0, byteOffset), byteOffset);\n  STORE<T>(buffer, 0, t, byteOffset); // arr[0] = t\n}\n","internal/string":'import { MAX_SIZE_32 } from "./allocator";\nimport { String } from "../string";\n\n/** Size of a String header. */\n@inline export const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\n/** Maximum length of a String. */\n@inline export const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(length: i32): String {\n  assert(length > 0 && length <= MAX_LENGTH);\n  var buffer: usize;\n  if (isManaged<String>()) {\n    buffer = __gc_allocate(HEADER_SIZE + (<usize>length << 1), __gc);  // tslint:disable-line\n  } else {\n    buffer = memory.allocate(HEADER_SIZE + (<usize>length << 1));\n  }\n  store<i32>(buffer, length);\n  return changetype<String>(buffer);\n}\n\n@inline\nexport function freeUnsafe(buffer: String): void {\n  if (!isManaged<String>()) {\n    assert(buffer);\n    memory.free(changetype<usize>(buffer));\n  }\n}\n\nexport function copyUnsafe(dest: String, destOffset: usize, src: String, srcOffset: usize, len: usize): void {\n  memory.copy(\n    changetype<usize>(dest) + (destOffset << 1) + HEADER_SIZE,\n    changetype<usize>(src)  + (srcOffset  << 1) + HEADER_SIZE,\n    len << 1\n  );\n}\n\nexport function compareUnsafe(str1: String, offset1: usize, str2: String, offset2: usize, len: usize): i32 {\n  var cmp: i32 = 0;\n  var ptr1 = changetype<usize>(str1) + (offset1 << 1);\n  var ptr2 = changetype<usize>(str2) + (offset2 << 1);\n  while (len && !(cmp = <i32>load<u16>(ptr1, HEADER_SIZE) - <i32>load<u16>(ptr2, HEADER_SIZE))) {\n    --len, ptr1 += 2, ptr2 += 2;\n  }\n  return cmp;\n}\n\nexport function repeatUnsafe(dest: String, destOffset: usize, src: String, count: i32): void {\n  var length = src.length;\n  if (ASC_SHRINK_LEVEL > 1) {\n    let strLen = length << 1;\n    let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\n    let from = changetype<usize>(src)  + HEADER_SIZE;\n    for (let i = 0, len = strLen * count; i < len; i += strLen) {\n      memory.copy(to + i, from, strLen);\n    }\n  } else {\n    switch (length) {\n      case 0: break;\n      case 1: {\n        let cc =  load<u16>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u16>(out + (i << 1), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      case 2: {\n        let cc  = load<u32>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u32>(out + (i << 2), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      case 3: {\n        let cc1 = load<u32>(changetype<usize>(src), HEADER_SIZE + 0);\n        let cc2 = load<u16>(changetype<usize>(src), HEADER_SIZE + 4);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u32>(out + (i << 2), cc1, HEADER_SIZE + 0);\n          store<u16>(out + (i << 1), cc2, HEADER_SIZE + 4);\n        }\n        break;\n      }\n      case 4: {\n        let cc = load<u64>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u64>(out + (i << 3), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      default: {\n        let strLen = length << 1;\n        let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\n        let from = changetype<usize>(src)  + HEADER_SIZE;\n        for (let i = 0, len = strLen * count; i < len; i += strLen) {\n          memory.copy(to + i, from, strLen);\n        }\n        break;\n      }\n    }\n  }\n}\n\n// Helpers\n\n@inline export const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n    case 9:    // <TAB>\n    case 10:   // <LF>\n    case 13:   // <CR>\n    case 11:   // <VT>\n    case 12:   // <FF>\n    case 32:   // <SP>\n    case 160:  // <NBSP>\n    case 8232: // <LS>\n    case 8233: // <PS>\n    case 65279: return true; // <ZWNBSP>\n    default: return false;\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len) return <T>NaN;\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    return <T>NaN;\n  }\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else break;\n    if (code >= radix) break;\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n',"internal/typedarray":'import {\n  HEADER_SIZE as AB_HEADER_SIZE,\n  MAX_BLENGTH as AB_MAX_BLENGTH,\n  allocateUnsafe,\n  LOAD,\n  STORE\n} from "./arraybuffer";\n\nimport {\n  SORT as SORT_IMPL\n} from "./sort";\n\n/** Typed array base class. Not a global object. */\nexport abstract class TypedArray<T> {\n  [key: number]: T; // compatibility only\n\n  readonly buffer: ArrayBuffer;\n  readonly byteOffset: i32;\n  readonly byteLength: i32;\n\n  constructor(length: i32) {\n    const MAX_LENGTH = <u32>AB_MAX_BLENGTH / sizeof<T>();\n    if (<u32>length > MAX_LENGTH) throw new RangeError("Invalid typed array length");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    memory.fill(changetype<usize>(buffer) + AB_HEADER_SIZE, 0, <usize>byteLength);\n    this.buffer = buffer;\n    this.byteOffset = 0;\n    this.byteLength = byteLength;\n  }\n\n  @inline\n  get length(): i32 {\n    return this.byteLength >>> alignof<T>();\n  }\n\n  @operator("[]")\n  protected __get(index: i32): T {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error("Index out of bounds");\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @inline @operator("{}")\n  protected __unchecked_get(index: i32): T {\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @operator("[]=")\n  protected __set(index: i32, value: native<T>): void {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error("Index out of bounds");\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  @inline @operator("{}=")\n  protected __unchecked_set(index: i32, value: native<T>): void {\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\n}\n\n@inline\nexport function FILL<TArray extends TypedArray<T>, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) {\n      memory.fill(\n        changetype<usize>(buffer) + start + byteOffset + AB_HEADER_SIZE,\n        <u8>value,\n        <usize>(end - start)\n      );\n    }\n  } else {\n    for (; start < end; ++start) {\n      STORE<T,native<T>>(buffer, start, value, byteOffset);\n    }\n  }\n  return array;\n}\n\n@inline\nexport function SORT<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var byteOffset = array.byteOffset;\n  var length = array.length;\n  if (length <= 1) return array;\n  var buffer = array.buffer;\n  if (length == 2) {\n    let a = LOAD<T>(buffer, 1, byteOffset);\n    let b = LOAD<T>(buffer, 0, byteOffset);\n    if (comparator(a, b) < 0) {\n      STORE<T>(buffer, 1, b, byteOffset);\n      STORE<T>(buffer, 0, a, byteOffset);\n    }\n    return array;\n  }\n  SORT_IMPL<T>(buffer, byteOffset, length, comparator);\n  return array;\n}\n\n@inline\nexport function SUBARRAY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var length = <i32>array.length;\n  if (begin < 0) begin = max(length + begin, 0);\n  else begin = min(begin, length);\n  if (end < 0) end = max(length + end, begin);\n  else end = max(min(end, length), begin);\n  var slice = memory.allocate(offsetof<TArray>());\n  store<usize>(slice, array.buffer, offsetof<TArray>("buffer"));\n  store<i32>(slice, <i32>array.byteOffset + (begin << alignof<T>()), offsetof<TArray>("byteOffset"));\n  store<i32>(slice, (end - begin) << alignof<T>(), offsetof<TArray>("byteLength"));\n  return changetype<TArray>(slice);\n}\n\n@inline\nexport function REDUCE<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    initialValue = callbackfn(\n      initialValue,\n      LOAD<T>(buffer, i, byteOffset),\n      i,\n      array,\n    );\n  }\n  return initialValue;\n}\n\n@inline\nexport function REDUCE_RIGHT<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = callbackfn(\n      initialValue,\n      LOAD<T>(buffer, i, byteOffset),\n      i,\n      array,\n    );\n  }\n  return initialValue;\n}\n\n@inline\nexport function MAP<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var result = instantiate<TArray>(length);\n  var resultBuffer = result.buffer;\n  for (let i = 0; i < length; i++) {\n    STORE<T, native<T>>(resultBuffer, i, <native<T>>callbackfn(LOAD<T>(buffer, i, byteOffset), i, array));\n  }\n\n  return result;\n}\n\n@inline\nexport function FIND_INDEX<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n@inline\nexport function SOME<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n@inline\nexport function EVERY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\n@inline\nexport function FOREACH<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    callbackfn(LOAD<T>(buffer, i, byteOffset), i, array);\n  }\n}\n\n@inline\nexport function REVERSE<TArray extends TypedArray<T>, T>(array: TArray): TArray {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n\n  for (let front = 0, back = array.length - 1; front < back; ++front, --back) {\n    let temp = LOAD<T>(buffer, front, byteOffset);\n    STORE<T>(buffer, front, LOAD<T>(buffer, back, byteOffset), byteOffset);\n    STORE<T>(buffer, back, temp, byteOffset);\n  }\n  return array;\n}\n',iterator:"export abstract class Iterable<T> {\n  // ?\n}\n\n@sealed\nexport abstract class Iterator<T> {\n\n  // private constructor(iterable: Iterable<T>) {\n  // }\n\n  // TODO: these need to evaluate the classId at the respective reference in order to obtain the\n  // next value, i.e. arrays work differently than maps. we'd then have:\n  //\n  // ╒═══════════════════ Iterator layout (32-bit) ══════════════════╕\n  //    3                   2                   1\n  //  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n  // ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n  // │                             index                             │\n  // ├─────────────────────────────────────────────────────────┬───┬─┤\n  // │                           reference                     │ 0 │D│\n  // └─────────────────────────────────────────────────────────┴───┴─┘\n  // D: Done flag\n\n  // get value(this: u64): T {\n  //   ?\n  // }\n\n  // next(this: u64): Iterator<T> {\n  //   ?\n  // }\n\n  done(this: u64): bool {\n    return <bool>(this & 1);\n  }\n}\n",map:'import {\n  HEADER_SIZE as HEADER_SIZE_AB\n} from "./internal/arraybuffer";\n\nimport {\n  HASH\n} from "./internal/hash";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n@inline const INITIAL_CAPACITY = 4;\n@inline const FILL_FACTOR: f64 = 8 / 3;\n@inline const FREE_FACTOR: f64 = 3 / 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n@inline function ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n@inline function ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets holding references to the respective first entry within\n  private buckets: ArrayBuffer; // usize[bucketsMask + 1]\n  private bucketsMask: u32;\n\n  // entries in insertion order\n  private entries: ArrayBuffer; // MapEntry<K,V>[entriesCapacity]\n  private entriesCapacity: i32;\n  private entriesOffset: i32;\n  private entriesCount: i32;\n\n  get size(): i32 { return this.entriesCount; }\n\n  constructor() { this.clear(); }\n\n  clear(): void {\n    const bucketsSize = INITIAL_CAPACITY * <i32>BUCKET_SIZE;\n    this.buckets = new ArrayBuffer(bucketsSize);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    const entriesSize = INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>();\n    this.entries = new ArrayBuffer(entriesSize, true);\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>(\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE,\n      HEADER_SIZE_AB\n    );\n    while (entry) {\n      if (!(entry.taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(entry.taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) !== null;\n  }\n\n  get(key: K): V {\n    var entry = this.find(key, HASH<K>(key));\n    return entry ? entry.value : <V>unreachable();\n  }\n\n  set(key: K, value: V): void {\n    var hashCode = HASH<K>(key);\n    var entry = this.find(key, hashCode);\n    if (entry) {\n      entry.value = value;\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(\n        changetype<usize>(entries) + HEADER_SIZE_AB + this.entriesOffset++ * ENTRY_SIZE<K,V>()\n      );\n      entry.key = key;\n      entry.value = value;\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase, HEADER_SIZE_AB);\n      store<usize>(bucketPtrBase, changetype<usize>(entry), HEADER_SIZE_AB);\n      if (isManaged<K>()) __gc_link(changetype<usize>(this), changetype<usize>(key)); // tslint:disable-line\n      if (isManaged<V>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n    }\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = <i32>(newBucketsCapacity * FILL_FACTOR);\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>(), true);\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries) + HEADER_SIZE_AB;\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries) + HEADER_SIZE_AB;\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        newEntry.key = oldEntry.key;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntry.key) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase, HEADER_SIZE_AB);\n        store<usize>(newBucketPtrBase, newPtr, HEADER_SIZE_AB);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  toString(): string {\n    return "[object Map]";\n  }\n\n  private __gc(): void {\n    __gc_mark(changetype<usize>(this.buckets)); // tslint:disable-line\n    var entries = this.entries;\n    __gc_mark(changetype<usize>(entries)); // tslint:disable-line\n    if (isManaged<K>() || isManaged<V>()) {\n      let offset: usize = 0;\n      let end: usize = this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (offset < end) {\n        let entry = changetype<MapEntry<K,V>>(\n          changetype<usize>(entries) + HEADER_SIZE_AB + offset * ENTRY_SIZE<K,V>()\n        );\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) __gc_mark(changetype<usize>(entry.key)); // tslint:disable-line\n          if (isManaged<V>()) __gc_mark(changetype<usize>(entry.value)); // tslint:disable-line\n        }\n        offset += ENTRY_SIZE<K,V>();\n      }\n    }\n  }\n}\n',math:'import * as JSMath from "./bindings/Math";\nexport { JSMath };\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from "./builtins";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n// TODO: sin, cos, tan for Math namespace\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n@inline function expo2(x: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  return NativeMath.exp(x - kln2) * scale * scale;\n}\n\n/** @internal */\n@lazy var random_seeded = false;\n@lazy var random_state0_64: u64;\n@lazy var random_state1_64: u64;\n@lazy var random_state0_32: u32;\n@lazy var random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  @lazy export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n  @lazy export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n  @lazy export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n  @lazy export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n  @lazy export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n  @lazy export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n  @lazy export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n  @lazy export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  @inline\n  export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    var s: f64, w: f64, z: f64;\n    if (hx >> 31) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    var c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    var e = reinterpret<u64>(x) >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // var z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    var z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z);\n    var r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    if (hx >> 31) return -x;\n    return x;\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var ix = <u32>(reinterpret<u64>(x) >> 32);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var s = u >> 63;\n    u &= 0x7FFFFFFFFFFFFFFF;\n    var y = reinterpret<f64>(u);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var lx = <u32>u;\n    u = reinterpret<u64>(y);\n    var iy = <u32>(u >> 32);\n    var ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        switch (m) {\n          case 0: return  PI / 4;\n          case 1: return -PI / 4;\n          case 2: return  3 * PI / 4;\n          case 3: return -3 * PI / 4;\n        }\n      } else {\n        switch (m) {\n          case 0: return  0.0;\n          case 1: return -0.0;\n          case 2: return  PI;\n          case 3: return -PI;\n        }\n      }\n    }\n    var z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    var t = reinterpret<f64>(u);\n    var r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    var s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(\n      <i32><i64>(x - 4294967296 * builtin_floor(x * (1.0 / 4294967296)))\n    );\n  }\n\n  export function cos(x: f64): f64 { // TODO\n    unreachable();\n    return 0;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n      P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n      P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n      P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n      P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n      overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n      underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var sign_ = <i32>(hx >> 31);\n    hx &= 0x7FFFFFFF;\n    if (hx >= 0x4086232B) {\n      if (isNaN(x)) return x;\n      if (x > overflow)  return x * Ox1p1023;\n      if (x < underflow) return 0;\n    }\n    var hi: f64, lo: f64 = 0;\n    var k = 0;\n    if (hx > 0x3FD62E42) {\n      if (hx >= 0x3FF0A2B2) {\n        k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));\n      } else {\n        k = 1 - (sign_ << 1);\n      }\n      hi = x - k * ln2hi;\n      lo = k * ln2lo;\n      x = hi - lo;\n    } else if (hx > 0x3E300000) {\n      hi = x;\n    } else return 1.0 + x;\n    var xs = x * x;\n    // var c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n    var xq = xs * xs;\n    var c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n    var y = 1.0 + (x * c / (2 - c) - lo + hi);\n    if (k == 0) return y;\n    return scalbn(y, k);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32 & 0x7FFFFFFF);\n    var k = 0, sign_ = <i32>(u >> 63);\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    var c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    var hfx = 0.5 * x;\n    var hxs = x * hfx;\n    // var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    var hxq = hxs * hxs;\n    var r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    var twopk = reinterpret<f64>(u);\n    var y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  @inline\n  export function fround(x: f64): f32 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    var ex = <i32>(ux >> 52);\n    var ey = <i32>(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    var z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    var c = x * SPLIT;\n    var h = x - c + c;\n    var l = x - h;\n    var hx = x * x;\n    var lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    var hy = y * y;\n    var ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    const inv32 = 1.0 / 4294967296;\n    return (\n      <i32><i64>(x - 4294967296 * builtin_floor(x * inv32)) *\n      <i32><i64>(y - 4294967296 * builtin_floor(y * inv32))\n    );\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31)    return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) return x;\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += (<i32>hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = k;\n    return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) return x;\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln10hi;\n    var dk = <f64>k;\n    var y = dk * log10_2hi;\n    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 1;\n    var c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = <u32>(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = <i32>(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n      ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n      Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54  = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) return x;\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln2hi;\n    var val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n    var y = <f64>k;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    val_hi = w;\n    return val_lo + val_hi;\n  }\n\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    const\n      dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n      dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n      two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n      huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n      tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n      L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n      L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n      L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n      L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n      L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n      L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n      P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n      P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n      P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n      P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n      P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n      lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n      lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n      lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n      ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n      cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n      cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n      cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n      ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n      ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n      inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n    var u_ = reinterpret<u64>(x);\n    var hx = <i32>(u_ >> 32);\n    var lx = <u32>u_;\n    u_ = reinterpret<u64>(y);\n    var hy = <i32>(u_ >> 32);\n    var ly = <u32>u_;\n    var ix = hx & 0x7FFFFFFF;\n    var iy = hy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n    // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n    if ( // NaN if either arg is NaN\n      ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n      iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n    ) return x + y;\n    var yisint = 0, k: i32;\n    if (hx < 0) {\n      if (iy >= 0x43400000) yisint = 2;\n      else if (iy >= 0x3FF00000) {\n        k = (iy >> 20) - 0x3FF;\n        let kcond = k > 20;\n        let offset = select<i32>(52, 20, kcond) - k;\n        let Ly = select<i32>(ly, iy, kcond);\n        let jj = Ly >> offset;\n        if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n      }\n    }\n    if (ly == 0) {\n      if (iy == 0x7FF00000) { // y is +-inf\n        if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n        else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n        else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n      }\n      if (iy == 0x3FF00000) {\n        if (hy >= 0) return x;\n        return 1 / x;\n      }\n      if (hy == 0x40000000) return x * x;\n      if (hy == 0x3FE00000) {\n        if (hx >= 0) return builtin_sqrt(x);\n      }\n    }\n    var ax = builtin_abs<f64>(x), z: f64;\n    if (lx == 0) {\n      if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n        z = ax;\n        if (hy < 0) z = 1.0 / z;\n        if (hx < 0) {\n          if (((ix - 0x3FF00000) | yisint) == 0) {\n            let d = z - z;\n            z = d / d;\n          } else if (yisint == 1) z = -z;\n        }\n        return z;\n      }\n    }\n    var s = 1.0;\n    if (hx < 0) {\n      if (yisint == 0) {\n        let d = x - x;\n        return d / d;\n      }\n      if (yisint == 1) s = -1.0;\n    }\n    var t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n    var j: i32, n: i32;\n    if (iy > 0x41E00000) {\n      if (iy > 0x43F00000) {\n        if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n        if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n      }\n      if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n      if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n      t = ax - 1.0;\n      w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n      u = ivln2_h * t;\n      v = t * ivln2_l - w * ivln2;\n      t1 = u + v;\n      t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n      t2 = v - (t1 - u);\n    } else {\n      let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n      n = 0;\n      if (ix < 0x00100000) {\n        ax *= two53;\n        n -= 53;\n        ix = <u32>(reinterpret<u64>(ax) >> 32);\n      }\n      n += (ix >> 20) - 0x3FF;\n      j = ix & 0x000FFFFF;\n      ix = j | 0x3FF00000;\n      if (j <= 0x3988E) k = 0;\n      else if (j < 0xBB67A) k = 1;\n      else {\n        k = 0;\n        n += 1;\n        ix -= 0x00100000;\n      }\n      ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n      let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n      u = ax - bp;\n      v = 1.0 / (ax + bp);\n      ss = u * v;\n      s_h = ss;\n      s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n      t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n      t_l = ax - (t_h - bp);\n      s_l = v * ((u - s_h * t_h) - s_h * t_l);\n      s2 = ss * ss;\n      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n      r += s_l * (s_h + ss);\n      s2 = s_h * s_h;\n      t_h = 3.0 + s2 + r;\n      t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n      t_l = r - ((t_h - 3.0) - s2);\n      u = s_h * t_h;\n      v = s_l * t_h + t_l * ss;\n      p_h = u + v;\n      p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n      p_l = v - (p_h - u);\n      let z_h = cp_h * p_h;\n      let dp_l = select<f64>(dp_l1, 0.0, k);\n      let z_l = cp_l * p_h + p_l * cp + dp_l;\n      t = <f64>n;\n      let dp_h = select<f64>(dp_h1, 0.0, k);\n      t1 = ((z_h + z_l) + dp_h) + t;\n      t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n      t2 = z_l - (((t1 - t) - dp_h) - z_h);\n    }\n    var y1 = y;\n    y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n    p_l = (y - y1) * t1 + y * t2;\n    p_h = y1 * t1;\n    z = p_l + p_h;\n    u_ = reinterpret<u64>(z);\n    j = <u32>(u_ >> 32);\n    var i = <i32>u_;\n    if (j >= 0x40900000) {\n      if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n      if (p_l + ovt > z - p_h) return s * huge * huge;\n    } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n      if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n      if (p_l <= z - p_h) return s * tiny * tiny;\n    }\n    i = j & 0x7FFFFFFF;\n    k = (i >> 20) - 0x3FF;\n    n = 0;\n    if (i > 0x3FE00000) {\n      n = j + (0x00100000 >> (k + 1));\n      k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n      t = 0.0;\n      t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);\n      n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n      if (j < 0) n = -n;\n      p_h -= t;\n    }\n    t = p_l + p_h;\n    t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n    u = t * lg2_h;\n    v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n    z = u + v;\n    w = v - (z - u);\n    t = z * z;\n    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n    r = (z * t1) / (t1 - 2.0) - (w + z * w);\n    z = 1.0 - (r - z);\n    j = <u32>(reinterpret<u64>(z) >> 32);\n    j += n << 20;\n    if ((j >> 20) <= 0) z = scalbn(z, n);\n    else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n    return s * z;\n  }\n\n  export function seedRandom(value: i64): void {\n    assert(value);\n    random_seeded = true;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n  }\n\n  export function random(): f64 { // see: v8/src/base/random-number-generator.cc\n    if (!random_seeded) throw new Error("PRNG must be seeded.");\n    var s1 = random_state0_64;\n    var s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    var r = ((s0 + s1) & 0x000FFFFFFFFFFFFF) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  @inline\n  export function round(x: f64): f64 {\n    return builtin_copysign<f64>(builtin_floor<f64>(x + 0.5), x);\n  }\n\n  @inline\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f64>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  @inline\n  export function signbit(x: f64): bool {\n    // In ECMAScript all NaN values are indistinguishable from each other\n    // so we need handle NaN and negative NaN in similar way\n    return <bool>(<i32>(reinterpret<u64>(x) >>> 63) & (x == x));\n  }\n\n  export function sin(x: f64): f64 { // TODO\n    unreachable();\n    return 0;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    var u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    var absx = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    var h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      t = expm1(absx);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    t = 2 * h * expo2(absx);\n    return t;\n  }\n\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // TODO\n    unreachable();\n    return 0;\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    var y = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n    var y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      /* make sure final n < -53 to avoid double\n       rounding in the subnormal range */\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = ux >> 63;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      if (ux1 == uy1) return 0 * x;\n      return x;\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= -ex + 1;\n    } else {\n      ux &= <u64>-1 >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    var shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    ux |= sx << 63;\n    return reinterpret<f64>(ux);\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = <i32>(ux >> 63);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    var uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= -ex + 1;\n    } else {\n      uxi &= <u64>-1 >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    var q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n  // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return sx ? -x : x;\n  }\n}\n\n/** @internal */\n@lazy var rempio2f_y: f64;\n@lazy const PIO2_TABLE: u64[] = [\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n];\n\n/** @internal */\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n  var p = z * (pS0 + z * (pS1 + z * pS2));\n  var q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n@inline function expo2f(x: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  var scale = reinterpret<f32>(<u32>(0x7F + (k >> 1)) << 23);\n  return NativeMathf.exp(x - kln2) * scale * scale;\n}\n\n@inline /** @internal */\nfunction pio2_large_quot(x: f32, u: i32): i32 {       // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // π * 0x1p-65 = 8.51530395021638647334e-20\n  const bits = PIO2_TABLE;\n\n  var offset = (u >> 23) - 152;\n  var index  = offset >> 6;\n  var shift  = offset & 63;\n\n  var b0 = unchecked(bits[index + 0]);\n  var b1 = unchecked(bits[index + 1]);\n  var lo: u64;\n\n  if (shift > 32) {\n    let b2 = unchecked(bits[index + 2]);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  var hi = (b1 >> (64 - shift)) | (b0 << shift);\n  var mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  var product: u64 = mantissa * hi + (mantissa * lo >> 32);\n  var r: i64 = product << 2;\n  var q: i32 = <i32>((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n@inline /** @internal */\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 {   // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const pi2hi = reinterpret<f64>(0x3FF921FB50000000); // 1.57079631090164184570\n  const pi2lo = reinterpret<f64>(0x3E5110B4611A6263); // 1.58932547735281966916e-8\n  const _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { /* π * 0x1p28 */\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  var q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/* |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]). */\n@inline /** @internal */\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const S1 = reinterpret<f64>(0xBFC5555554CBAC77); // -0x15555554cbac77.0p-55\n  const S2 = reinterpret<f64>(0x3F811110896EFBB2); //  0x111110896efbb2.0p-59\n  const S3 = reinterpret<f64>(0xBF2A00F9E2CAE774); // -0x1a00f9e2cae774.0p-65\n  const S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  var z = x * x;\n  var w = z * z;\n  var r = S3 + z * S4;\n  var s = z * x;\n  return <f32>((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n/* |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]). */\n@inline /** @internal */\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81); // -0x1ffffffd0c5e81.0p-54\n  const C1 = reinterpret<f64>(0x3FA55553E1053A42); //  0x155553e1053a42.0p-57\n  const C2 = reinterpret<f64>(0xBF56C087E80F1E27); // -0x16c087e80f1e27.0p-62\n  const C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  var z = x * x;\n  var w = z * z;\n  var r = C2 + z * C3;\n  return <f32>(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n/* |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]). */\n@inline /** @internal */\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n\n  const T0 = reinterpret<f64>(0x3FD5554D3418C99F); /* 0x15554d3418c99f.0p-54 */\n  const T1 = reinterpret<f64>(0x3FC112FD38999F72); /* 0x1112fd38999f72.0p-55 */\n  const T2 = reinterpret<f64>(0x3FAB54C91D865AFE); /* 0x1b54c91d865afe.0p-57 */\n  const T3 = reinterpret<f64>(0x3F991DF3908C33CE); /* 0x191df3908c33ce.0p-58 */\n  const T4 = reinterpret<f64>(0x3F685DADFCECF44E); /* 0x185dadfcecf44e.0p-61 */\n  const T5 = reinterpret<f64>(0x3F8362B9BF971BCD); /* 0x1362b9bf971bcd.0p-59 */\n\n  var z = x * x;\n  var r = T4 + z * T5;\n  var t = T2 + z * T3;\n  var w = z * z;\n  var s = z * x;\n  var u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return <f32>(odd ? -1 / r : r);\n}\n\nexport namespace NativeMathf {\n\n  @lazy export const E       = <f32>NativeMath.E;\n  @lazy export const LN2     = <f32>NativeMath.LN2;\n  @lazy export const LN10    = <f32>NativeMath.LN10;\n  @lazy export const LOG2E   = <f32>NativeMath.LOG2E;\n  @lazy export const LOG10E  = <f32>NativeMath.LOG10E;\n  @lazy export const PI      = <f32>NativeMath.PI;\n  @lazy export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n  @lazy export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  /** Used as return values from Mathf.sincos */\n  @lazy export var sincos_sin: f32 = 0;\n  @lazy export var sincos_cos: f32 = 0;\n\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = reinterpret<u32>(x);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    var z: f32, w: f32, s: f32;\n    if (hx >> 31) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    var df = reinterpret<f32>(hx & 0xFFFFF000);\n    var c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x);\n    var a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) {\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (a < 0x3F800000 + (12 << 23)) return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var sx = x;\n    var hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    var z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z); // sic\n    x = <f32>(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var ix = reinterpret<u32>(x);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * aT4));\n    var s2 = w * (aT1 + w * aT3);\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var ix = reinterpret<u32>(x);\n    var iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        switch (m) {\n          case 0: return  pi / 4;\n          case 1: return -pi / 4;\n          case 2: return  3 * pi / 4;\n          case 3: return -3 * pi / 4;\n        }\n      } else {\n        switch (m) {\n          case 0: return  0;\n          case 1: return -0;\n          case 2: return  pi;\n          case 3: return -pi;\n        }\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    var z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    var t = <f64>reinterpret<f32>(u);\n    var r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return builtin_clz(\n      <i32><i64>(x - 4294967296 * builtin_floor(x * (1.0 / 4294967296)))\n    );\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const c1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\n    const c2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\n    const c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\n    const c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3f490fda) {  /* |x| ~<= π/4 */\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\n        /* raise inexact if x != 0 */\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407b53d1) {  /* |x| ~<= 5π/4 */\n        if (ix > 0x4016cbe3) { /* |x|  ~> 3π/4 */\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ix <= 0x40e231d5) {  /* |x| ~<= 9π/4 */\n        if (ix > 0x40afeddf) { /* |x|  ~> 7π/4 */\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    /* cos(Inf or NaN) is NaN */\n    if (ix >= 0x7f800000) return x - x;\n\n    /* general argument reduction needed */\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x);\n  }\n\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n      ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n      P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n      P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n      Ox1p127f = reinterpret<f32>(0x7F000000);\n    var hx = reinterpret<u32>(x);\n    var sign_ = <i32>(hx >> 31);\n    hx &= 0x7FFFFFFF;\n    if (hx >= 0x42AEAC50) {\n      if (hx >= 0x42B17218) {\n        if (!sign_) return x * Ox1p127f;\n        else if (hx >= 0x42CFF1B5) return 0;\n      }\n    }\n    var hi: f32, lo: f32;\n    var k: i32;\n    if (hx > 0x3EB17218) {\n      if (hx > 0x3F851592) {\n        k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));\n      } else {\n        k = 1 - (sign_ << 1);\n      }\n      hi = x - <f32>k * ln2hi;\n      lo = <f32>k * ln2lo;\n      x = hi - lo;\n    } else if (hx > 0x39000000) {\n      k = 0;\n      hi = x;\n      lo = 0;\n    } else {\n      return 1 + x;\n    }\n    var xx = x * x;\n    var c = x - xx * (P1 + xx * P2);\n    var y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n    if (k == 0) return y;\n    return scalbn(y, k);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f32>(0x42B17180), //  8.8721679688e+01f\n      ln2_hi      = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo      = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2      = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1          = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2          = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f    = reinterpret<f32>(0x7F000000);\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    var sign_ = <i32>(u >> 31);\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) {\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    var c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    var hfx: f32 = 0.5 * x;\n    var hxs: f32 = x * hfx;\n    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    var twopk = reinterpret<f32>(u);\n    var y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    var z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));\n  }\n\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    const inv32 = 1.0 / 4294967296;\n    return (\n      <i32><i64>(x - 4294967296 * builtin_floor(x * inv32)) *\n      <i32><i64>(y - 4294967296 * builtin_floor(y * inv32))\n    );\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n      ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n      Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n      Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n      Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n      Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n      Ox1p25f = reinterpret<f32>(0x4C000000);\n    var u = reinterpret<u32>(x);\n    var k = 0;\n    if (u < 0x00800000 || <bool>(u >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (u >> 31) return (x - x) / 0;\n      k -= 25;\n      x *= Ox1p25f;\n      u = reinterpret<u32>(x);\n    } else if (u >= 0x7F800000) return x;\n      else if (u == 0x3F800000) return 0;\n    u += 0x3F800000 - 0x3F3504F3;\n    k += <u32>(<i32>u >> 23) - 0x7F;\n    u = (u & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(u);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq = <f32>0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000);\n    var ix = reinterpret<u32>(x);\n    var k = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) return x;\n      else if (ix == 0x3F800000) return 0;\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    ix = reinterpret<u32>(hi);\n    ix &= 0xFFFFF000;\n    hi = reinterpret<f32>(ix);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n    var ix = reinterpret<u32>(x);\n    var c: f32 = 0, f: f32 = 0;\n    var k: i32 = 1;\n    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = <i32>(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n      ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n      Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f = reinterpret<f32>(0x4C000000);\n    var ix = reinterpret<u32>(x);\n    var k: i32 = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) return x;\n      else if (ix == 0x3F800000) return 0;\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    var u = reinterpret<u32>(hi);\n    u &= 0xFFFFF000;\n    hi = reinterpret<f32>(u);\n    var lo: f32 = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n  }\n\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 { // see: musl/src/math/powf.c and SUN COPYRIGHT NOTICE above\n    const\n      dp_h1   = reinterpret<f32>(0x3F15C000), //  5.84960938e-01f\n      dp_l1   = reinterpret<f32>(0x35D1CFDC), //  1.56322085e-06f\n      two24   = reinterpret<f32>(0x4B800000), //  16777216f\n      huge    = reinterpret<f32>(0x7149F2CA), //  1.0e+30f\n      tiny    = reinterpret<f32>(0x0DA24260), //  1.0e-30f\n      L1      = reinterpret<f32>(0x3F19999A), //  6.0000002384e-01f\n      L2      = reinterpret<f32>(0x3EDB6DB7), //  4.2857143283e-01f\n      L3      = reinterpret<f32>(0x3EAAAAAB), //  3.3333334327e-01f\n      L4      = reinterpret<f32>(0x3E8BA305), //  2.7272811532e-01f\n      L5      = reinterpret<f32>(0x3E6C3255), //  2.3066075146e-01f\n      L6      = reinterpret<f32>(0x3E53F142), //  2.0697501302e-01f\n      P1      = reinterpret<f32>(0x3E2AAAAB), //  1.6666667163e-01f\n      P2      = reinterpret<f32>(0xBB360B61), // -2.7777778450e-03f\n      P3      = reinterpret<f32>(0x388AB355), //  6.6137559770e-05f\n      P4      = reinterpret<f32>(0xB5DDEA0E), // -1.6533901999e-06f\n      P5      = reinterpret<f32>(0x3331BB4C), //  4.1381369442e-08f\n      lg2     = reinterpret<f32>(0x3F317218), //  6.9314718246e-01f\n      lg2_h   = reinterpret<f32>(0x3F317200), //  6.93145752e-01f\n      lg2_l   = reinterpret<f32>(0x35BFBE8C), //  1.42860654e-06f\n      ovt     = reinterpret<f32>(0x3338AA3C), //  4.2995665694e-08f\n      cp      = reinterpret<f32>(0x3F76384F), //  9.6179670095e-01\n      cp_h    = reinterpret<f32>(0x3F764000), //  9.6191406250e-01\n      cp_l    = reinterpret<f32>(0xB8F623C6), // -1.1736857402e-04\n      ivln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00\n      ivln2_h = reinterpret<f32>(0x3FB8AA00), //  1.4426879883e+00\n      ivln2_l = reinterpret<f32>(0x36ECA570), //  7.0526075433e-06\n      inv3    = reinterpret<f32>(0x3EAAAAAB);  // 0.333333333333\n    var hx = reinterpret<i32>(x);\n    var hy = reinterpret<i32>(y);\n    var ix = hx & 0x7FFFFFFF;\n    var iy = hy & 0x7FFFFFFF;\n    if (iy == 0) return 1.0; // x**0 = 1, even if x is NaN\n    // if (hx == 0x3F800000) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n    if (ix > 0x7F800000 || iy > 0x7F800000) return x + y; // NaN if either arg is NaN\n    var yisint  = 0, j: i32, k: i32;\n    if (hx < 0) {\n      if (iy >= 0x4B800000) yisint = 2;\n      else if (iy >= 0x3F800000) {\n        k = (iy >> 23) - 0x7F;\n        let ki = 23 - k;\n        j = iy >> ki;\n        if ((j << ki) == iy) yisint = 2 - (j & 1);\n      }\n    }\n    if (iy == 0x7F800000) { // y is +-inf\n      if (ix == 0x3F800000) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n      else if (ix > 0x3F800000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n      else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n    }\n    if (iy == 0x3F800000) return hy >= 0 ? x : 1.0 / x;\n    if (hy == 0x40000000) return x * x;\n    if (hy == 0x3F000000) {\n      if (hx >= 0) return builtin_sqrt<f32>(x);\n    }\n    var ax = builtin_abs<f32>(x);\n    var z: f32;\n    if (ix == 0x7F800000 || ix == 0 || ix == 0x3F800000) {\n      z = ax;\n      if (hy < 0) z = 1.0 / z;\n      if (hx < 0) {\n        if (((ix - 0x3F800000) | yisint) == 0) {\n          let d = z - z;\n          z = d / d;\n        }\n        else if (yisint == 1) z = -z;\n      }\n      return z;\n    }\n    var sn = <f32>1.0;\n    if (hx < 0) {\n      if (yisint == 0) {\n        let d = x - x;\n        return d / d;\n      }\n      if (yisint == 1) sn = -1.0;\n    }\n    var t1: f32, t2: f32, r: f32, s: f32, t: f32, u: f32, v: f32, w: f32, p_h: f32, p_l: f32;\n    var n: i32, is: i32;\n    if (iy > 0x4D000000) {\n      if (ix < 0x3F7FFFF8) return hy < 0 ? sn * huge * huge : sn * tiny * tiny;\n      if (ix > 0x3F800007) return hy > 0 ? sn * huge * huge : sn * tiny * tiny;\n      t = ax - 1;\n      w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n      u = ivln2_h * t;\n      v = t * ivln2_l - w * ivln2;\n      t1 = u + v;\n      is = reinterpret<i32>(t1);\n      t1 = reinterpret<f32>(is & 0xFFFFF000);\n      t2 = v - (t1 - u);\n    } else {\n      let s2: f32, s_h: f32, s_l: f32, t_h: f32, t_l: f32;\n      n = 0;\n      if (ix < 0x00800000) {\n        ax *= two24;\n        n -= 24;\n        ix = reinterpret<i32>(ax);\n      }\n      n += (ix >> 23) - 0x7F;\n      j = ix & 0x007FFFFF;\n      ix = j | 0x3F800000;\n      if (j <= 0x1CC471) k = 0;\n      else if (j < 0x5DB3D7) k = 1;\n      else {\n        k = 0;\n        n += 1;\n        ix -= 0x00800000;\n      }\n      ax = reinterpret<f32>(ix);\n      let bp = select<f32>(1.5, 1.0, k); // k ? 1.5 : 1.0\n      u = ax - bp;\n      v = 1.0 / (ax + bp);\n      s = u * v;\n      s_h = s;\n      is = reinterpret<u32>(s_h);\n      s_h = reinterpret<f32>(is & 0xFFFFF000);\n      is = ((ix >> 1) & 0xFFFFF000) | 0x20000000;\n      t_h = reinterpret<f32>(is + 0x00400000 + (k << 21));\n      t_l = ax - (t_h - bp);\n      s_l = v * ((u - s_h * t_h) - s_h * t_l);\n      s2 = s * s;\n      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n      r += s_l * (s_h + s);\n      s2 = s_h * s_h;\n      t_h = 3.0 + s2 + r;\n      is  = reinterpret<u32>(t_h);\n      t_h = reinterpret<f32>(is & 0xFFFFF000);\n      t_l = r - ((t_h - 3.0) - s2);\n      u = s_h * t_h;\n      v = s_l * t_h + t_l * s;\n      p_h = u + v;\n      is  = reinterpret<u32>(p_h);\n      p_h = reinterpret<f32>(is & 0xFFFFF000);\n      p_l = v - (p_h - u);\n      let z_h = cp_h * p_h;\n      let dp_l = select<f32>(dp_l1, 0.0, k);\n      let z_l = cp_l * p_h + p_l * cp + dp_l;\n      t = <f32>n;\n      let dp_h = select<f32>(dp_h1, 0.0, k);\n      t1 = (((z_h + z_l) + dp_h) + t);\n      is = reinterpret<u32>(t1);\n      t1 = reinterpret<f32>(is & 0xFFFFF000);\n      t2 = z_l - (((t1 - t) - dp_h) - z_h);\n    }\n    is = reinterpret<u32>(y);\n    var y1 = reinterpret<f32>(is & 0xFFFFF000);\n    p_l = (y - y1) * t1 + y * t2;\n    p_h = y1 * t1;\n    z = p_l + p_h;\n    j = reinterpret<u32>(z);\n    if (j > 0x43000000) {\n      return sn * huge * huge;\n    } else if (j == 0x43000000) {\n      if (p_l + ovt > z - p_h) return sn * huge * huge;\n    } else if ((j & 0x7FFFFFFF) > 0x43160000) {\n      return sn * tiny * tiny;\n    } else if (j == 0xC3160000) {\n      if (p_l <= z - p_h) return sn * tiny * tiny;\n    }\n    var i = j & 0x7FFFFFFF;\n    k = (i >> 23) - 0x7F;\n    n = 0;\n    if (i > 0x3F000000) {\n      n = j + (0x00800000 >> (k + 1));\n      k = ((n & 0x7FFFFFFF) >> 23) - 0x7F;\n      t = reinterpret<f32>(n & ~(0x007FFFFF >> k));\n      n = ((n & 0x007FFFFF) | 0x00800000) >> (23 - k);\n      if (j < 0) n = -n;\n      p_h -= t;\n    }\n    t = p_l + p_h;\n    is = reinterpret<u32>(t);\n    t = reinterpret<f32>(is & 0xFFFF8000);\n    u = t * lg2_h;\n    v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n    z = u + v;\n    w = v - (z - u);\n    t = z * z;\n    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n    r = (z * t1) / (t1 - 2.0) - (w + z * w);\n    z = 1.0 - (r - z);\n    j = reinterpret<u32>(z);\n    j += n << 23;\n    if ((j >> 23) <= 0) z = scalbn(z, n);\n    else z = reinterpret<f32>(j);\n    return sn * z;\n  }\n\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) throw new Error("PRNG must be seeded.");\n\n    var s0 = random_state0_32;\n    var s1 = random_state1_32;\n    var r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  @inline\n  export function round(x: f32): f32 {\n    return builtin_copysign<f32>(builtin_floor<f32>(x + 0.5), x);\n  }\n\n  @inline\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f32>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>((reinterpret<u32>(x) >>> 31) & (x == x));\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3f490fda) {  /* |x| ~<= π/4 */\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407b53d1) {   /* |x| ~<= 5π/4 */\n        if (ix <= 0x4016cbe3) { /* |x| ~<= 3π/4 */\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ix <= 0x40e231d5) {   /* |x| ~<= 9π/4 */\n        if (ix <= 0x40afeddf) { /* |x| ~<= 7π/4 */\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    /* sin(Inf or NaN) is NaN */\n    if (ix >= 0x7f800000) return x - x;\n\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var absx = reinterpret<f32>(u);\n    var t: f32;\n    var h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      t = expm1(absx);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    t = 2 * h * expo2f(absx);\n    return t;\n  }\n\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const t1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\n    const t2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\n    const t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\n    const t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3f490fda) {  /* |x| ~<= π/4 */\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407b53d1) {   /* |x| ~<= 5π/4 */\n        if (ix <= 0x4016cbe3) { /* |x| ~<= 3π/4 */\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ix <= 0x40e231d5) {   /* |x| ~<= 9π/4 */\n        if (ix <= 0x40afeddf) { /* |x| ~<= 7π/4 */\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    /* tan(Inf or NaN) is NaN */\n    if (ix >= 0x7f800000) return x - x;\n\n    /* argument reduction */\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    var t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n    var y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = ux & 0x80000000;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      if (ux1 == uy1) return 0 * x;\n      return x;\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= -ex + 1;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    var shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    ux |= sx;\n    return reinterpret<f32>(ux);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = <i32>(ux >> 31);\n    var uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= -ex + 1;\n    } else {\n      uxi &= <u32>-1 >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    var q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n  // end\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7fffffff;\n\n    if (ix <= 0x3f490fda) {  /* |x| ~<= π/4 */\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\n        sincos_s32 = x;\n        sincos_c32 = 1;\n        return;\n      }\n      sincos_s32 = sin_kernf(x);\n      sincos_c32 = cos_kernf(x);\n      return;\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407b53d1) {   /* |x| ~<= 5π/4 */\n        if (ix <= 0x4016cbe3) { /* |x| ~<= 3π/4 */\n          if (sign) {\n            sincos_s32 = -cos_kernf(x + s1pio2);\n            sincos_c32 =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_s32 = cos_kernf(s1pio2 - x);\n            sincos_c32 = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        /* -sin(x + c) is not correct if x+c could be 0: -0 vs +0 */\n        sincos_s32 = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_c32 = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n\n      if (ix <= 0x40e231d5) {   /* |x| ~<= 9π/4 */\n        if (ix <= 0x40afeddf) { /* |x| ~<= 7π/4 */\n          if (sign) {\n            sincos_s32 =  cos_kernf(x + s3pio2);\n            sincos_c32 = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_s32 = -cos_kernf(x - s3pio2);\n            sincos_c32 =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_s32 = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_c32 = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n\n    /* sin(Inf or NaN) is NaN */\n    if (ix >= 0x7f800000) {\n      let xx = x - x;\n      sincos_s32 = xx;\n      sincos_c32 = xx;\n      return;\n    }\n\n    /* general argument reduction needed */\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    var s = sin_kernf(y);\n    var c = cos_kernf(y);\n\n    switch (n & 3) {\n      case 0: {\n        sincos_s32 = s;\n        sincos_c32 = c;\n        break;\n      }\n      case 1: {\n        sincos_s32 =  c;\n        sincos_c32 = -s;\n        break;\n      }\n      case 2: {\n        sincos_s32 = -s;\n        sincos_c32 = -c;\n        break;\n      }\n      case 3:\n      default: {\n        sincos_s32 = -c;\n        sincos_c32 =  s;\n        break;\n      }\n    }\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  var out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (e < 0) return 0;\n\n    switch (e) {\n      case 0: return 1;\n      case 1: return x;\n      case 2: return x * x;\n    }\n\n    let log = 32 - clz(e);\n    if (log <= 5) {\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n\n  while (e > 0) {\n    if (e & 1) out *= x;\n    e >>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i32): i64 {\n  var out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (e < 0) return 0;\n    switch (e) {\n      case 0: return 1;\n      case 1: return x;\n      case 2: return x * x;\n    }\n\n    let log = 32 - clz(e);\n    if (log <= 6) {\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n\n  while (e > 0) {\n    if (e & 1) out *= x;\n    e >>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow32f(x: f32, e: i32): f32 {\n  var sign = e >> 31;\n  e = (e + sign) ^ sign; // abs(e)\n  var out: f32 = 1;\n  while (e) {\n    out *= select<f32>(x, 1.0, e & 1);\n    e >>= 1;\n    x *= x;\n  }\n  return sign ? <f32>1.0 / out : out;\n}\n\nexport function ipow64f(x: f64, e: i32): f64 {\n  var sign = e >> 31;\n  e = (e + sign) ^ sign; // abs(e)\n  var out = 1.0;\n  while (e) {\n    out *= select(x, 1.0, e & 1);\n    e >>= 1;\n    x *= x;\n  }\n  return sign ? 1.0 / out : out;\n}\n',memory:'import { memcmp, memmove, memset } from "./internal/memory";\n\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\n\n/* tslint:disable */\n\nexport namespace memory {\n\n  @builtin export declare function size(): i32;\n\n  @builtin export declare function grow(pages: i32): i32;\n\n  @builtin @inline\n  export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n    memset(dest, c, n); // fallback if "bulk-memory" isn\'t enabled\n  }\n\n  @builtin @inline\n  export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n    memmove(dest, src, n); // fallback if "bulk-memory" isn\'t enabled\n  }\n\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n    return memcmp(vl, vr, n);\n  }\n\n  // Passive segments\n\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\n  // }\n\n  // export function drop(segmentIndex: u32): void {\n  //   __memory_drop(segmentIndex);\n  // }\n\n  // Allocator\n\n  @inline export function allocate(size: usize): usize {\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\n    WARNING("Calling \'memory.allocate\' requires a memory manager to be present.");\n    return <usize>unreachable();\n  }\n\n  @inline export function free(ptr: usize): void {\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\n    WARNING("Calling \'memory.free\' requires a memory manager to be present.");\n    unreachable();\n  }\n\n  @inline export function reset(): void {\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\n    unreachable();\n  }\n}\n',number:'import {\n  itoa,\n  dtoa\n} from "./internal/number";\n\nimport {\n  isNaN as builtin_isNaN,\n  isFinite as builtin_isFinite\n} from "./builtins";\n\n@sealed\nexport abstract class I8 {\n\n  @lazy static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>parseI32(value, radix);\n  }\n\n  toString(this: i8): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class I16 {\n\n  @lazy static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>parseI32(value, radix);\n  }\n\n  toString(this: i16): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class I32 {\n\n  @lazy static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>parseI32(value, radix);\n  }\n\n  toString(this: i32): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class I64 {\n\n  @lazy static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return <i64>parseI64(value, radix);\n  }\n\n  toString(this: i64): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class Isize {\n\n  @lazy static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>parseI64(value, radix);\n  }\n\n  toString(this: isize): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class U8 {\n\n  @lazy static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>parseI32(value, radix);\n  }\n\n  toString(this: u8): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class U16 {\n\n  @lazy static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>parseI32(value, radix);\n  }\n\n  toString(this: u16): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class U32 {\n\n  @lazy static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>parseI32(value, radix);\n  }\n\n  toString(this: u32): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class U64 {\n\n  @lazy static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>parseI64(value, radix);\n  }\n\n  toString(this: u64): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class Usize {\n\n  @lazy static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>parseI64(value, radix);\n  }\n\n  toString(this: usize): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed\nexport abstract class Bool {\n\n  @lazy static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool): String {\n    // TODO: radix?\n    return this ? "true" : "false";\n  }\n}\n\nexport { Bool as Boolean };\n\n@sealed\nexport abstract class F32 {\n\n  @lazy static readonly EPSILON: f32 = f32.EPSILON;\n  @lazy static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n  @lazy static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n  @lazy static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n  @lazy static readonly POSITIVE_INFINITY: f32 = Infinity;\n  @lazy static readonly NEGATIVE_INFINITY: f32 = -Infinity;\n  @lazy static readonly NaN: f32 = NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>parseI64(value, radix);\n  }\n\n  static parseFloat(value: string): f32 {\n    return <f32>parseFloat(value);\n  }\n\n  toString(this: f32): String {\n    // TODO: radix\n    return dtoa(this);\n  }\n}\n\n@sealed\nexport abstract class F64 {\n\n  @lazy static readonly EPSILON: f64 = f64.EPSILON;\n  @lazy static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n  @lazy static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n  @lazy static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n  @lazy static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n  @lazy static readonly POSITIVE_INFINITY: f64 = Infinity;\n  @lazy static readonly NEGATIVE_INFINITY: f64 = -Infinity;\n  @lazy static readonly NaN: f64 = NaN;\n\n  static isNaN(value: f64): bool {\n    return builtin_isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return builtin_isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return builtin_isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return <f64>parseI64(value, radix);\n  }\n\n  static parseFloat(value: string): f64 {\n    return parseFloat(value);\n  }\n\n  toString(this: f64): String {\n    // TODO: radix\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n',polyfills:"export function bswap<T>(value: T): T {\n  if (isInteger<T>()) {\n    if (sizeof<T>() == 2) {\n      return <T>((value << 8) | ((value >> 8) & <T>0x00FF));\n    }\n    if (sizeof<T>() == 4) {\n      return <T>(\n        rotl<u32>(<u32>value & 0xFF00FF00, 8) |\n        rotr<u32>(<u32>value & 0x00FF00FF, 8)\n      );\n    }\n    if (sizeof<T>() == 8) {\n      let a = (<u64>value >> 8) & 0x00FF00FF00FF00FF;\n      let b = (<u64>value & 0x00FF00FF00FF00FF) << 8;\n      let v = a | b;\n\n      a = (v >> 16) & 0x0000FFFF0000FFFF;\n      b = (v & 0x0000FFFF0000FFFF) << 16;\n\n      return <T>rotr<u64>(a | b, 32);\n    }\n    return value;\n  }\n  assert(false);\n  return value;\n}\n\n@inline\nexport function bswap16<T>(value: T): T {\n  if (isInteger<T>() && sizeof<T>() <= 4) {\n    if (sizeof<T>() == 2) {\n      return <T>((value << 8) | ((value >> 8) & <T>0x00FF));\n    } else if (sizeof<T>() == 4) {\n      return <T>(((value << 8) & <T>0xFF00) | ((value >> 8) & <T>0x00FF) | (value & <T>0xFFFF0000));\n    }\n    return value;\n  }\n  assert(false);\n  return value;\n}\n",regexp:'export class RegExp {\n\n  // @binding(CALL_NEW, [ STRING, STRING], OBJECT_HANDLE)\n  constructor(pattern: string, flags: string = "") { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [ STRING ], PASS_THRU)\n  test(search: string): bool { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [], STRING)\n  toString(): string { throw new Error("unreachable"); }\n\n}\n',set:'import {\n  HEADER_SIZE as HEADER_SIZE_AB\n} from "./internal/arraybuffer";\n\nimport {\n  HASH\n} from "./internal/hash";\n\n// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht\n\n@inline const INITIAL_CAPACITY = 4;\n@inline const FILL_FACTOR: f64 = 8 / 3;\n@inline const FREE_FACTOR: f64 = 3 / 4;\n\n/** Structure of a set entry. */\n@unmanaged class SetEntry<K> {\n  key: K;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n@inline function ENTRY_ALIGN<K>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits\n  const align = (sizeof<K>() > sizeof<usize>() ? sizeof<K>() : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n@inline function ENTRY_SIZE<K>(): usize {\n  const align = ENTRY_ALIGN<K>();\n  const size = (offsetof<SetEntry<K>>() + align) & ~align;\n  return size;\n}\n\nexport class Set<K> {\n\n  // buckets holding references to the respective first entry within\n  private buckets: ArrayBuffer; // usize[bucketsMask + 1]\n  private bucketsMask: u32;\n\n  // entries in insertion order\n  private entries: ArrayBuffer; // SetEntry<K>[entriesCapacity]\n  private entriesCapacity: i32;\n  private entriesOffset: i32;\n  private entriesCount: i32;\n\n  get size(): i32 { return this.entriesCount; }\n\n  constructor() { this.clear(); }\n\n  clear(): void {\n    const bucketsSize = INITIAL_CAPACITY * <i32>BUCKET_SIZE;\n    this.buckets = new ArrayBuffer(bucketsSize);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    const entriesSize = INITIAL_CAPACITY * <i32>ENTRY_SIZE<K>();\n    this.entries = new ArrayBuffer(entriesSize, true);\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): SetEntry<K> | null {\n    var entry = load<SetEntry<K>>(\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE,\n      HEADER_SIZE_AB\n    );\n    while (entry) {\n      if (!(entry.taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<SetEntry<K>>(entry.taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH(key)) !== null;\n  }\n\n  add(key: K): void {\n    var hashCode = HASH(key);\n    var entry = this.find(key, hashCode);\n    if (!entry) {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<SetEntry<K>>(\n        changetype<usize>(entries) + HEADER_SIZE_AB + this.entriesOffset++ * ENTRY_SIZE<K>()\n      );\n      entry.key = key;\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase, HEADER_SIZE_AB);\n      store<usize>(bucketPtrBase, changetype<usize>(entry), HEADER_SIZE_AB);\n      if (isManaged<K>()) __gc_link(changetype<usize>(this), changetype<usize>(key)); // tslint:disable-line\n    }\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = <i32>(newBucketsCapacity * FILL_FACTOR);\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K>(), true);\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries) + HEADER_SIZE_AB;\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K>();\n    var newPtr = changetype<usize>(newEntries) + HEADER_SIZE_AB;\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<SetEntry<K>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<SetEntry<K>>(newPtr);\n        newEntry.key = oldEntry.key;\n        let newBucketIndex = HASH<K>(oldEntry.key) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase, HEADER_SIZE_AB);\n        store<usize>(newBucketPtrBase, newPtr, HEADER_SIZE_AB);\n        newPtr += ENTRY_SIZE<K>();\n      }\n      oldPtr += ENTRY_SIZE<K>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  toString(): string {\n    return "[object Set]";\n  }\n\n  private __gc(): void {\n    __gc_mark(changetype<usize>(this.buckets)); // tslint:disable-line\n    var entries = this.entries;\n    __gc_mark(changetype<usize>(entries)); // tslint:disable-line\n    if (isManaged<K>()) {\n      let offset: usize = 0;\n      let end: usize = this.entriesOffset * ENTRY_SIZE<K>();\n      while (offset < end) {\n        let entry = changetype<SetEntry<K>>(\n          changetype<usize>(entries) + HEADER_SIZE_AB + offset * ENTRY_SIZE<K>()\n        );\n        if (!(entry.taggedNext & EMPTY)) __gc_mark(changetype<usize>(entry.key)); // tslint:disable-line\n        offset += ENTRY_SIZE<K>();\n      }\n    }\n  }\n}\n',string:'import {\n  HEADER_SIZE,\n  MAX_LENGTH,\n  allocateUnsafe,\n  compareUnsafe,\n  repeatUnsafe,\n  copyUnsafe,\n  isWhiteSpaceOrLineTerminator,\n  CharCode,\n  parse\n} from "./internal/string";\n\nimport {\n  STORE\n} from "./internal/arraybuffer";\n\n@sealed\nexport class String {\n\n  readonly length: i32; // capped to [0, MAX_LENGTH]\n\n  // TODO Add and handle second argument\n  static fromCharCode(code: i32): String {\n    var out = allocateUnsafe(1);\n    store<u16>(\n      changetype<usize>(out),\n      <u16>code,\n      HEADER_SIZE\n    );\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    assert(<u32>code <= 0x10FFFF);\n    var sur = code > 0xFFFF;\n    var out = allocateUnsafe(<i32>sur + 1);\n    if (!sur) {\n      store<u16>(\n        changetype<usize>(out),\n        <u16>code,\n        HEADER_SIZE\n      );\n    } else {\n      code -= 0x10000;\n      let hi: u32 = (code >>> 10) + 0xD800;\n      let lo: u32 = (code & 0x3FF) + 0xDC00;\n      store<u32>(\n        changetype<usize>(out),\n        (hi << 16) | lo,\n        HEADER_SIZE\n      );\n    }\n    return out;\n  }\n\n  @operator("[]")\n  charAt(pos: i32): String {\n    assert(this !== null);\n\n    if (<u32>pos >= <u32>this.length) return changetype<String>("");\n\n    var out = allocateUnsafe(1);\n    store<u16>(\n      changetype<usize>(out),\n      load<u16>(\n        changetype<usize>(this) + (<usize>pos << 1),\n        HEADER_SIZE\n      ),\n      HEADER_SIZE\n    );\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    assert(this !== null);\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n\n    return load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n  }\n\n  codePointAt(pos: i32): i32 {\n    assert(this !== null);\n    if (<u32>pos >= <u32>this.length) return -1; // (undefined)\n\n    var first = <i32>load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) {\n      return first;\n    }\n    var second = <i32>load<u16>(\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\n      HEADER_SIZE\n    );\n    if (second < 0xDC00 || second > 0xDFFF) return first;\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator("+")\n  private static __concat(left: String, right: String): String {\n    if (!changetype<usize>(left)) left = changetype<String>("null");\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    assert(this !== null);\n    if (other === null) other = changetype<String>("null");\n\n    var thisLen: isize  = this.length;\n    var otherLen: isize = other.length;\n    var outLen: usize   = thisLen + otherLen;\n    if (outLen == 0) return changetype<String>("");\n    var out = allocateUnsafe(outLen);\n    copyUnsafe(out, 0, this, 0, thisLen);\n    copyUnsafe(out, thisLen, other, 0, otherLen);\n    return out;\n  }\n\n  endsWith(searchString: String, endPosition: i32 = MAX_LENGTH): bool {\n    assert(this !== null);\n    if (searchString === null) return false;\n    var end = min(max(endPosition, 0), this.length);\n    var searchLength: isize = searchString.length;\n    var start: isize = end - searchLength;\n    if (start < 0) return false;\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\n  }\n\n  @operator("==")\n  private static __eq(left: String, right: String): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n\n    return !compareUnsafe(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix("!")\n  private static __not(str: String): bool {\n    return str === null || !str.length;\n  }\n\n  @operator("!=")\n  private static __ne(left: String, right: String): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(">")\n  private static __gt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!leftLength)  return false;\n    if (!rightLength) return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return compareUnsafe(left, 0, right, 0, length) > 0;\n  }\n\n  @operator(">=")\n  private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator("<")\n  private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!rightLength) return false;\n    if (!leftLength)  return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return compareUnsafe(left, 0, right, 0, length) < 0;\n  }\n\n  @operator("<=")\n  private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  @inline\n  includes(searchString: String, position: i32 = 0): bool {\n    return this.indexOf(searchString, position) != -1;\n  }\n\n  indexOf(searchString: String, fromIndex: i32 = 0): i32 {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>("null");\n\n    var searchLen: isize = searchString.length;\n    if (!searchLen) return 0;\n    var len: isize = this.length;\n    if (!len) return -1;\n    var start = min<isize>(max<isize>(fromIndex, 0), len);\n    len -= searchLen;\n    for (let k: isize = start; k <= len; ++k) {\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchString: String, fromIndex: i32 = i32.MAX_VALUE): i32 {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>("null");\n\n    var len: isize = this.length;\n    var searchLen: isize = searchString.length;\n    if (!searchLen) return len;\n    if (!len) return -1;\n    var start = min<isize>(max(fromIndex, 0), len - searchLen);\n    for (let k = start; k >= 0; --k) {\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\n    }\n    return -1;\n  }\n\n  startsWith(searchString: String, position: i32 = 0): bool {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>("null");\n\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start = min(max(pos, 0), len);\n    var searchLength: isize = searchString.length;\n    if (searchLength + start > len) return false;\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\n    assert(this !== null);\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0) intStart = max(size + intStart, 0);\n    var resultLength = min(max(end, 0), size - intStart);\n    if (resultLength <= 0) return changetype<String>("");\n    var out = allocateUnsafe(resultLength);\n    copyUnsafe(out, 0, this, intStart, resultLength);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    assert(this !== null);\n    var len = this.length;\n    var finalStart = min(max(start, 0), len);\n    var finalEnd = min(max(end, 0), len);\n    var from = min<i32>(finalStart, finalEnd);\n    var to = max<i32>(finalStart, finalEnd);\n    len = to - from;\n    if (!len) return changetype<String>("");\n    if (!from && to == this.length) return this;\n    var out = allocateUnsafe(len);\n    copyUnsafe(out, 0, this, from, len);\n    return out;\n  }\n\n  trim(): String {\n    assert(this !== null);\n    var length: usize = this.length;\n\n    while (\n      length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (length << 1), HEADER_SIZE)\n      )\n    ) {\n      --length;\n    }\n    var start: usize = 0;\n    while (\n      start < length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start, --length;\n    }\n    if (!length) return changetype<String>("");\n    if (!start && length == this.length) return this;\n    var out = allocateUnsafe(length);\n    copyUnsafe(out, 0, this, start, length);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    assert(this !== null);\n    var start: isize = 0;\n    var len: isize = this.length;\n    while (\n      start < len &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start;\n    }\n    if (!start) return this;\n    var outLen = len - start;\n    if (!outLen) return changetype<String>("");\n    var out = allocateUnsafe(outLen);\n    copyUnsafe(out, 0, this, start, outLen);\n    return out;\n  }\n\n  trimEnd(): String {\n    assert(this !== null);\n    var len: isize = this.length;\n    while (\n      len > 0 &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (len << 1), HEADER_SIZE)\n      )\n    ) {\n      --len;\n    }\n    if (len <= 0) return changetype<String>("");\n    if (<i32>len == this.length) return this;\n    var out = allocateUnsafe(len);\n    copyUnsafe(out, 0, this, 0, len);\n    return out;\n  }\n\n  padStart(targetLength: i32, padString: String = changetype<String>(" ")): String {\n    assert(this !== null);\n    var length = this.length;\n    var padLen = padString.length;\n    if (targetLength < length || !padLen) return this;\n    var len = targetLength - length;\n    var out = allocateUnsafe(targetLength);\n    if (len > padLen) {\n      let count = (len - 1) / padLen;\n      let base = count * padLen;\n      let rest = len - base;\n      repeatUnsafe(out, 0, padString, count);\n      if (rest) copyUnsafe(out, base, padString, 0, rest);\n    } else {\n      copyUnsafe(out, 0, padString, 0, len);\n    }\n    if (length) copyUnsafe(out, len, this, 0, length);\n    return out;\n  }\n\n  padEnd(targetLength: i32, padString: String = changetype<String>(" ")): String {\n    assert(this !== null);\n    var length = this.length;\n    var padLen = padString.length;\n    if (targetLength < length || !padLen) return this;\n    var len = targetLength - length;\n    var out = allocateUnsafe(targetLength);\n    if (length) copyUnsafe(out, 0, this, 0, length);\n    if (len > padLen) {\n      let count = (len - 1) / padLen;\n      let base = count * padLen;\n      let rest = len - base;\n      repeatUnsafe(out, length, padString, count);\n      if (rest) copyUnsafe(out, base + length, padString, 0, rest);\n    } else {\n      copyUnsafe(out, length, padString, 0, len);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    assert(this !== null);\n    var length = this.length;\n\n    // Most browsers can\'t handle strings 1 << 28 chars or longer\n    if (count < 0 || length * count > (1 << 28)) {\n      throw new RangeError("Invalid count value");\n    }\n\n    if (count == 0 || !length) return changetype<String>("");\n    if (count == 1) return this;\n\n    var result = allocateUnsafe(length * count);\n    repeatUnsafe(result, 0, this, count);\n    return result;\n  }\n\n  slice(beginIndex: i32, endIndex: i32 = i32.MAX_VALUE): String {\n    var len   = this.length;\n    var begin = beginIndex < 0 ? max(beginIndex + len, 0) : min(beginIndex, len);\n    var end   = endIndex   < 0 ? max(endIndex   + len, 0) : min(endIndex,   len);\n    len = end - begin;\n    if (len <= 0) return changetype<String>("");\n    var out = allocateUnsafe(len);\n    copyUnsafe(out, 0, this, begin, len);\n    return out;\n  }\n\n  split(separator: String = null, limit: i32 = i32.MAX_VALUE): String[] {\n    assert(this !== null);\n    if (!limit) return new Array<String>();\n    if (separator === null) return <String[]>[this];\n    var length: isize = this.length;\n    var sepLen: isize = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return new Array<String>();\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = new Array<String>(length);\n      let buffer = <ArrayBuffer>result.buffer_;\n      for (let i: isize = 0; i < length; ++i) {\n        let char = allocateUnsafe(1);\n        store<u16>(\n          changetype<usize>(char),\n          load<u16>(\n            changetype<usize>(this) + (<usize>i << 1),\n            HEADER_SIZE\n          ),\n          HEADER_SIZE\n        );\n        STORE<String>(buffer, i, char);\n      }\n      return result;\n    } else if (!length) {\n      let result = new Array<String>(1);\n      unchecked(result[0] = changetype<String>(""));\n      return result;\n    }\n    var result = new Array<String>();\n    var end = 0, start = 0, i = 0;\n    while ((end = this.indexOf(separator, start)) != -1) {\n      let len = end - start;\n      if (len > 0) {\n        let out = allocateUnsafe(len);\n        copyUnsafe(out, 0, this, start, len);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(""));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) {\n      let result = new Array<String>(1);\n      unchecked(result[0] = this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = allocateUnsafe(len);\n      copyUnsafe(out, 0, this, start, len);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(""));\n    }\n    return result;\n  }\n\n  toString(): String {\n    return this;\n  }\n\n  get lengthUTF8(): i32 {\n    var len = 1; // null terminated\n    var pos: usize = 0;\n    var end = <usize>this.length;\n    while (pos < end) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\n      if (c < 128) {\n        len += 1; ++pos;\n      } else if (c < 2048) {\n        len += 2; ++pos;\n      } else {\n        if (\n          (c & 0xFC00) == 0xD800 && pos + 1 < end &&\n          (<u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE) & 0xFC00) == 0xDC00\n        ) {\n          len += 4; pos += 2;\n        } else {\n          len += 3; ++pos;\n        }\n      }\n    }\n    return len;\n  }\n\n  static fromUTF8(ptr: usize, len: usize): String {\n    if (len < 1) return changetype<String>("");\n    var ptrPos = <usize>0;\n    var buf = memory.allocate(<usize>len << 1);\n    var bufPos = <usize>0;\n    while (ptrPos < len) {\n      let cp = <u32>load<u8>(ptr + ptrPos++);\n      if (cp < 128) {\n        store<u16>(buf + bufPos, cp);\n        bufPos += 2;\n      } else if (cp > 191 && cp < 224) {\n        assert(ptrPos + 1 <= len);\n        store<u16>(buf + bufPos, (cp & 31) << 6 | load<u8>(ptr + ptrPos++) & 63);\n        bufPos += 2;\n      } else if (cp > 239 && cp < 365) {\n        assert(ptrPos + 3 <= len);\n        cp = (\n          (cp                       &  7) << 18 |\n          (load<u8>(ptr + ptrPos++) & 63) << 12 |\n          (load<u8>(ptr + ptrPos++) & 63) <<  6 |\n           load<u8>(ptr + ptrPos++) & 63\n        ) - 0x10000;\n        store<u16>(buf + bufPos, 0xD800 + (cp >> 10));\n        bufPos += 2;\n        store<u16>(buf + bufPos, 0xDC00 + (cp & 1023));\n        bufPos += 2;\n      } else {\n        assert(ptrPos + 2 <= len);\n        store<u16>(buf + bufPos,\n          (cp                       & 15) << 12 |\n          (load<u8>(ptr + ptrPos++) & 63) <<  6 |\n           load<u8>(ptr + ptrPos++) & 63\n        );\n        bufPos += 2;\n      }\n    }\n    assert(ptrPos == len);\n    var str = allocateUnsafe(<u32>(bufPos >> 1));\n    memory.copy(changetype<usize>(str) + HEADER_SIZE, buf, bufPos);\n    memory.free(buf);\n    return str;\n  }\n\n  toUTF8(): usize {\n    var buf = memory.allocate(<usize>this.lengthUTF8);\n    var pos: usize = 0;\n    var end = <usize>this.length;\n    var off: usize = 0;\n    while (pos < end) {\n      let c1 = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\n      if (c1 < 128) {\n        store<u8>(buf + off, c1);\n        ++off; ++pos;\n      } else if (c1 < 2048) {\n        let ptr = buf + off;\n        store<u8>(ptr, c1 >> 6 | 192);\n        store<u8>(ptr, c1 & 63 | 128, 1);\n        off += 2; ++pos;\n      } else {\n        let ptr = buf + off;\n        if ((c1 & 0xFC00) == 0xD800 && pos + 1 < end) {\n          let c2 = <u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE);\n          if ((c2 & 0xFC00) == 0xDC00) {\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n            store<u8>(ptr, c1 >> 18      | 240);\n            store<u8>(ptr, c1 >> 12 & 63 | 128, 1);\n            store<u8>(ptr, c1 >>  6 & 63 | 128, 2);\n            store<u8>(ptr, c1       & 63 | 128, 3);\n            off += 4; pos += 2;\n            continue;\n          }\n        }\n        store<u8>(ptr, c1 >> 12     | 224);\n        store<u8>(ptr, c1 >> 6 & 63 | 128, 1);\n        store<u8>(ptr, c1      & 63 | 128, 2);\n        off += 3; ++pos;\n      }\n    }\n    store<u8>(buf + off, 0);\n    return buf;\n  }\n}\n\nexport type string = String;\n\nexport function parseInt(str: String, radix: i32 = 0): f64 {\n  return parse<f64>(str, radix);\n}\n\nexport function parseI32(str: String, radix: i32 = 0): i32 {\n  return parse<i32>(str, radix);\n}\n\nexport function parseI64(str: String, radix: i32 = 0): i64 {\n  return parse<i64>(str, radix);\n}\n\n// FIXME: naive implementation\nexport function parseFloat(str: String): f64 {\n  var len: i32 = str.length;\n  if (!len) return NaN;\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: f64;\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // calculate value\n  var num: f64 = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      let fac: f64 = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr, HEADER_SIZE);\n        if (code == CharCode.E || code == CharCode.e) {\n          assert(false); // TODO\n        }\n        code -= CharCode._0;\n        if (<u32>code > 9) break;\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10) break;\n    num = (num * 10) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n',symbol:'import { Map } from "./map";\n\n@lazy var stringToId: Map<string, usize>;\n@lazy var idToString: Map<usize, string>;\n@lazy var nextId: usize = 12; // Symbol.unscopables + 1\n\n@unmanaged export class symbol {\n  toString(): string {\n    var id = changetype<usize>(this);\n    var str = "";\n    switch (id) {\n      case 1:  { str = "hasInstance"; break; }\n      case 2:  { str = "isConcatSpreadable"; break; }\n      case 3:  { str = "isRegExp"; break; }\n      case 4:  { str = "match"; break; }\n      case 5:  { str = "replace"; break; }\n      case 6:  { str = "search"; break; }\n      case 7:  { str = "species"; break; }\n      case 8:  { str = "split"; break; }\n      case 9:  { str = "toPrimitive"; break; }\n      case 10: { str = "toStringTag"; break; }\n      case 11: { str = "unscopables"; break; }\n      default: {\n        if (idToString !== null && idToString.has(id)) str = idToString.get(id);\n        break;\n      }\n    }\n    return "Symbol(" + str + ")";\n  }\n}\n\nexport function Symbol(description: string | null = null): symbol {\n  var id = nextId++;\n  if (!id) unreachable(); // out of ids\n  return changetype<symbol>(id);\n}\n\nexport namespace Symbol {\n\n  // well-known symbols\n  @lazy export const hasInstance        = changetype<symbol>(1);\n  @lazy export const isConcatSpreadable = changetype<symbol>(2);\n  @lazy export const isRegExp           = changetype<symbol>(3);\n  @lazy export const iterator           = changetype<symbol>(3);\n  @lazy export const match              = changetype<symbol>(4);\n  @lazy export const replace            = changetype<symbol>(5);\n  @lazy export const search             = changetype<symbol>(6);\n  @lazy export const species            = changetype<symbol>(7);\n  @lazy export const split              = changetype<symbol>(8);\n  @lazy export const toPrimitive        = changetype<symbol>(9);\n  @lazy export const toStringTag        = changetype<symbol>(10);\n  @lazy export const unscopables        = changetype<symbol>(11);\n\n  /* tslint:disable */// not valid TS\n  export function for(key: string): symbol {\n    if (!stringToId) { stringToId = new Map(); idToString = new Map(); }\n    else if (stringToId.has(key)) return changetype<symbol>(stringToId.get(key));\n    var id = nextId++;\n    if (!id) unreachable(); // out of ids\n    stringToId.set(key, id);\n    idToString.set(id, key);\n    return changetype<symbol>(id);\n  }\n  /* tslint:enable */\n\n  export function keyFor(sym: symbol): string | null {\n    return idToString !== null && idToString.has(changetype<usize>(sym))\n      ? idToString.get(changetype<usize>(sym))\n      : null;\n  }\n}\n',table:"export namespace table {\n\n  // export function copy(dst: u32, src: u32, n: u32): void {\n  //   __table_copy(dst, src, n);\n  // }\n\n  // Passive elements\n\n  // export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void {\n  //   __table_init(elementIndex, srcOffset, dstOffset, n);\n  // }\n\n  // export function drop(elementIndex: u32): void {\n  //   __table_drop(elementIndex);\n  // }\n}\n",typedarray:"import {\n  TypedArray,\n  FILL,\n  SORT,\n  SUBARRAY,\n  REDUCE,\n  REDUCE_RIGHT,\n  MAP,\n  FIND_INDEX,\n  SOME,\n  EVERY,\n  FOREACH,\n  REVERSE,\n} from \"./internal/typedarray\";\n\nimport {\n  COMPARATOR\n} from \"./internal/sort\";\n\nfunction clampToByte(value: i32): i32 {\n  return ~(value >> 31) & (((255 - value) >> 31) | value); // & 255\n}\n\nexport class Int8Array extends TypedArray<i8> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<i8>();\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return FILL<Int8Array, i8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    return SORT<Int8Array, i8>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i8>(this);\n  }\n}\n\nexport class Uint8Array extends TypedArray<u8> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return FILL<Uint8Array, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    return SORT<Uint8Array, u8>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n}\n\nexport class Uint8ClampedArray extends Uint8Array {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  @inline @operator(\"[]=\")\n  protected __set(index: i32, value: i32): void {\n    super.__set(index, clampToByte(value));\n  }\n\n  @inline @operator(\"{}=\")\n  protected __unchecked_set(index: i32, value: i32): void {\n    super.__unchecked_set(index, clampToByte(value));\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return changetype<Uint8ClampedArray>(super.fill(value, start, end)); // safe because '.fill' reuses 'this'\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    return changetype<Uint8ClampedArray>(super.sort(comparator)); // safe because '.sort' reuses 'this'\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n}\n\nexport class Int16Array extends TypedArray<i16> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<i16>();\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return FILL<Int16Array, i16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    return SORT<Int16Array, i16>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i16>(this);\n  }\n}\n\nexport class Uint16Array extends TypedArray<u16> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u16>();\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return FILL<Uint16Array, u16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    return SORT<Uint16Array, u16>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u16>(this);\n  }\n}\n\nexport class Int32Array extends TypedArray<i32> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<i32>();\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return FILL<Int32Array, i32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    return SORT<Int32Array, i32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i32>(this);\n  }\n}\n\nexport class Uint32Array extends TypedArray<u32> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u32>();\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return FILL<Uint32Array, u32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    return SORT<Uint32Array, u32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u32>(this);\n  }\n}\n\nexport class Int64Array extends TypedArray<i64> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<i64>();\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return FILL<Int64Array, i64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    return SORT<Int64Array, i64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i64>(this);\n  }\n}\n\nexport class Uint64Array extends TypedArray<u64> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u64>();\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return FILL<Uint64Array, u64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    return SORT<Uint64Array, u64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u64>(this);\n  }\n}\n\nexport class Float32Array extends TypedArray<f32> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<f32>();\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return FILL<Float32Array, f32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    return SORT<Float32Array, f32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f32>(this);\n  }\n}\n\nexport class Float64Array extends TypedArray<f64> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<f64>();\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return FILL<Float64Array, f64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    return SORT<Float64Array, f64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f64>(this);\n  }\n}\n",vector:"@sealed\nexport abstract class V128 {\n}\n"}):(()=>{const e=path.join(".","..","std","assembly"),n=__webpack_require__(!function(){var e=new Error("Cannot find module 'glob'");throw e.code="MODULE_NOT_FOUND",e}()).sync("**/!(*.d).ts",{cwd:e}),t={};return n.forEach(n=>t[n.replace(/\.ts$/,"")]=fs.readFileSync(path.join(e,n),"utf8")),t})(),exports.definitionFiles=exports.isBundle?Object({assembly:'/**\n * Environment definitions for compiling AssemblyScript to WebAssembly using asc.\n * @module std/assembly\n *//***/\n\n/// <reference no-default-lib="true"/>\n\n// Types\n\n/** An 8-bit signed integer. */\ndeclare type i8 = number;\n/** A 16-bit signed integer. */\ndeclare type i16 = number;\n/** A 32-bit signed integer. */\ndeclare type i32 = number;\n/** A 64-bit signed integer. */\ndeclare type i64 = number;\n/** A 32-bit signed integer when targeting 32-bit WebAssembly or a 64-bit signed integer when targeting 64-bit WebAssembly. */\ndeclare type isize = number;\n/** An 8-bit unsigned integer. */\ndeclare type u8 = number;\n/** A 16-bit unsigned integer. */\ndeclare type u16 = number;\n/** A 32-bit unsigned integer. */\ndeclare type u32 = number;\n/** A 64-bit unsigned integer. */\ndeclare type u64 = number;\n/** A 32-bit unsigned integer when targeting 32-bit WebAssembly or a 64-bit unsigned integer when targeting 64-bit WebAssembly. */\ndeclare type usize = number;\n/** A 1-bit unsigned integer. */\ndeclare type bool = boolean | number;\n/** A 32-bit float. */\ndeclare type f32 = number;\n/** A 64-bit float. */\ndeclare type f64 = number;\n/** A 128-bit vector. */\ndeclare type v128 = object;\n\n// Compiler hints\n\n/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */\ndeclare const ASC_TARGET: i32;\n/** Provided noAssert option. */\ndeclare const ASC_NO_ASSERT: bool;\n/** Provided memoryBase option. */\ndeclare const ASC_MEMORY_BASE: i32;\n/** Provided optimizeLevel option. */\ndeclare const ASC_OPTIMIZE_LEVEL: i32;\n/** Provided shrinkLevel option. */\ndeclare const ASC_SHRINK_LEVEL: i32;\n/** Whether the mutable global feature is enabled. */\ndeclare const ASC_FEATURE_MUTABLE_GLOBAL: bool;\n/** Whether the sign extension feature is enabled. */\ndeclare const ASC_FEATURE_SIGN_EXTENSION: bool;\n/** Whether the bulk memory feature is enabled. */\ndeclare const ASC_FEATURE_BULK_MEMORY: bool;\n/** Whether the SIMD feature is enabled. */\ndeclare const ASC_FEATURE_SIMD: bool;\n/** Whether the threads feature is enabled. */\ndeclare const ASC_FEATURE_THREADS: bool;\n\n// Builtins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered trailing if the value is zero. */\ndeclare function ctz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit or 64-bit integer. */\ndeclare function popcnt<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic rotate left operation on a 32-bit or 64-bit integer. */\ndeclare function rotl<T = i32 | i64>(value: T, shift: T): T;\n/** Performs the sign-agnostic rotate right operation on a 32-bit or 64-bit integer. */\ndeclare function rotr<T = i32 | i64>(value: T, shift: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | i64 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\ndeclare function copysign<T = f32 | f64>(x: T, y: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\ndeclare function nearest<T = f32 | f64>(value: T): T;\n/** Reinterprets the bits of the specified value as type `T`. Valid reinterpretations are u32/i32 to/from f32 and u64/i64 to/from f64. */\ndeclare function reinterpret<T = i32 | i64 | f32 | f64>(value: number): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Loads a value of the specified type from memory. Equivalent to dereferncing a pointer in other languages. */\ndeclare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n/** Stores a value of the specified type to memory. Equivalent to dereferencing a pointer in other languages when assigning a value. */\ndeclare function store<T>(ptr: usize, value: any, immOffset?: usize, immAlign?: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. Both a statement and an expression of any type. */\ndeclare function unreachable(): any; // sic\n\n/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */\ndeclare const NaN: f32 | f64;\n/** Positive infinity as a 32-bit or 64-bit float depending on context. */\ndeclare const Infinity: f32 | f64;\n/** Heap base offset. */\ndeclare const HEAP_BASE: usize;\n/** Determines the byte size of the specified underlying core type. Compiles to a constant. */\ndeclare function sizeof<T>(): usize;\n/** Determines the alignment (log2) of the specified underlying core type. Compiles to a constant. */\ndeclare function alignof<T>(): usize;\n/** Determines the offset of the specified field within the given class type. Returns the class type\'s end offset if field name has been omitted. Compiles to a constant. */\ndeclare function offsetof<T>(fieldName?: string): usize;\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */\ndeclare function unchecked<T>(value: T): T;\n/** Emits a `call_indirect` instruction, calling the specified function in the function table by index with the specified arguments. Does result in a runtime error if the arguments do not match the called function. */\ndeclare function call_indirect<T>(target: Function | u32, ...args: any[]): T;\n/** Instantiates a new instance of `T` using the specified constructor arguments. */\ndeclare function instantiate<T>(...args: any[]): T;\n/** Tests if a 32-bit or 64-bit float is `NaN`. */\ndeclare function isNaN<T = f32 | f64>(value: T): bool;\n/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */\ndeclare function isFinite<T = f32 | f64>(value: T): bool;\n/** Tests if the specified type *or* expression is of an integer type and not a reference. Compiles to a constant. */\ndeclare function isInteger<T>(value?: any): value is number;\n/** Tests if the specified type *or* expression is of a float type. Compiles to a constant. */\ndeclare function isFloat<T>(value?: any): value is number;\n/** Tests if the specified type *or* expression can represent negative numbers. Compiles to a constant. */\ndeclare function isSigned<T>(value?: any): value is number;\n/** Tests if the specified type *or* expression is of a reference type. Compiles to a constant. */\ndeclare function isReference<T>(value?: any): value is object | string;\n/** Tests if the specified type *or* expression can be used as a string. Compiles to a constant. */\ndeclare function isString<T>(value?: any): value is string | String;\n/** Tests if the specified type *or* expression can be used as an array. Compiles to a constant. */\ndeclare function isArray<T>(value?: any): value is Array<any>;\n/** Tests if the specified type *or* expression can be used as an array like object. Compiles to a constant. */\ndeclare function isArrayLike<T>(value?: any): value is ArrayLike<any>;\n/** Tests if the specified type *or* expression is of a function type. Compiles to a constant. */\ndeclare function isFunction<T>(value?: any): value is (...args: any) => any;\n/** Tests if the specified type *or* expression is of a nullable reference type. Compiles to a constant. */\ndeclare function isNullable<T>(value?: any): bool;\n/** Tests if the specified expression resolves to a defined element. Compiles to a constant. */\ndeclare function isDefined(expression: any): bool;\n/** Tests if the specified expression evaluates to a constant value. Compiles to a constant. */\ndeclare function isConstant(expression: any): bool;\n/** Tests if the specified type *or* expression is of a managed type. Compiles to a constant. */\ndeclare function isManaged<T>(value?: any): bool;\n/** Traps if the specified value is not true-ish, otherwise returns the (non-nullable) value. */\ndeclare function assert<T>(isTrueish: T, message?: string): T & object; // any better way to model `: T != null`?\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses an integer string to a 32-bit integer. */\ndeclare function parseI32(str: string, radix?: i32): i32;\n/** Parses an integer string to a 64-bit integer. */\ndeclare function parseI64(str: string, radix?: i32): i64;\n/** Parses a string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n/** Returns the 64-bit floating-point remainder of `x/y`. */\ndeclare function fmod(x: f64, y: f64): f64;\n/** Returns the 32-bit floating-point remainder of `x/y`. */\ndeclare function fmodf(x: f32, y: f32): f32;\n\n/** Atomic operations. */\ndeclare namespace atomic {\n  /** Atomically loads an integer value from memory and returns it. */\n  export function load<T>(offset: usize, immOffset?: usize): T;\n  /** Atomically stores an integer value to memory. */\n  export function store<T>(offset: usize, value: T, immOffset?: usize): void;\n  /** Atomically adds an integer value in memory. */\n  export function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n  /** Atomically subtracts an integer value in memory. */\n  export function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n  /** Atomically performs a bitwise AND operation on an integer value in memory. */\n  export function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n  /** Atomically performs a bitwise OR operation on an integer value in memory. */\n  export function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n  /** Atomically performs a bitwise XOR operation on an integer value in memory. */\n  export function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n  /** Atomically exchanges an integer value in memory. */\n  export function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n  /** Atomically compares and exchanges an integer value in memory if the condition is met. */\n  export function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n  /** Performs a wait operation on an address in memory suspending this agent if the integer condition is met. */\n  export function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n  /** Performs a notify operation on an address in memory waking up suspended agents. */\n  export function notify(ptr: usize, count: i32): i32;\n}\n\n/** Describes the result of an atomic wait operation. */\ndeclare enum AtomicWaitResult {\n  /** Woken by another agent. */\n  OK,\n  /** Loaded value did not match the expected value. */\n  NOT_EQUAL,\n  /** Not woken before the timeout expired. */\n  TIMED_OUT\n}\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace i8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i8;\n  /** Largest representable value. */\n  export const MAX_VALUE: i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace i16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i16;\n  /** Largest representable value. */\n  export const MAX_VALUE: i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i32;\ndeclare namespace i32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i32;\n  /** Largest representable value. */\n  export const MAX_VALUE: i32;\n  /** Loads an 8-bit signed integer value from memory and returns it as a 32-bit integer. */\n  export function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  /** Loads an 8-bit unsigned integer value from memory and returns it as a 32-bit integer. */\n  export function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  /** Loads a 16-bit signed integer value from memory and returns it as a 32-bit integer. */\n  export function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  /** Loads a 16-bit unsigned integer value from memory and returns it as a 32-bit integer. */\n  export function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  /** Loads a 32-bit integer value from memory. */\n  export function load(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  /** Stores a 32-bit integer value to memory as an 8-bit integer. */\n  export function store8(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  /** Stores a 32-bit integer value to memory as a 16-bit integer. */\n  export function store16(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  /** Stores a 32-bit integer value to memory. */\n  export function store(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  /** Atomic 32-bit integer operations. */\n  export namespace atomic {\n    /** Atomically loads an 8-bit unsigned integer value from memory and returns it as a 32-bit integer. */\n    export function load8_u(offset: usize, immOffset?: usize): i32;\n    /** Atomically loads a 16-bit unsigned integer value from memory and returns it as a 32-bit integer. */\n    export function load16_u(offset: usize, immOffset?: usize): i32;\n    /** Atomically loads a 32-bit integer value from memory and returns it. */\n    export function load(offset: usize, immOffset?: usize): i32;\n    /** Atomically stores a 32-bit integer value to memory as an 8-bit integer. */\n    export function store8(offset: usize, value: i32, immOffset?: usize): void;\n    /** Atomically stores a 32-bit integer value to memory as a 16-bit integer. */\n    export function store16(offset: usize, value: i32, immOffset?: usize): void;\n    /** Atomically stores a 32-bit integer value to memory. */\n    export function store(offset: usize, value: i32, immOffset?: usize): void;\n    /** Performs a wait operation on a 32-bit integer value in memory suspending this agent if the condition is met. */\n    export function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n    /** Atomic 32-bit integer read-modify-write operations on 8-bit values. */\n    export namespace rmw8 {\n      /** Atomically adds an 8-bit unsigned integer value in memory. */\n      export function add_u(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically subtracts an 8-bit unsigned integer value in memory. */\n      export function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise AND operation an 8-bit unsigned integer value in memory. */\n      export function and_u(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise OR operation an 8-bit unsigned integer value in memory. */\n      export function or_u(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise XOR operation an 8-bit unsigned integer value in memory. */\n      export function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically exchanges an 8-bit unsigned integer value in memory. */\n      export function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically compares and exchanges an 8-bit unsigned integer value in memory if the condition is met. */\n      export function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n    /** Atomic 32-bit integer read-modify-write operations on 16-bit values. */\n    export namespace rmw16 {\n      /** Atomically adds a 16-bit unsigned integer value in memory. */\n      export function add_u(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically adds a 16-bit unsigned integer value in memory. */\n      export function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise AND operation a 16-bit unsigned integer value in memory. */\n      export function and_u(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise OR operation a 16-bit unsigned integer value in memory. */\n      export function or_u(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise XOR operation a 16-bit unsigned integer value in memory. */\n      export function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically exchanges a 16-bit unsigned integer value in memory. */\n      export function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically compares and exchanges a 16-bit unsigned integer value in memory if the condition is met. */\n      export function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n    /** Atomic 32-bit integer read-modify-write operations. */\n    export namespace rmw {\n      /** Atomically adds a 32-bit integer value in memory. */\n      export function add(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically subtracts a 32-bit integer value in memory. */\n      export function sub(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise AND operation a 32-bit integer value in memory. */\n      export function and(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise OR operation a 32-bit integer value in memory. */\n      export function or(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise XOR operation a 32-bit integer value in memory. */\n      export function xor(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically exchanges a 32-bit integer value in memory. */\n      export function xchg(offset: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically compares and exchanges a 32-bit integer value in memory if the condition is met. */\n      export function cmpxchg(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n/** Converts any other numeric value to a 64-bit signed integer. */\ndeclare function i64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i64;\ndeclare namespace i64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i64;\n  /** Largest representable value. */\n  export const MAX_VALUE: i64;\n  /** Loads an 8-bit signed integer value from memory and returns it as a 64-bit integer. */\n  export function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Loads an 8-bit unsigned integer value from memory and returns it as a 64-bit integer. */\n  export function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Loads a 16-bit signed integer value from memory and returns it as a 64-bit integer. */\n  export function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Loads a 16-bit unsigned integer value from memory and returns it as a 64-bit integer. */\n  export function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Loads a 32-bit signed integer value from memory and returns it as a 64-bit integer. */\n  export function load32_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Loads a 32-bit unsigned integer value from memory and returns it as a 64-bit integer. */\n  export function load32_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Loads a 64-bit unsigned integer value from memory. */\n  export function load(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Stores a 64-bit integer value to memory as an 8-bit integer. */\n  export function store8(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  /** Stores a 64-bit integer value to memory as a 16-bit integer. */\n  export function store16(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  /** Stores a 64-bit integer value to memory as a 32-bit integer. */\n  export function store32(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  /** Stores a 64-bit integer value to memory. */\n  export function store(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  /** Atomic 64-bit integer operations. */\n  export namespace atomic {\n    /** Atomically loads an 8-bit unsigned integer value from memory and returns it as a 64-bit integer. */\n    export function load8_u(offset: usize, immOffset?: usize): i64;\n    /** Atomically loads a 16-bit unsigned integer value from memory and returns it as a 64-bit integer. */\n    export function load16_u(offset: usize, immOffset?: usize): i64;\n    /** Atomically loads a 32-bit unsigned integer value from memory and returns it as a 64-bit integer. */\n    export function load32_u(offset: usize, immOffset?: usize): i64;\n    /** Atomically loads a 64-bit integer value from memory and returns it. */\n    export function load(offset: usize, immOffset?: usize): i64;\n    /** Atomically stores a 64-bit integer value to memory as an 8-bit integer. */\n    export function store8(offset: usize, value: i64, immOffset?: usize): void;\n    /** Atomically stores a 64-bit integer value to memory as a 16-bit integer. */\n    export function store16(offset: usize, value: i64, immOffset?: usize): void;\n    /** Atomically stores a 64-bit integer value to memory as a 32-bit integer. */\n    export function store32(offset: usize, value: i64, immOffset?: usize): void;\n    /** Atomically stores a 64-bit integer value to memory. */\n    export function store(offset: usize, value: i64, immOffset?: usize): void;\n    /** Performs a wait operation on a 64-bit integer value in memory suspending this agent if the condition is met. */\n    export function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n    /** Atomic 64-bit integer read-modify-write operations on 8-bit values. */\n    export namespace rmw8 {\n      /** Atomically adds an 8-bit unsigned integer value in memory. */\n      export function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically subtracts an 8-bit unsigned integer value in memory. */\n      export function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise AND operation on an 8-bit unsigned integer value in memory. */\n      export function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise OR operation on an 8-bit unsigned integer value in memory. */\n      export function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise XOR operation on an 8-bit unsigned integer value in memory. */\n      export function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically exchanges an 8-bit unsigned integer value in memory. */\n      export function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically compares and exchanges an 8-bit unsigned integer value in memory if the condition is met. */\n      export function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    /** Atomic 64-bit integer read-modify-write operations on 16-bit values. */\n    export namespace rmw16 {\n      /** Atomically adds a 16-bit unsigned integer value in memory. */\n      export function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically subtracts a 16-bit unsigned integer value in memory. */\n      export function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise AND operation on a 16-bit unsigned integer value in memory. */\n      export function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise OR operation on a 16-bit unsigned integer value in memory. */\n      export function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise XOR operation on a 16-bit unsigned integer value in memory. */\n      export function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically exchanges a 16-bit unsigned integer value in memory. */\n      export function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically compares and exchanges a 16-bit unsigned integer value in memory if the condition is met. */\n      export function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    /** Atomic 64-bit integer read-modify-write operations on 32-bit values. */\n    export namespace rmw32 {\n      /** Atomically adds a 32-bit unsigned integer value in memory. */\n      export function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically subtracts a 32-bit unsigned integer value in memory. */\n      export function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise AND operation on a 32-bit unsigned integer value in memory. */\n      export function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise OR operation on a 32-bit unsigned integer value in memory. */\n      export function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise XOR operation on a 32-bit unsigned integer value in memory. */\n      export function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically exchanges a 32-bit unsigned integer value in memory. */\n      export function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically compares and exchanges a 32-bit unsigned integer value in memory if the condition is met. */\n      export function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    /** Atomic 64-bit integer read-modify-write operations. */\n    export namespace rmw {\n      /** Atomically adds a 64-bit integer value in memory. */\n      export function add(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically subtracts a 64-bit integer value in memory. */\n      export function sub(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise AND operation on a 64-bit integer value in memory. */\n      export function and(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise OR operation on a 64-bit integer value in memory. */\n      export function or(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise XOR operation on a 64-bit integer value in memory. */\n      export function xor(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically exchanges a 64-bit integer value in memory. */\n      export function xchg(offset: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically compares and exchanges a 64-bit integer value in memory if the condition is met. */\n      export function cmpxchg(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare var isize: typeof i32 | typeof i64;\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace u8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u8;\n  /** Largest representable value. */\n  export const MAX_VALUE: u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace u16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u16;\n  /** Largest representable value. */\n  export const MAX_VALUE: u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i32;\ndeclare namespace u32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u32;\n  /** Largest representable value. */\n  export const MAX_VALUE: u32;\n}\n/** Converts any other numeric value to a 64-bit unsigned integer. */\ndeclare function u64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i64;\ndeclare namespace u64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u64;\n  /** Largest representable value. */\n  export const MAX_VALUE: u64;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare var usize: typeof u32 | typeof u64;\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): bool;\ndeclare namespace bool {\n  /** Smallest representable value. */\n  export const MIN_VALUE: bool;\n  /** Largest representable value. */\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): f32;\ndeclare namespace f32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f32;\n  /** Largest representable value. */\n  export const MAX_VALUE: f32;\n  /** Smallest normalized positive value. */\n  export const MIN_POSITIVE_VALUE: f32;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n  /** Loads a 32-bit float from memory. */\n  export function load(offset: usize, immOffset?: usize, immAlign?: usize): f32;\n  /** Stores a 32-bit float to memory. */\n  export function store(offset: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): f64;\ndeclare namespace f64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f64;\n  /** Largest representable value. */\n  export const MAX_VALUE: f64;\n  /** Smallest normalized positive value. */\n  export const MIN_POSITIVE_VALUE: f64;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n  /** Loads a 64-bit float from memory. */\n  export function load(offset: usize, immOffset?: usize, immAlign?: usize): f64;\n  /** Stores a 64-bit float to memory. */\n  export function store(offset: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n}\n/** Initializes a 128-bit vector from sixteen 8-bit integer values. Arguments must be compile-time constants. */\ndeclare function v128(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\ndeclare namespace v128 {\n  /** Creates a 128-bit vector with identical lanes. */\n  export function splat<T>(x: T): v128;\n  /** Extracts one lane from a 128-bit vector as a scalar. */\n  export function extract_lane<T>(x: v128, idx: u8): T;\n  /** Replaces one lane in a 128-bit vector. */\n  export function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n  /** Selects lanes from either 128-bit vector according to the specified lane indexes. */\n  export function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n  /** Loads a 128-bit vector from memory. */\n  export function load(offset: usize, immOffset?: usize, immAlign?: usize): v128;\n  /** Stores a 128-bit vector to memory. */\n  export function store(offset: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n  /** Adds each lane of two 128-bit vectors. */\n  export function add<T>(a: v128, b: v128): v128;\n  /** Subtracts each lane of two 128-bit vectors. */\n  export function sub<T>(a: v128, b: v128): v128;\n  /** Multiplies each lane of two 128-bit vectors. */\n  export function mul<T>(a: v128, b: v128): v128; // except i64\n  /** Divides each lane of two 128-bit vectors. */\n  export function div<T = f32 | f64>(a: v128, b: v128): v128;\n  /** Negates each lane of a 128-bit vector */\n  export function neg<T>(a: v128): v128;\n  /** Adds each lane of two 128-bit vectors using saturation. */\n  export function add_saturate<T>(a: v128, b: v128): v128;\n  /** Subtracts each lane of two 128-bit vectors using saturation. */\n  export function sub_saturate<T>(a: v128, b: v128): v128;\n  /** Performs a bitwise left shift on each lane of a 128-bit vector by a scalar. */\n  export function shl<T>(a: v128, b: i32): v128;\n  /** Performs a bitwise right shift on each lane of a 128-bit vector by a scalar. */\n  export function shr<T>(a: v128, b: i32): v128;\n  /** Performs the bitwise AND operation on each lane of two 128-bit vectors. */\n  export function and(a: v128, b: v128): v128;\n  /** Performs the bitwise OR operation on each lane of two 128-bit vectors. */\n  export function or(a: v128, b: v128): v128;\n  /** Performs the bitwise XOR operation on each lane of two 128-bit vectors. */\n  export function xor(a: v128, b: v128): v128;\n  /** Performs the bitwise NOT operation on each lane of a 128-bit vector. */\n  export function not(a: v128): v128;\n  /** Selects bits of either 128-bit vector according to the specified mask. */\n  export function bitselect(v1: v128, v2: v128, mask: v128): v128;\n  /** Reduces a 128-bit vector to a scalar indicating whether any lane is considered `true`. */\n  export function any_true<T>(a: v128): bool;\n  /** Reduces a 128-bit vector to a scalar indicating whether all lanes are considered `true`. */\n  export function all_true<T>(a: v128): bool;\n  /** Computes the minimum of each lane of two 128-bit vectors. */\n  export function min<T = f32 | f64>(a: v128, b: v128): v128;\n  /** Computes the maximum of each lane of two 128-bit vectors. */\n  export function max<T = f32 | f64>(a: v128, b: v128): v128;\n  /** Computes the absolute value of each lane of a 128-bit vector. */\n  export function abs<T = f32 | f64>(a: v128): v128;\n  /** Computes the square root of each lane of a 128-bit vector. */\n  export function sqrt<T = f32 | f64>(a: v128): v128;\n  /** Computes which lanes of two 128-bit vectors are equal. */\n  export function eq<T>(a: v128, b: v128): v128;\n  /** Computes which lanes of two 128-bit vectors are not equal. */\n  export function ne<T>(a: v128, b: v128): v128;\n  /** Computes which lanes of the first 128-bit vector are less than those of the second. */\n  export function lt<T>(a: v128, b: v128): v128;\n  /** Computes which lanes of the first 128-bit vector are less than or equal those of the second. */\n  export function le<T>(a: v128, b: v128): v128;\n  /** Computes which lanes of the first 128-bit vector are greater than those of the second. */\n  export function gt<T>(a: v128, b: v128): v128;\n  /** Computes which lanes of the first 128-bit vector are greater than or equal those of the second. */\n  export function ge<T>(a: v128, b: v128): v128;\n  /** Converts each lane of a 128-bit vector from integer to floating point. */\n  export function convert<TFrom = i32 | u32 | i64 | u64>(a: v128): v128;\n  /** Truncates each lane of a 128-bit vector from floating point to integer with saturation. */\n  export function trunc<TTo = i32 | u32 | i64 | u64>(a: v128): v128;\n}\n/** Initializes a 128-bit vector from sixteen 8-bit integer values. Arguments must be compile-time constants. */\ndeclare function i8x16(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\ndeclare namespace i8x16 {\n  /** Creates a vector with sixteen identical 8-bit integer lanes. */\n  export function splat(x: i8): v128;\n  /** Extracts one 8-bit integer lane from a 128-bit vector as a signed scalar. */\n  export function extract_lane_s(x: v128, idx: u8): i8;\n  /** Extracts one 8-bit integer lane from a 128-bit vector as an unsigned scalar. */\n  export function extract_lane_u(x: v128, idx: u8): u8;\n  /** Replaces one 8-bit integer lane in a 128-bit vector. */\n  export function replace_lane(x: v128, idx: u8, value: i8): v128;\n  /** Adds each 8-bit integer lane of two 128-bit vectors. */\n  export function add(a: v128, b: v128): v128;\n  /** Subtracts each 8-bit integer lane of two 128-bit vectors. */\n  export function sub(a: v128, b: v128): v128;\n  /** Multiplies each 8-bit integer lane of two 128-bit vectors. */\n  export function mul(a: v128, b: v128): v128;\n  /** Negates each 8-bit integer lane of a 128-bit vector. */\n  export function neg(a: v128): v128;\n  /** Adds each 8-bit integer lane of two 128-bit vectors using signed saturation. */\n  export function add_saturate_s(a: v128, b: v128): v128;\n  /** Adds each 8-bit integer lane of two 128-bit vectors using unsigned saturation. */\n  export function add_saturate_u(a: v128, b: v128): v128;\n  /** Subtracts each 8-bit integer lane of two 128-bit vectors using signed saturation. */\n  export function sub_saturate_s(a: v128, b: v128): v128;\n  /** Subtracts each 8-bit integer lane of two 128-bit vectors using unsigned saturation. */\n  export function sub_saturate_u(a: v128, b: v128): v128;\n  /** Performs a bitwise left shift on each 8-bit integer lane of a 128-bit vector by a scalar. */\n  export function shl(a: v128, b: i32): v128;\n  /** Performs a bitwise arithmetic right shift on each 8-bit integer lane of a 128-bit vector by a scalar. */\n  export function shr_s(a: v128, b: i32): v128;\n  /** Performs a bitwise logical right shift on each 8-bit integer lane of a 128-bit vector by a scalar. */\n  export function shr_u(a: v128, b: i32): v128;\n  /** Reduces a 128-bit vector to a scalar indicating whether any 8-bit integer lane is considered `true`. */\n  export function any_true(a: v128): bool;\n  /** Reduces a 128-bit vector to a scalar indicating whether all 8-bit integer lanes are considered `true`. */\n  export function all_true(a: v128): bool;\n  /** Computes which 8-bit integer lanes of two 128-bit vectors are equal. */\n  export function eq(a: v128, b: v128): v128;\n  /** Computes which 8-bit integer lanes of two 128-bit vectors are not equal. */\n  export function ne(a: v128, b: v128): v128;\n  /** Computes which 8-bit signed integer lanes of the first 128-bit vector are less than those of the second. */\n  export function lt_s(a: v128, b: v128): v128;\n  /** Computes which 8-bit unsigned integer lanes of the first 128-bit vector are less than those of the second. */\n  export function lt_u(a: v128, b: v128): v128;\n  /** Computes which 8-bit signed integer lanes of the first 128-bit vector are less than or equal those of the second. */\n  export function le_s(a: v128, b: v128): v128;\n  /** Computes which 8-bit unsigned integer lanes of the first 128-bit vector are less than or equal those of the second. */\n  export function le_u(a: v128, b: v128): v128;\n  /** Computes which 8-bit signed integer lanes of the first 128-bit vector are greater than those of the second. */\n  export function gt_s(a: v128, b: v128): v128;\n  /** Computes which 8-bit unsigned integer lanes of the first 128-bit vector are greater than those of the second. */\n  export function gt_u(a: v128, b: v128): v128;\n  /** Computes which 8-bit signed integer lanes of the first 128-bit vector are greater than or equal those of the second. */\n  export function ge_s(a: v128, b: v128): v128;\n  /** Computes which 8-bit unsigned integer lanes of the first 128-bit vector are greater than or equal those of the second. */\n  export function ge_u(a: v128, b: v128): v128;\n}\n/** Initializes a 128-bit vector from eight 16-bit integer values. Arguments must be compile-time constants. */\ndeclare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\ndeclare namespace i16x8 {\n  /** Creates a vector with eight identical 16-bit integer lanes. */\n  export function splat(x: i16): v128;\n  /** Extracts one 16-bit integer lane from a 128-bit vector as a signed scalar. */\n  export function extract_lane_s(x: v128, idx: u8): i16;\n  /** Extracts one 16-bit integer lane from a 128-bit vector as an unsigned scalar. */\n  export function extract_lane_u(x: v128, idx: u8): u16;\n  /** Replaces one 16-bit integer lane in a 128-bit vector. */\n  export function replace_lane(x: v128, idx: u8, value: i16): v128;\n  /** Adds each 16-bit integer lane of two 128-bit vectors. */\n  export function add(a: v128, b: v128): v128;\n  /** Subtracts each 16-bit integer lane of two 128-bit vectors. */\n  export function sub(a: v128, b: v128): v128;\n  /** Multiplies each 16-bit integer lane of two 128-bit vectors. */\n  export function mul(a: v128, b: v128): v128;\n  /** Negates each 16-bit integer lane of a 128-bit vector. */\n  export function neg(a: v128): v128;\n  /** Adds each 16-bit integer lane of two 128-bit vectors using signed saturation. */\n  export function add_saturate_s(a: v128, b: v128): v128;\n  /** Adds each 16-bit integer lane of two 128-bit vectors using unsigned saturation. */\n  export function add_saturate_u(a: v128, b: v128): v128;\n  /** Subtracts each 16-bit integer lane of two 128-bit vectors using signed saturation. */\n  export function sub_saturate_s(a: v128, b: v128): v128;\n  /** Subtracts each 16-bit integer lane of two 128-bit vectors using unsigned saturation. */\n  export function sub_saturate_u(a: v128, b: v128): v128;\n  /** Performs a bitwise left shift on each 16-bit integer lane of a 128-bit vector by a scalar. */\n  export function shl(a: v128, b: i32): v128;\n  /** Performs a bitwise arithmetic right shift each 16-bit integer lane of a 128-bit vector by a scalar. */\n  export function shr_s(a: v128, b: i32): v128;\n  /** Performs a bitwise logical right shift on each 16-bit integer lane of a 128-bit vector by a scalar. */\n  export function shr_u(a: v128, b: i32): v128;\n  /** Reduces a 128-bit vector to a scalar indicating whether any 16-bit integer lane is considered `true`. */\n  export function any_true(a: v128): bool;\n  /** Reduces a 128-bit vector to a scalar indicating whether all 16-bit integer lanes are considered `true`. */\n  export function all_true(a: v128): bool;\n  /** Computes which 16-bit integer lanes of two 128-bit vectors are equal. */\n  export function eq(a: v128, b: v128): v128;\n  /** Computes which 16-bit integer lanes of two 128-bit vectors are not equal. */\n  export function ne(a: v128, b: v128): v128;\n  /** Computes which 16-bit signed integer lanes of the first 128-bit vector are less than those of the second. */\n  export function lt_s(a: v128, b: v128): v128;\n  /** Computes which 16-bit unsigned integer lanes of the first 128-bit vector are less than those of the second. */\n  export function lt_u(a: v128, b: v128): v128;\n  /** Computes which 16-bit signed integer lanes of the first 128-bit vector are less than or equal those of the second. */\n  export function le_s(a: v128, b: v128): v128;\n  /** Computes which 16-bit unsigned integer lanes of the first 128-bit vector are less than or equal those of the second. */\n  export function le_u(a: v128, b: v128): v128;\n  /** Computes which 16-bit signed integer lanes of the first 128-bit vector are greater than those of the second. */\n  export function gt_s(a: v128, b: v128): v128;\n  /** Computes which 16-bit unsigned integer lanes of the first 128-bit vector are greater than those of the second. */\n  export function gt_u(a: v128, b: v128): v128;\n  /** Computes which 16-bit signed integer lanes of the first 128-bit vector are greater than or equal those of the second. */\n  export function ge_s(a: v128, b: v128): v128;\n  /** Computes which 16-bit unsigned integer lanes of the first 128-bit vector are greater than or equal those of the second. */\n  export function ge_u(a: v128, b: v128): v128;\n}\n/** Initializes a 128-bit vector from four 32-bit integer values. Arguments must be compile-time constants. */\ndeclare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\ndeclare namespace i32x4 {\n  /** Creates a 128-bit vector with four identical 32-bit integer lanes. */\n  export function splat(x: i32): v128;\n  /** Extracts one 32-bit integer lane from a 128-bit vector as a scalar. */\n  export function extract_lane(x: v128, idx: u8): i32;\n  /** Replaces one 32-bit integer lane in a 128-bit vector. */\n  export function replace_lane(x: v128, idx: u8, value: i32): v128;\n  /** Adds each 32-bit integer lane of two 128-bit vectors. */\n  export function add(a: v128, b: v128): v128;\n  /** Subtracts each 32-bit integer lane of two 128-bit vectors. */\n  export function sub(a: v128, b: v128): v128;\n  /** Multiplies each 32-bit integer lane of two 128-bit vectors. */\n  export function mul(a: v128, b: v128): v128;\n  /** Negates each 32-bit integer lane of a 128-bit vector. */\n  export function neg(a: v128): v128;\n  /** Performs a bitwise left shift on each 32-bit integer lane of a 128-bit vector by a scalar. */\n  export function shl(a: v128, b: i32): v128;\n  /** Performs a bitwise arithmetic right shift on each 32-bit integer lane of a 128-bit vector by a scalar. */\n  export function shr_s(a: v128, b: i32): v128;\n  /** Performs a bitwise logical right shift on each 32-bit integer lane of a 128-bit vector by a scalar. */\n  export function shr_u(a: v128, b: i32): v128;\n  /** Reduces a 128-bit vector to a scalar indicating whether any 32-bit integer lane is considered `true`. */\n  export function any_true(a: v128): bool;\n  /** Reduces a 128-bit vector to a scalar indicating whether all 32-bit integer lanes are considered `true`. */\n  export function all_true(a: v128): bool;\n  /** Computes which 32-bit integer lanes of two 128-bit vectors are equal. */\n  export function eq(a: v128, b: v128): v128;\n  /** Computes which 32-bit integer lanes of two 128-bit vectors are not equal. */\n  export function ne(a: v128, b: v128): v128;\n  /** Computes which 32-bit signed integer lanes of the first 128-bit vector are less than those of the second. */\n  export function lt_s(a: v128, b: v128): v128;\n  /** Computes which 32-bit unsigned integer lanes of the first 128-bit vector are less than those of the second. */\n  export function lt_u(a: v128, b: v128): v128;\n  /** Computes which 32-bit signed integer lanes of the first 128-bit vector are less than or equal those of the second. */\n  export function le_s(a: v128, b: v128): v128;\n  /** Computes which 32-bit unsigned integer lanes of the first 128-bit vector are less than or equal those of the second. */\n  export function le_u(a: v128, b: v128): v128;\n  /** Computes which 32-bit signed integer lanes of the first 128-bit vector are greater than those of the second. */\n  export function gt_s(a: v128, b: v128): v128;\n  /** Computes which 32-bit unsigned integer lanes of the first 128-bit vector are greater than those of the second. */\n  export function gt_u(a: v128, b: v128): v128;\n  /** Computes which 32-bit signed integer lanes of the first 128-bit vector are greater than or equal those of the second. */\n  export function ge_s(a: v128, b: v128): v128;\n  /** Computes which 32-bit unsigned integer lanes of the first 128-bit vector are greater than or equal those of the second. */\n  export function ge_u(a: v128, b: v128): v128;\n  /** Truncates each 32-bit float lane of a 128-bit vector to a signed integer with saturation. */\n  export function trunc_s_f32x4_sat(a: v128): v128;\n  /** Truncates each 32-bit float lane of a 128-bit vector to an unsigned integer with saturation. */\n  export function trunc_u_f32x4_sat(a: v128): v128;\n}\n/** Initializes a 128-bit vector from two 64-bit integer values. Arguments must be compile-time constants. */\ndeclare function i64x2(a: i64, b: i64): v128;\ndeclare namespace i64x2 {\n  /** Creates a 128-bit vector with two identical 64-bit integer lanes. */\n  export function splat(x: i64): v128;\n  /** Extracts one 64-bit integer lane from a 128-bit vector as a scalar. */\n  export function extract_lane(x: v128, idx: u8): i64;\n  /** Replaces one 64-bit integer lane in a 128-bit vector. */\n  export function replace_lane(x: v128, idx: u8, value: i64): v128;\n  /** Adds each 64-bit integer lane of two 128-bit vectors. */\n  export function add(a: v128, b: v128): v128;\n  /** Subtracts each 64-bit integer lane of two 128-bit vectors. */\n  export function sub(a: v128, b: v128): v128;\n  /** Multiplies each 64-bit integer lane of two 128-bit vectors. */\n  export function mul(a: v128, b: v128): v128;\n  /** Negates each 64-bit integer lane of a 128-bit vector. */\n  export function neg(a: v128): v128;\n  /** Performs a bitwise left shift on each 64-bit integer lane of a 128-bit vector by a scalar. */\n  export function shl(a: v128, b: i32): v128;\n  /** Performs a bitwise arithmetic right shift on each 64-bit integer lane of a 128-bit vector by a scalar. */\n  export function shr_s(a: v128, b: i32): v128;\n  /** Performs a bitwise logical right shift on each 64-bit integer lane of a 128-bit vector by a scalar. */\n  export function shr_u(a: v128, b: i32): v128;\n  /** Reduces a 128-bit vector to a scalar indicating whether any 64-bit integer lane is considered `true`. */\n  export function any_true(a: v128): bool;\n  /** Reduces a 128-bit vector to a scalar indicating whether all 64-bit integer lanes are considered `true`. */\n  export function all_true(a: v128): bool;\n  /** Truncates each 64-bit float lane of a 128-bit vector to a signed integer with saturation. */\n  export function trunc_s_f64x2_sat(a: v128): v128;\n  /** Truncates each 64-bit float lane of a 128-bit vector to an unsigned integer with saturation. */\n  export function trunc_u_f64x2_sat(a: v128): v128;\n}\n/** Initializes a 128-bit vector from four 32-bit float values. Arguments must be compile-time constants. */\ndeclare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\ndeclare namespace f32x4 {\n  /** Creates a 128-bit vector with four identical 32-bit float lanes. */\n  export function splat(x: f32): v128;\n  /** Extracts one 32-bit float lane from a 128-bit vector as a scalar. */\n  export function extract_lane(x: v128, idx: u8): f32;\n  /** Replaces one 32-bit float lane in a 128-bit vector. */\n  export function replace_lane(x: v128, idx: u8, value: f32): v128;\n  /** Adds each 32-bit float lane of two 128-bit vectors. */\n  export function add(a: v128, b: v128): v128;\n  /** Subtracts each 32-bit float lane of two 128-bit vectors. */\n  export function sub(a: v128, b: v128): v128;\n  /** Multiplies each 32-bit float lane of two 128-bit vectors. */\n  export function mul(a: v128, b: v128): v128;\n  /** Divides each 32-bit float lane of two 128-bit vectors. */\n  export function div(a: v128, b: v128): v128;\n  /** Negates each 32-bit float lane of a 128-bit vector. */\n  export function neg(a: v128): v128;\n  /** Computes the minimum of each 32-bit float lane of two 128-bit vectors. */\n  export function min(a: v128, b: v128): v128;\n  /** Computes the maximum of each 32-bit float lane of two 128-bit vectors. */\n  export function max(a: v128, b: v128): v128;\n  /** Computes the absolute value of each 32-bit float lane of a 128-bit vector. */\n  export function abs(a: v128): v128;\n  /** Computes the square root of each 32-bit float lane of a 128-bit vector. */\n  export function sqrt(a: v128): v128;\n  /** Computes which 32-bit float lanes of two 128-bit vectors are equal. */\n  export function eq(a: v128, b: v128): v128;\n  /** Computes which 32-bit float lanes of two 128-bit vectors are not equal. */\n  export function ne(a: v128, b: v128): v128;\n  /** Computes which 32-bit float lanes of the first 128-bit vector are less than those of the second. */\n  export function lt(a: v128, b: v128): v128;\n  /** Computes which 32-bit float lanes of the first 128-bit vector are less than or equal those of the second. */\n  export function le(a: v128, b: v128): v128;\n  /** Computes which 32-bit float lanes of the first 128-bit vector are greater than those of the second. */\n  export function gt(a: v128, b: v128): v128;\n  /** Computes which 32-bit float lanes of the first 128-bit vector are greater than or equal those of the second. */\n  export function ge(a: v128, b: v128): v128;\n  /** Converts each 32-bit signed integer lane of a 128-bit vector to floating point. */\n  export function convert_s_i32x4(a: v128): v128;\n  /** Converts each 32-bit unsigned integer lane of a 128-bit vector to floating point. */\n  export function convert_u_i32x4(a: v128): v128;\n}\n/** Initializes a 128-bit vector from two 64-bit float values. Arguments must be compile-time constants. */\ndeclare function f64x2(a: f64, b: f64): v128;\ndeclare namespace f64x2 {\n  /** Creates a 128-bit vector with two identical 64-bit float lanes. */\n  export function splat(x: f64): v128;\n  /** Extracts one 64-bit float lane from a 128-bit vector as a scalar. */\n  export function extract_lane(x: v128, idx: u8): f64;\n  /** Replaces one 64-bit float lane in a 128-bit vector. */\n  export function replace_lane(x: v128, idx: u8, value: f64): v128;\n  /** Adds each 64-bit float lane of two 128-bit vectors. */\n  export function add(a: v128, b: v128): v128;\n  /** Subtracts each 64-bit float lane of two 128-bit vectors. */\n  export function sub(a: v128, b: v128): v128;\n  /** Multiplies each 64-bit float lane of two 128-bit vectors. */\n  export function mul(a: v128, b: v128): v128;\n  /** Divides each 64-bit float lane of two 128-bit vectors. */\n  export function div(a: v128, b: v128): v128;\n  /** Negates each 64-bit float lane of a 128-bit vector. */\n  export function neg(a: v128): v128;\n  /** Computes the minimum of each 64-bit float lane of two 128-bit vectors. */\n  export function min(a: v128, b: v128): v128;\n  /** Computes the maximum of each 64-bit float lane of two 128-bit vectors. */\n  export function max(a: v128, b: v128): v128;\n  /** Computes the absolute value of each 64-bit float lane of a 128-bit vector. */\n  export function abs(a: v128): v128;\n  /** Computes the square root of each 64-bit float lane of a 128-bit vector. */\n  export function sqrt(a: v128): v128;\n  /** Computes which 64-bit float lanes of two 128-bit vectors are equal. */\n  export function eq(a: v128, b: v128): v128;\n  /** Computes which 64-bit float lanes of two 128-bit vectors are not equal. */\n  export function ne(a: v128, b: v128): v128;\n  /** Computes which 64-bit float lanes of the first 128-bit vector are less than those of the second. */\n  export function lt(a: v128, b: v128): v128;\n  /** Computes which 64-bit float lanes of the first 128-bit vector are less than or equal those of the second. */\n  export function le(a: v128, b: v128): v128;\n  /** Computes which 64-bit float lanes of the first 128-bit vector are greater than those of the second. */\n  export function gt(a: v128, b: v128): v128;\n  /** Computes which 64-bit float lanes of the first 128-bit vector are greater than or equal those of the second. */\n  export function ge(a: v128, b: v128): v128;\n  /** Converts each 64-bit signed integer lane of a 128-bit vector to floating point. */\n  export function convert_s_i64x2(a: v128): v128;\n  /** Converts each 64-bit unsigned integer lane of a 128-bit vector to floating point. */\n  export function convert_u_i64x2(a: v128): v128;\n}\ndeclare namespace v8x16 {\n  /** Selects 8-bit lanes from either 128-bit vector according to the specified lane indexes. */\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8, l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8): v128;\n}\n/** Macro type evaluating to the underlying native WebAssembly type. */\ndeclare type native<T> = T;\n\n/** Pseudo-class representing the backing class of integer types. */\ndeclare class _Integer {\n  /** Smallest representable value. */\n  static readonly MIN_VALUE: number;\n  /** Largest representable value. */\n  static readonly MAX_VALUE: number;\n  /** Converts a string to an integer of this type. */\n  static parseInt(value: string, radix?: number): number;\n  /** Converts this integer to a string. */\n  toString(): string;\n}\n\n/** Pseudo-class representing the backing class of floating-point types. */\ndeclare class _Float {\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  static readonly EPSILON: f32 | f64;\n  /** Smallest representable value. */\n  static readonly MIN_VALUE: f32 | f64;\n  /** Largest representable value. */\n  static readonly MAX_VALUE: f32 | f64;\n  /** Smallest safely representable integer value. */\n  static readonly MIN_SAFE_INTEGER: f32 | f64;\n  /** Largest safely representable integer value. */\n  static readonly MAX_SAFE_INTEGER: f32 | f64;\n  /** Value representing positive infinity. */\n  static readonly POSITIVE_INFINITY: f32 | f64;\n  /** Value representing negative infinity. */\n  static readonly NEGATIVE_INFINITY: f32 | f64;\n  /** Value representing \'not a number\'. */\n  static readonly NaN: f32 | f64;\n  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */\n  static isNaN(value: f32 | f64): bool;\n  /** Returns true if passed value is finite. */\n  static isFinite(value: f32 | f64): bool;\n  /** Returns true if the value passed is a safe integer. */\n  static isSafeInteger(value: f32 | f64): bool;\n  /** Returns true if the value passed is an integer, false otherwise. */\n  static isInteger(value: f32 | f64): bool;\n  /** Converts a string to an integer. */\n  static parseInt(value: string, radix?: i32): f32 | f64;\n  /** Converts a string to a floating-point number. */\n  static parseFloat(value: string): f32 | f64;\n  /** Converts this floating-point number to a string. */\n  toString(this: f64): string;\n}\n\n/** Backing class of signed 8-bit integers. */\ndeclare const I8: typeof _Integer;\n/** Backing class of signed 16-bit integers. */\ndeclare const I16: typeof _Integer;\n/** Backing class of signed 32-bit integers. */\ndeclare const I32: typeof _Integer;\n/** Backing class of signed 64-bit integers. */\ndeclare const I64: typeof _Integer;\n/** Backing class of signed size integers. */\ndeclare const Isize: typeof _Integer;\n/** Backing class of unsigned 8-bit integers. */\ndeclare const U8: typeof _Integer;\n/** Backing class of unsigned 16-bit integers. */\ndeclare const U16: typeof _Integer;\n/** Backing class of unsigned 32-bit integers. */\ndeclare const U32: typeof _Integer;\n/** Backing class of unsigned 64-bit integers. */\ndeclare const U64: typeof _Integer;\n/** Backing class of unsigned size integers. */\ndeclare const Usize: typeof _Integer;\n/** Backing class of 32-bit floating-point values. */\ndeclare const F32: typeof _Float;\n/** Backing class of 64-bit floating-point values. */\ndeclare const F64: typeof _Float;\n\n// User-defined diagnostic macros\n\n/** Emits a user-defined diagnostic error when encountered. */\ndeclare function ERROR(message?: any): void;\n/** Emits a user-defined diagnostic warning when encountered. */\ndeclare function WARNING(message?: any): void;\n/** Emits a user-defined diagnostic info when encountered. */\ndeclare function INFO(message?: any): void;\n\n// Polyfills\n\n/** Performs the sign-agnostic reverse bytes **/\ndeclare function bswap<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | isize | usize>(value: T): T;\n/** Performs the sign-agnostic reverse bytes only for last 16-bit **/\ndeclare function bswap16<T = i8 | u8 | i16 | u16 | i32 | u32>(value: T): T;\n\n// Standard library\n\n/** Memory operations. */\ndeclare namespace memory {\n  /** Returns the current memory size in units of pages. One page is 64kb. */\n  export function size(): i32;\n  /** Grows linear memory by a given unsigned delta of pages. One page is 64kb. Returns the previous memory size in units of pages or `-1` on failure. */\n  export function grow(value: i32): i32;\n  /** Sets n bytes beginning at the specified destination in memory to the specified byte value. */\n  export function fill(dst: usize, value: u8, count: usize): void;\n  /** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\n  export function copy(dst: usize, src: usize, n: usize): void;\n  /** Copies elements from a passive element segment to a table. */\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void;\n  /** Prevents further use of a passive element segment. */\n  // export function drop(segmentIndex: u32): void;\n  /** Copies elements from one region of a table to another region. */\n  export function allocate(size: usize): usize;\n  /** Disposes a chunk of memory by its pointer. */\n  export function free(ptr: usize): void;\n  /** Compares two chunks of memory. Returns `0` if equal, otherwise the difference of the first differing bytes. */\n  export function compare(vl: usize, vr: usize, n: usize): i32;\n  /** Resets the allocator to its initial state, if supported. */\n  export function reset(): void;\n}\n\n/** Garbage collector operations. */\ndeclare namespace gc {\n  /** Allocates a managed object identified by its visitor function. */\n  export function allocate(size: usize, visitFn: (ref: usize) => void): usize;\n  /** Performs a full garbage collection cycle. */\n  export function collect(): void;\n}\n\n/** Table operations. */\ndeclare namespace table {\n  /** Copies elements from a passive element segment to a table. */\n  // export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void;\n  /** Prevents further use of a passive element segment. */\n  // export function drop(elementIndex: u32): void;\n  /** Copies elements from one region of a table to another region. */\n  // export function copy(dest: u32, src: u32, n: u32): void;\n}\n\n/** Class representing a generic, fixed-length raw binary data buffer. */\ndeclare class ArrayBuffer {\n  /** The size, in bytes, of the array. */\n  readonly byteLength: i32;\n  /** Unsafe pointer to the start of the data in memory. */\n  readonly data: usize;\n  /** Returns true if value is one of the ArrayBuffer views, such as typed array or a DataView **/\n  static isView<T>(value: T): bool;\n  /** Constructs a new array buffer of the given length in bytes. */\n  constructor(length: i32, unsafe?: bool);\n  /** Returns a copy of this array buffer\'s bytes from begin, inclusive, up to end, exclusive. */\n  slice(begin?: i32, end?: i32): ArrayBuffer;\n  /** Returns a string representation of ArrayBuffer. */\n  toString(): string;\n}\n\n/** The `DataView` view provides a low-level interface for reading and writing multiple number types in a binary `ArrayBuffer`, without having to care about the platform\'s endianness. */\ndeclare class DataView {\n  /** The `buffer` accessor property represents the `ArrayBuffer` or `SharedArrayBuffer` referenced by the `DataView` at construction time. */\n  readonly buffer: ArrayBuffer;\n  /** The `byteLength` accessor property represents the length (in bytes) of this view from the start of its `ArrayBuffer` or `SharedArrayBuffer`. */\n  readonly byteLength: i32;\n  /** The `byteOffset` accessor property represents the offset (in bytes) of this view from the start of its `ArrayBuffer` or `SharedArrayBuffer`. */\n  readonly byteOffset: i32;\n  /** Constructs a new `DataView` with the given properties */\n  constructor(buffer: ArrayBuffer, byteOffset?: i32, byteLength?: i32);\n  /** The `getFloat32()` method gets a signed 32-bit float (float) at the specified byte offset from the start of the `DataView`. */\n  getFloat32(byteOffset: i32, littleEndian?: boolean): f32;\n  /** The `getFloat64()` method gets a signed 64-bit float (double) at the specified byte offset from the start of the `DataView`. */\n  getFloat64(byteOffset: i32, littleEndian?: boolean): f64;\n  /** The `getInt8()` method gets a signed 8-bit integer (byte) at the specified byte offset from the start of the `DataView`. */\n  getInt8(byteOffset: i32): i8;\n  /** The `getInt16()` method gets a signed 16-bit integer (short) at the specified byte offset from the start of the `DataView`. */\n  getInt16(byteOffset: i32, littleEndian?: boolean): i16;\n  /** The `getInt32()` method gets a signed 32-bit integer (long) at the specified byte offset from the start of the `DataView`. */\n  getInt32(byteOffset: i32, littleEndian?: boolean): i32;\n  /** The `getInt64()` method gets a signed 64-bit integer (long long) at the specified byte offset from the start of the `DataView`. */\n  getInt64(byteOffset: i32, littleEndian?: boolean): i64;\n  /** The `getUint8()` method gets an unsigned 8-bit integer (unsigned byte) at the specified byte offset from the start of the `DataView`. */\n  getUint8(byteOffset: i32): u8;\n  /** The `getUint16()` method gets an unsigned 16-bit integer (unsigned short) at the specified byte offset from the start of the `DataView`. */\n  getUint16(byteOffset: i32, littleEndian?: boolean): u16;\n  /** The `getUint32()` method gets an unsigned 32-bit integer (unsigned long) at the specified byte offset from the start of the `DataView`. */\n  getUint32(byteOffset: i32, littleEndian?: boolean): u32;\n  /** The `getUint64()` method gets an unsigned 64-bit integer (unsigned long long) at the specified byte offset from the start of the `DataView`. */\n  getUint64(byteOffset: i32, littleEndian?: boolean): u64;\n  /** The `setFloat32()` method stores a signed 32-bit float (float) value at the specified byte offset from the start of the `DataView`. */\n  setFloat32(byteOffset: i32, value: f32, littleEndian?: boolean): void;\n  /** The `setFloat64()` method stores a signed 64-bit float (double) value at the specified byte offset from the start of the `DataView`. */\n  setFloat64(byteOffset: i32, value: f64, littleEndian?: boolean): void;\n  /** The `setInt8()` method stores a signed 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`. */\n  setInt8(byteOffset: i32, value: i8): void;\n  /** The `setInt16()` method stores a signed 16-bit integer (short) value at the specified byte offset from the start of the `DataView`. */\n  setInt16(byteOffset: i32, value: i16, littleEndian?: boolean): void;\n  /** The `setInt32()` method stores a signed 32-bit integer (long) value at the specified byte offset from the start of the `DataView`. */\n  setInt32(byteOffset: i32, value: i32, littleEndian?: boolean): void;\n  /** The `setInt64()` method stores a signed 64-bit integer (long long) value at the specified byte offset from the start of the `DataView`. */\n  setInt64(byteOffset: i32, value: i64, littleEndian?: boolean): void;\n  /** The `setUint8()` method stores an unsigned 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`. */\n  setUint8(byteOffset: i32, value: u8): void;\n  /** The `setUint16()` method stores an unsigned 16-bit integer (unsigned short) value at the specified byte offset from the start of the `DataView`. */\n  setUint16(byteOffset: i32, value: u16, littleEndian?: boolean): void;\n  /** The `setUint32()` method stores an unsigned 32-bit integer (unsigned long) value at the specified byte offset from the start of the `DataView`. */\n  setUint32(byteOffset: i32, value: u32, littleEndian?: boolean): void;\n  /** The `setUint64()` method stores an unsigned 64-bit integer (unsigned long long) value at the specified byte offset from the start of the `DataView`. */\n  setUint64(byteOffset: i32, value: u64, littleEndian?: boolean): void;\n  /** Returns a string representation of DataView. */\n  toString(): string;\n}\n\ninterface ArrayLike<T> {\n  length: i32;\n  // [key: number]: T;\n}\n\n/** Interface for a typed view on an array buffer. */\ninterface ArrayBufferView<T> {\n  [key: number]: T;\n  /** The {@link ArrayBuffer} referenced by this view. */\n  readonly buffer: ArrayBuffer;\n  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteOffset: i32;\n  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteLength: i32;\n}\n\n/* @internal */\ndeclare abstract class TypedArray<T> implements ArrayBufferView<T> {\n  [key: number]: T;\n  /** Number of bytes per element. */\n  static readonly BYTES_PER_ELEMENT: usize;\n  /** Constructs a new typed array. */\n  constructor(length: i32);\n  /** The {@link ArrayBuffer} referenced by this view. */\n  readonly buffer: ArrayBuffer;\n  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteOffset: i32;\n  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteLength: i32;\n  /** The length (in elements). */\n  readonly length: i32;\n  /** Returns a new TypedArray of this type on the same ArrayBuffer from begin inclusive to end exclusive. */\n  subarray(begin?: i32, end?: i32): this;\n  /**  The reduce() method applies a function against an accumulator and each value of the typed array (from left-to-right) has to reduce it to a single value. This method has the same algorithm as Array.prototype.reduce(). */\n  reduce<W>(\n    callbackfn: (accumulator: W, value: T, index: i32, self: this) => W,\n    initialValue: W,\n  ): W;\n  /**  The reduceRight() method applies a function against an accumulator and each value of the typed array (from left-to-right) has to reduce it to a single value, starting from the end of the array. This method has the same algorithm as Array.prototype.reduceRight(). */\n  reduceRight<W>(\n    callbackfn: (accumulator: W, value: T, index: i32, self: this) => W,\n    initialValue: W,\n  ): W;\n  /** The some() method tests whether some element in the typed array passes the test implemented by the provided function. This method has the same algorithm as Array.prototype.some().*/\n  some(callbackfn: (value: T, index: i32, self: this) => bool): bool;\n  /** The map() method creates a new typed array with the results of calling a provided function on every element in this typed array. This method has the same algorithm as Array.prototype.map().*/\n  map(callbackfn: (value: T, index: i32, self: this) => T): this;\n  /** The sort() method sorts the elements of a typed array numerically in place and returns the typed array. This method has the same algorithm as Array.prototype.sort(), except that sorts the values numerically instead of as strings. TypedArray is one of the typed array types here. */\n  sort(callback?: (a: T, b: T) => i32): this;\n  /** The fill() method fills all the elements of a typed array from a start index to an end index with a static value. This method has the same algorithm as Array.prototype.fill(). */\n  fill(value: T, start?: i32, end?: i32): this;\n  /** The findIndex() method returns an index in the typed array, if an element in the typed array satisfies the provided testing function. Otherwise -1 is returned. See also the find() [not implemented] method, which returns the value of a found element in the typed array instead of its index. */\n  findIndex(callbackfn: (value: T, index: i32, self: this) => bool): i32;\n  /** The every() method tests whether all elements in the typed array pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.every(). */\n  every(callbackfn: (value: T, index: i32, self: this) => bool): bool;\n  /** The forEach() method executes a provided function once per array element. This method has the same algorithm as Array.prototype.forEach().*/\n  forEach(callbackfn: (value: T, index: i32, self: this) => void): void;\n  /** The reverse() method reverses a typed array in place. The first typed array element becomes the last and the last becomes the first. This method has the same algorithm as Array.prototype.reverse(). */\n  reverse(): this;\n}\n\n/** An array of twos-complement 8-bit signed integers. */\ndeclare class Int8Array extends TypedArray<i8> {}\n/** An array of 8-bit unsigned integers. */\ndeclare class Uint8Array extends TypedArray<u8> {}\n/** A clamped array of 8-bit unsigned integers. */\ndeclare class Uint8ClampedArray extends TypedArray<u8> {}\n/** An array of twos-complement 16-bit signed integers. */\ndeclare class Int16Array extends TypedArray<i16> {}\n/** An array of 16-bit unsigned integers. */\ndeclare class Uint16Array extends TypedArray<u16> {}\n/** An array of twos-complement 32-bit signed integers. */\ndeclare class Int32Array extends TypedArray<i32> {}\n/** An array of 32-bit unsigned integers. */\ndeclare class Uint32Array extends TypedArray<u32> {}\n/** An array of twos-complement 64-bit signed integers. */\ndeclare class Int64Array extends TypedArray<i64> {}\n/** An array of 64-bit unsigned integers. */\ndeclare class Uint64Array extends TypedArray<u64> {}\n/** An array of 32-bit floating point numbers. */\ndeclare class Float32Array extends TypedArray<f32> {}\n/** An array of 64-bit floating point numbers. */\ndeclare class Float64Array extends TypedArray<f64> {}\n\n/** Class representing a sequence of values of type `T`. */\ndeclare class Array<T> {\n\n  static isArray<U>(value: any): value is Array<any>;\n\n  [key: number]: T;\n  /** Current length of the array. */\n  length: i32;\n  /** Constructs a new array. */\n  constructor(capacity?: i32);\n\n  fill(value: T, start?: i32, end?: i32): this;\n  every(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool;\n  findIndex(predicate: (element: T, index: i32, array?: Array<T>) => bool): i32;\n  includes(searchElement: T, fromIndex?: i32): bool;\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): i32;\n  concat(items: T[]): T[];\n  copyWithin(target: i32, start: i32, end?: i32): this;\n  pop(): T;\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void;\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U>;\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T>;\n  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\n  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\n  shift(): T;\n  some(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool;\n  unshift(element: T): i32;\n  slice(from: i32, to?: i32): Array<T>;\n  splice(start: i32, deleteCount?: i32): Array<T>;\n  sort(comparator?: (a: T, b: T) => i32): this;\n  join(separator?: string): string;\n  reverse(): T[];\n  toString(): string;\n}\n\n/** Class representing a sequence of characters. */\ndeclare class String {\n\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(code: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n\n  readonly length: i32;\n  readonly lengthUTF8: i32;\n\n  charAt(index: u32): string;\n  charCodeAt(index: u32): u16;\n  concat(other: string): string;\n  endsWith(other: string): bool;\n  indexOf(other: string, fromIndex?: i32): u32;\n  lastIndexOf(other: string, fromIndex?: i32): i32;\n  includes(other: string): bool;\n  startsWith(other: string): bool;\n  substr(start: u32, length?: u32): string;\n  substring(start: u32, end?: u32): string;\n  trim(): string;\n  trimLeft(): string;\n  trimRight(): string;\n  trimStart(): string;\n  trimEnd(): string;\n  padStart(targetLength: i32, padString?: string): string;\n  padEnd(targetLength: i32, padString?: string): string;\n  repeat(count?: i32): string;\n  slice(beginIndex: i32, endIndex?: i32): string;\n  split(separator?: string, limit?: i32): string[];\n  toString(): string;\n  static fromUTF8(ptr: usize, len: usize): string;\n  toUTF8(): usize;\n}\n\n/** Class for representing a runtime error. Base class of all errors. */\ndeclare class Error {\n\n  /** Error name. */\n  name: string;\n\n  /** Message provided on construction. */\n  message: string;\n\n  /** Stack trace. */\n  stack?: string;\n\n  /** Constructs a new error, optionally with a message. */\n  constructor(message?: string);\n\n  /** Method returns a string representing the specified Error class. */\n  toString(): string;\n}\n\n/** Class for indicating an error when a value is not in the set or range of allowed values. */\ndeclare class RangeError extends Error { }\n\n/** Class for indicating an error when a value is not of the expected type. */\ndeclare class TypeError extends Error { }\n\n/** Class for indicating an error when trying to interpret syntactically invalid code. */\ndeclare class SyntaxError extends Error { }\n\ninterface Boolean {}\ninterface Function {}\ninterface IArguments {}\ninterface Number {}\ninterface Object {}\ninterface RegExp {}\n\ndeclare class Map<K,V> {\n  readonly size: i32;\n  has(key: K): bool;\n  set(key: K, value: V): void;\n  get(key: K): V;\n  delete(key: K): bool;\n  clear(): void;\n  toString(): string;\n}\n\ndeclare class Set<T> {\n  readonly size: i32;\n  has(value: T): bool;\n  add(value: T): void;\n  delete(value: T): bool;\n  clear(): void;\n  toString(): string;\n}\n\ninterface SymbolConstructor {\n  readonly hasInstance: symbol;\n  readonly isConcatSpreadable: symbol;\n  readonly isRegExp: symbol;\n  readonly iterator: symbol;\n  readonly match: symbol;\n  readonly replace: symbol;\n  readonly search: symbol;\n  readonly species: symbol;\n  readonly split: symbol;\n  readonly toPrimitive: symbol;\n  readonly toStringTag: symbol;\n  readonly unscopables: symbol;\n  (description?: string | null): symbol;\n  for(key: string): symbol;\n  keyFor(sym: symbol): string | null;\n}\n\ndeclare const Symbol: SymbolConstructor;\n\ninterface IMath<T> {\n  /** The base of natural logarithms, e, approximately 2.718. */\n  readonly E: T;\n  /** The natural logarithm of 2, approximately 0.693. */\n  readonly LN2: T;\n  /** The natural logarithm of 10, approximately 2.302. */\n  readonly LN10: T;\n  /** The base 2 logarithm of e, approximately 1.442. */\n  readonly LOG2E: T;\n  /** The base 10 logarithm of e, approximately 0.434. */\n  readonly LOG10E: T;\n  /** The ratio of the circumference of a circle to its diameter, approximately 3.14159. */\n  readonly PI: T;\n  /** The square root of 1/2, approximately 0.707. */\n  readonly SQRT1_2: T;\n  /** The square root of 2, approximately 1.414. */\n  readonly SQRT2: T;\n  /** Returns the absolute value of `x`. */\n  abs(x: T): T;\n  /** Returns the arccosine (in radians) of `x`. */\n  acos(x: T): T;\n  /** Returns the hyperbolic arc-cosine of `x`. */\n  acosh(x: T): T;\n  /** Returns the arcsine (in radians) of `x` */\n  asin(x: T): T;\n  /** Returns the hyperbolic arcsine of `x`. */\n  asinh(x: T): T;\n  /** Returns the arctangent (in radians) of `x`. */\n  atan(x: T): T;\n  /** Returns the arctangent of the quotient of its arguments. */\n  atan2(y: T, x: T): T;\n  /** Returns the hyperbolic arctangent of `x`. */\n  atanh(x: T): T;\n  /** Returns the cube root of `x`. */\n  cbrt(x: T): T;\n  /** Returns the smallest integer greater than or equal to `x`. */\n  ceil(x: T): T;\n  /** Returns the number of leading zero bits in the 32-bit binary representation of `x`. */\n  clz32(x: T): T;\n  /** Returns the cosine (in radians) of `x`. */\n  cos(x: T): T;\n  /** Returns the hyperbolic cosine of `x`. */\n  cosh(x: T): T;\n  /** Returns e to the power of `x`. */\n  exp(x: T): T;\n  /** Returns e to the power of `x`, minus 1. */\n  expm1(x: T): T;\n  /** Returns the largest integer less than or equal to `x`. */\n  floor(x: T): T;\n  /** Returns the nearest 32-bit single precision float representation of `x`. */\n  fround(x: T): f32;\n  /** Returns the square root of the sum of squares of its arguments. */\n  hypot(value1: T, value2: T): T; // TODO: rest\n  /** Returns the result of the C-like 32-bit multiplication of `a` and `b`. */\n  imul(a: T, b: T): T;\n  /** Returns the natural logarithm (base e) of `x`. */\n  log(x: T): T;\n  /** Returns the base 10 logarithm of `x`. */\n  log10(x: T): T;\n  /** Returns the natural logarithm (base e) of 1 + `x`. */\n  log1p(x: T): T;\n  /** Returns the base 2 logarithm of `x`. */\n  log2(x: T): T;\n  /** Returns the largest-valued number of its arguments. */\n  max(value1: T, value2: T): T; // TODO: rest\n  /** Returns the lowest-valued number of its arguments. */\n  min(value1: T, value2: T): T; // TODO: rest\n  /** Returns `base` to the power of `exponent`. */\n  pow(base: T, exponent: T): T;\n  /** Returns a pseudo-random number in the range from 0.0 inclusive up to but not including 1.0. */\n  random(): T;\n  /** Returns the value of `x` rounded to the nearest integer. */\n  round(x: T): T;\n  /** Returns the sign of `x`, indicating whether the number is positive, negative or zero. */\n  sign(x: T): T;\n  /** Returns whether the sign bit of `x` is set */\n  signbit(x: T): bool;\n  /** Returns the sine of `x`. */\n  sin(x: T): T;\n  /** Returns the hyperbolic sine of `x`. */\n  sinh(x: T): T;\n  /** Returns the square root of `x`. */\n  sqrt(x: T): T;\n  /** Returns the tangent of `x`. */\n  tan(x: T): T;\n  /** Returns the hyperbolic tangent of `x`. */\n  tanh(x: T): T;\n  /** Returns the integer part of `x` by removing any fractional digits. */\n  trunc(x: T): T;\n}\n\ninterface INativeMath<T> extends IMath<T> {\n  /** Contains sin value produced after Math/Mathf.sincos */\n  sincos_sin: T;\n  /** Contains cos value produced after Math/Mathf.sincos */\n  sincos_cos: T;\n  /** Seeds the random number generator. */\n  seedRandom(value: i64): void;\n  /** Returns the floating-point remainder of `x / y` (rounded towards zero). */\n  mod(x: T, y: T): T;\n  /** Returns the floating-point remainder of `x / y` (rounded to nearest). */\n  rem(x: T, y: T): T;\n  /** Returns sin and cos simultaneously for same angle. Results stored to `sincos_s32/64` and `sincos_c32/64` globals */\n  sincos(x: T): void;\n}\n\n/** Double precision math imported from JavaScript. */\ndeclare const JSMath: IMath<f64>;\n/** Double precision math implemented natively. */\ndeclare const NativeMath: INativeMath<f64>;\n/** Single precision math implemented natively. */\ndeclare const NativeMathf: INativeMath<f32>;\n/** Alias of {@link NativeMath} or {@link JSMath} respectively. Defaults to `NativeMath`. */\ndeclare const Math: IMath<f64>;\n/** Alias of {@link NativeMathf} or {@link JSMath} respectively. Defaults to `NativeMathf`. */\ndeclare const Mathf: IMath<f32>;\n\ndeclare class Date {\n  /** Returns the UTC timestamp in milliseconds of the specified date. */\n  static UTC(\n    year: i32,\n    month: i32,\n    day: i32,\n    hour: i32,\n    minute: i32,\n    second: i32,\n    millisecond: i32\n  ): i64;\n  /** Returns the current UTC timestamp in milliseconds. */\n  static now(): i64;\n  /** Constructs a new date object from an UTC timestamp in milliseconds. */\n  constructor(value: i64);\n  /** Returns the UTC timestamp of this date in milliseconds. */\n  getTime(): i64;\n  /** Sets the UTC timestamp of this date in milliseconds. */\n  setTime(value: i64): i64;\n}\n\n/** Environmental tracing function for debugging purposes. */\ndeclare function trace(msg: string, n?: i32, a0?: f64, a1?: f64, a2?: f64, a3?: f64, a4?: f64): void;\n\n// Decorators\n\ninterface TypedPropertyDescriptor<T> {\n  configurable?: boolean;\n  enumerable?: boolean;\n  writable?: boolean;\n  value?: T;\n  get?(): T;\n  set?(value: T): void;\n}\n\n/** Annotates an element as a program global. */\ndeclare function global(\n  target: any,\n  propertyKey: string,\n  descriptor: TypedPropertyDescriptor<any>\n): TypedPropertyDescriptor<any> | void;\n\n/** Annotates a method as a binary operator overload for the specified `token`. */\ndeclare function operator(token:\n  "[]" | "[]=" | "{}" | "{}=" | "==" | "!=" | ">" | "<" | "<=" | ">=" |\n  ">>" | ">>>" | "<<" |  "&"  | "|"  | "^"  | "+" | "-" | "*"  | "**" | "/"  | "%"\n): (\n  target: any,\n  propertyKey: string,\n  descriptor: TypedPropertyDescriptor<any>\n) => TypedPropertyDescriptor<any> | void;\n\ndeclare namespace operator {\n  /** Annotates a method as a binary operator overload for the specified `token`. */\n  export function binary(token:\n    "[]" | "[]=" | "{}" | "{}=" | "==" | "!=" | ">" | "<" | "<=" | ">=" |\n    ">>" | ">>>" | "<<" |  "&"  | "|"  | "^"  | "+" | "-" | "*"  | "**" | "/"  | "%"\n  ): (\n    target: any,\n    propertyKey: string,\n    descriptor: TypedPropertyDescriptor<any>\n  ) => TypedPropertyDescriptor<any> | void;\n  /** Annotates a method as an unary prefix operator overload for the specified `token`. */\n  export function prefix(token: "!" | "~" | "+" | "-" | "++" | "--"): (\n    target: any,\n    propertyKey: string,\n    descriptor: TypedPropertyDescriptor<any>\n  ) => TypedPropertyDescriptor<any> | void;\n  /** Annotates a method as an unary postfix operator overload for the specified `token`. */\n  export function postfix(token: "++" | "--"): (\n    target: any,\n    propertyKey: string,\n    descriptor: TypedPropertyDescriptor<any>\n  ) => TypedPropertyDescriptor<any> | void;\n}\n\n/** Annotates a class as being unmanaged with limited capabilities. */\ndeclare function unmanaged(constructor: Function): void;\n\n/** Annotates a class as being sealed / non-derivable. */\ndeclare function sealed(constructor: Function): void;\n\n/** Annotates a method, function or constant global as always inlined. */\ndeclare function inline(\n  target: any,\n  propertyKey: string,\n  descriptor: TypedPropertyDescriptor<any>\n): TypedPropertyDescriptor<any> | void;\n\n/** Annotates an explicit external name of a function or global. */\ndeclare function external(namespace: string, name: string): (\n  target: any,\n  propertyKey: string,\n  descriptor: TypedPropertyDescriptor<any>\n) => TypedPropertyDescriptor<any> | void;\n\n/** Annotates a global for lazy compilation. */\ndeclare function lazy(\n  target: any,\n  propertyKey: string,\n  descriptor: TypedPropertyDescriptor<any>\n): TypedPropertyDescriptor<any> | void;\n\n/** Annotates a function as the explicit start function. */\ndeclare function start(\n  target: any,\n  propertyKey: string,\n  descriptor: TypedPropertyDescriptor<any>\n): TypedPropertyDescriptor<any> | void;\n',portable:"/**\n * Environment definitions for compiling AssemblyScript to JavaScript using tsc.\n *\n * Note that semantic differences require additional explicit conversions for full compatibility.\n * For example, when casting an i32 to an u8, doing `<u8>(someI32 & 0xff)` will yield the same\n * result when compiling to WebAssembly or JS while `<u8>someI32` alone does nothing in JS.\n *\n * Note that i64's are not portable (JS numbers are IEEE754 doubles with a maximum safe integer\n * value of 2^53-1) and instead require a compatibility layer to work in JS as well, as for example\n * {@link glue/js/i64} respectively {@link glue/wasm/i64}.\n *\n * @module std/portable\n *//***/\n\n/// <reference no-default-lib=\"true\"/>\n\n// Types\n\ndeclare type bool = boolean;\ndeclare type i8 = number;\ndeclare type i16 = number;\ndeclare type i32 = number;\ndeclare type isize = number;\ndeclare type u8 = number;\ndeclare type u16 = number;\ndeclare type u32 = number;\ndeclare type usize = number;\ndeclare type f32 = number;\ndeclare type f64 = number;\n\n// Compiler hints\n\n/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */\ndeclare const ASC_TARGET: i32;\n/** Provided noAssert option. */\ndeclare const ASC_NO_ASSERT: bool;\n/** Provided memoryBase option. */\ndeclare const ASC_MEMORY_BASE: i32;\n/** Provided optimizeLevel option. */\ndeclare const ASC_OPTIMIZE_LEVEL: i32;\n/** Provided shrinkLevel option. */\ndeclare const ASC_SHRINK_LEVEL: i32;\n/** Whether the mutable global feature is enabled. */\ndeclare const ASC_FEATURE_MUTABLE_GLOBAL: bool;\n/** Whether the sign extension feature is enabled. */\ndeclare const ASC_FEATURE_SIGN_EXTENSION: bool;\n\n// Builtins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32>(value: T): T;\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */\ndeclare function ctz<T = i32>(value: T): T;\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */\ndeclare function popcnt<T = i32>(value: T): T;\n/** Performs the sign-agnostic rotate left operation on a 32-bit integer. */\ndeclare function rotl<T = i32>(value: T, shift: T): T;\n/** Performs the sign-agnostic rotate right operation on a 32-bit integer. */\ndeclare function rotr<T = i32>(value: T, shift: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\ndeclare function copysign<T = f32 | f64>(x: T, y: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\ndeclare function nearest<T = f32 | f64>(value: T): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Loads a value of the specified type from memory. Type must be `u8`. */\ndeclare function load<T = u8>(ptr: usize, constantOffset?: usize): T;\n/** Stores a value of the specified type to memory. Type must be `u8`. */\ndeclare function store<T = u8>(ptr: usize, value: T, constantOffset?: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. */\ndeclare function unreachable(): any; // sic\n\n/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */\ndeclare const NaN: f32 | f64;\n/** Positive infinity as a 32-bit or 64-bit float depending on context. */\ndeclare const Infinity: f32 | f64;\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */\ndeclare function unchecked<T>(value: T): T;\n/** Tests if a 32-bit or 64-bit float is `NaN`. */\ndeclare function isNaN<T = f32 | f64>(value: T): bool;\n/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */\ndeclare function isFinite<T = f32 | f64>(value: T): bool;\n/** Tests if the specified value is a valid integer. Can't distinguish an integer from an integral float. */\ndeclare function isInteger(value: any): value is number;\n/** Tests if the specified value is a valid float. Can't distinguish a float from an integer. */\ndeclare function isFloat(value: any): value is number;\n/** Tests if the specified value is of a nullable reference type. */\ndeclare function isNullable(value: any): bool;\n/** Tests if the specified value is of a reference type. */\ndeclare function isReference(value: any): value is object | string;\n/** Tests if the specified value is of a function type */\ndeclare function isFunction(value: any): value is Function;\n/** Tests if the specified value can be used as a string. */\ndeclare function isString(value: any): value is string | String;\n/** Tests if the specified value can be used as an array. */\ndeclare function isArray(value: any): value is Array<any>;\n/** Tests if the specified type *or* expression can be used as an array like object. */\ndeclare function isArrayLike(value: any): value is ArrayLike<any>;\n/** Tests if the specified expression resolves to a defined element. */\ndeclare function isDefined(expression: any): bool;\n/** Tests if the specified expression evaluates to a constant value. */\ndeclare function isConstant(expression: any): bool;\n/** Traps if the specified value is not true-ish, otherwise returns the value. */\ndeclare function assert<T>(isTrueish: T | null, message?: string): T;\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses an integer string to a 32-bit integer. */\ndeclare function parseI32(str: string, radix?: i32): i32;\n/** Parses a floating point string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n/** Returns the 64-bit floating-point remainder of `x/y`. */\ndeclare function fmod(x: f64, y: f64): f64;\n/** Returns the 32-bit floating-point remainder of `x/y`. */\ndeclare function fmodf(x: f32, y: f32): f32;\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace i8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i8;\n  /** Largest representable value. */\n  export const MAX_VALUE: i8;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): i8;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace i16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i16;\n  /** Largest representable value. */\n  export const MAX_VALUE: i16;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): i16;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i32;\ndeclare namespace i32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i32;\n  /** Largest representable value. */\n  export const MAX_VALUE: i32;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): i32;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): i32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare function isize(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): isize;\ndeclare namespace isize {\n  /** Smallest representable value. */\n  export const MIN_VALUE: isize;\n  /** Largest representable value. */\n  export const MAX_VALUE: isize;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): isize;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): isize;\n}\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace u8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u8;\n  /** Largest representable value. */\n  export const MAX_VALUE: u8;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): u8;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace u16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u16;\n  /** Largest representable value. */\n  export const MAX_VALUE: u16;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): u16;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i32;\ndeclare namespace u32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u32;\n  /** Largest representable value. */\n  export const MAX_VALUE: u32;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): u32;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): u32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare function usize(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): isize;\ndeclare namespace usize {\n  /** Smallest representable value. */\n  export const MIN_VALUE: usize;\n  /** Largest representable value. */\n  export const MAX_VALUE: usize;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): usize;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): usize;\n}\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): bool;\ndeclare namespace bool {\n  /** Smallest representable value. */\n  export const MIN_VALUE: bool;\n  /** Largest representable value. */\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): f32;\ndeclare namespace f32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f32;\n  /** Largest representable value. */\n  export const MAX_VALUE: f32;\n  /** Smallest normalized positive value. */\n  export const MIN_POSITIVE_VALUE: f32;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */\n  export function isNaN(value: f32): bool;\n  /** Returns true if passed value is finite. */\n  export function isFinite(value: f32): bool;\n  /** Returns true if the value passed is a safe integer. */\n  export function isSafeInteger(value: f32): bool;\n  /** Returns true if the value passed is an integer, false otherwise. */\n  export function isInteger(value: f32): bool;\n  /** Converts a string to a floating-point number. */\n  export function parseFloat(string: string): f32;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): f32;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): f64;\ndeclare namespace f64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f64;\n  /** Largest representable value. */\n  export const MAX_VALUE: f64;\n  /** Smallest normalized positive value. */\n  export const MIN_POSITIVE_VALUE: f64;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */\n  export function isNaN(value: f32): bool;\n  /** Returns true if passed value is finite. */\n  export function isFinite(value: f32): bool;\n  /** Returns true if the value passed is a safe integer. */\n  export function isSafeInteger(value: f64): bool;\n  /** Returns true if the value passed is an integer, false otherwise. */\n  export function isInteger(value: f64): bool;\n  /** Converts a string to a floating-point number. */\n  export function parseFloat(string: string): f64;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): f64;\n}\n\n// Polyfills\n\n/** [Polyfill] Performs the sign-agnostic reverse bytes **/\ndeclare function bswap<T = i32 | u32 | isize | usize>(value: T): T;\n/** [Polyfill] Performs the sign-agnostic reverse bytes only for last 16-bit **/\ndeclare function bswap16<T = i16 | u16 | i32 | u32>(value: T): T;\n\n// Standard library\n\n/** Memory operations. */\ndeclare namespace memory {\n  /** Allocates a chunk of memory of the specified size and returns a pointer to it. */\n  function allocate(size: usize): usize;\n  /** Disposes a chunk of memory by its pointer. */\n  function free(ptr: usize): void;\n  /** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\n  function copy(dst: usize, src: usize, n: usize): void;\n  /** Fills size bytes from from the specified destination by same value in memory. */\n  function fill(dst: usize, value: u8, size: usize): void;\n  /** Resets the allocator to its initial state, if supported. */\n  function reset(): void;\n}\n\n/** Class representing a generic, fixed-length raw binary data buffer. */\ndeclare class ArrayBuffer {\n  /** The size, in bytes, of the array. */\n  readonly byteLength: i32;\n  /** Returns true if value is one of the ArrayBuffer views, such as typed array or a DataView **/\n  static isView<T>(value: T): bool;\n  /** Constructs a new array buffer of the given length in bytes. */\n  constructor(length: i32);\n  /** Returns a copy of this array buffer's bytes from begin, inclusive, up to end, exclusive. */\n  slice(begin?: i32, end?: i32): ArrayBuffer;\n  /** Returns a string representation of ArrayBuffer. */\n  toString(): string;\n}\n\n/** The `DataView` view provides a low-level interface for reading and writing multiple number types in a binary `ArrayBuffer`, without having to care about the platform's endianness. */\ndeclare class DataView {\n  /** The `buffer` accessor property represents the `ArrayBuffer` or `SharedArrayBuffer` referenced by the `DataView` at construction time. */\n  readonly buffer: ArrayBuffer;\n  /** The `byteLength` accessor property represents the length (in bytes) of this view from the start of its `ArrayBuffer` or `SharedArrayBuffer`. */\n  readonly byteLength: i32;\n  /** The `byteOffset` accessor property represents the offset (in bytes) of this view from the start of its `ArrayBuffer` or `SharedArrayBuffer`. */\n  readonly byteOffset: i32;\n  /** Constructs a new `DataView` with the given properties */\n  constructor(buffer: ArrayBuffer, byteOffset?: i32, byteLength?: i32);\n  /** The `getFloat32()` method gets a signed 32-bit float (float) at the specified byte offset from the start of the `DataView`. */\n  getFloat32(byteOffset: i32, littleEndian?: boolean): f32;\n  /** The `getFloat64()` method gets a signed 64-bit float (double) at the specified byte offset from the start of the `DataView`. */\n  getFloat64(byteOffset: i32, littleEndian?: boolean): f64;\n  /** The `getInt8()` method gets a signed 8-bit integer (byte) at the specified byte offset from the start of the `DataView`. */\n  getInt8(byteOffset: i32): i8;\n  /** The `getInt16()` method gets a signed 16-bit integer (short) at the specified byte offset from the start of the `DataView`. */\n  getInt16(byteOffset: i32, littleEndian?: boolean): i16;\n  /** The `getInt32()` method gets a signed 32-bit integer (long) at the specified byte offset from the start of the `DataView`. */\n  getInt32(byteOffset: i32, littleEndian?: boolean): i32;\n  /** The `getUint8()` method gets an unsigned 8-bit integer (unsigned byte) at the specified byte offset from the start of the `DataView`. */\n  getUint8(byteOffset: i32): u8;\n  /** The `getUint16()` method gets an unsigned 16-bit integer (unsigned short) at the specified byte offset from the start of the `DataView`. */\n  getUint16(byteOffset: i32, littleEndian?: boolean): u16;\n  /** The `getUint32()` method gets an unsigned 32-bit integer (unsigned long) at the specified byte offset from the start of the `DataView`. */\n  getUint32(byteOffset: i32, littleEndian?: boolean): u32;\n  /** The `setFloat32()` method stores a signed 32-bit float (float) value at the specified byte offset from the start of the `DataView`. */\n  setFloat32(byteOffset: i32, value: f32, littleEndian?: boolean): void;\n  /** The `setFloat64()` method stores a signed 64-bit float (double) value at the specified byte offset from the start of the `DataView`. */\n  setFloat64(byteOffset: i32, value: f64, littleEndian?: boolean): void;\n  /** The `setInt8()` method stores a signed 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`. */\n  setInt8(byteOffset: i32, value: i8): void;\n  /** The `setInt16()` method stores a signed 16-bit integer (short) value at the specified byte offset from the start of the `DataView`. */\n  setInt16(byteOffset: i32, value: i16, littleEndian?: boolean): void;\n  /** The `setInt32()` method stores a signed 32-bit integer (long) value at the specified byte offset from the start of the `DataView`. */\n  setInt32(byteOffset: i32, value: i32, littleEndian?: boolean): void;\n  /** The `setUint8()` method stores an unsigned 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`. */\n  setUint8(byteOffset: i32, value: u8): void;\n  /** The `setUint16()` method stores an unsigned 16-bit integer (unsigned short) value at the specified byte offset from the start of the `DataView`. */\n  setUint16(byteOffset: i32, value: u16, littleEndian?: boolean): void;\n  /** The `setUint32()` method stores an unsigned 32-bit integer (unsigned long) value at the specified byte offset from the start of the `DataView`. */\n  setUint32(byteOffset: i32, value: u32, littleEndian?: boolean): void;\n  /** Returns a string representation of DataView. */\n  toString(): string;\n}\n\ndeclare class Array<T> {\n\n  static isArray<U>(value: any): value is Array<any>;\n\n  [key: number]: T;\n  length: i32;\n  constructor(capacity?: i32);\n\n  fill(value: T, start?: i32, end?: i32): this;\n  every(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool;\n  findIndex(predicate: (element: T, index: i32, array?: Array<T>) => bool): i32;\n  includes(searchElement: T, fromIndex?: i32): bool;\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): i32;\n  concat(items: T[]): T[];\n  copyWithin(target: i32, start: i32, end?: i32): this;\n  pop(): T;\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void;\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U>;\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T>;\n  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\n  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\n  shift(): T;\n  some(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool;\n  unshift(element: T): i32;\n  slice(from?: i32, to?: i32): Array<T>;\n  splice(start: i32, deleteCount?: i32): Array<T>;\n  sort(comparator?: (a: T, b: T) => i32): this;\n  join(separator?: string): string;\n  reverse(): T[];\n  toString(): string;\n}\n\ndeclare class Uint8Array extends Array<u8> {}\ndeclare class Uint8ClampedArray extends Array<u8> {}\ndeclare class Uint16Array extends Array<u16> {}\ndeclare class Uint32Array extends Array<u32> {}\ndeclare class Int8Array extends Array<i8> {}\ndeclare class Int16Array extends Array<i16> {}\ndeclare class Int32Array extends Array<i32> {}\ndeclare class Float32Array extends Array<f32> {}\ndeclare class Float64Array extends Array<f64> {}\n\ninterface ArrayLike<T> {\n  length: i32;\n  [key: number]: T;\n}\n\n/** Interface for a typed view on an array buffer. */\ninterface ArrayBufferView<T> {\n  [key: number]: T;\n  /** The {@link ArrayBuffer} referenced by this view. */\n  readonly buffer: ArrayBuffer;\n  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteOffset: i32;\n  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteLength: i32;\n}\n\ndeclare class String {\n\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(code: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n\n  readonly length: i32;\n\n  private constructor();\n\n  charAt(index: i32): string;\n  charCodeAt(index: i32): i32;\n  concat(other: string): string;\n  indexOf(other: string, fromIndex?: i32): i32;\n  lastIndexOf(other: string, fromIndex?: i32): i32;\n  includes(other: string): bool;\n  startsWith(other: string): bool;\n  endsWith(other: string): bool;\n  substr(start: u32, length?: u32): string;\n  substring(from: i32, to?: i32): string;\n  trim(): string;\n  trimLeft(): string;\n  trimRight(): string;\n  trimStart(): string;\n  trimEnd(): string;\n  padStart(targetLength: i32, padString?: string): string;\n  padEnd(targetLength: i32, padString?: string): string;\n  replace(search: string, replacement: string): string;\n  repeat(count?: i32): string;\n  slice(beginIndex: i32, endIndex?: i32): string;\n  split(separator?: string, limit?: i32): string[];\n  toString(): string;\n}\n\ninterface Boolean {}\n\ndeclare class Number {\n  private constructor();\n  toString(radix?: i32): string;\n}\n\ninterface Object {}\n\ninterface Function {}\n\ninterface RegExp {}\n\ninterface IArguments {}\n\n/** Class for representing a runtime error. Base class of all errors. */\ndeclare class Error {\n\n  /** Error name. */\n  name: string;\n\n  /** Message provided on construction. */\n  message: string;\n\n  /** Stack trace. */\n  stack?: string;\n\n  /** Constructs a new error, optionally with a message. */\n  constructor(message?: string);\n\n  /** Method returns a string representing the specified Error class. */\n  toString(): string;\n}\n\n/** Class for indicating an error when a value is not in the set or range of allowed values. */\ndeclare class RangeError extends Error { }\n\n/** Class for indicating an error when a value is not of the expected type. */\ndeclare class TypeError  extends Error { }\n\n/** Class for indicating an error when trying to interpret syntactically invalid code. */\ndeclare class SyntaxError extends Error { }\n\ndeclare class Set<T> {\n  constructor(entries?: T[]);\n  readonly size: i32;\n  has(value: T): bool;\n  add(value: T): void;\n  delete(value: T): bool;\n  clear(): void;\n  toString(): string;\n  [Symbol.iterator](): Iterator<T>;\n}\n\ndeclare class Map<K,V> {\n  constructor(entries?: [K, V][]);\n  readonly size: i32;\n  set(key: K, value: V): void;\n  has(key: K): bool;\n  get(key: K): V | null;\n  clear(): void;\n  entries(): Iterable<[K, V]>;\n  keys(): Iterable<K>;\n  values(): Iterable<V>;\n  delete(key: K): bool;\n  toString(): string;\n  [Symbol.iterator](): Iterator<[K,V]>;\n}\n\ninterface SymbolConstructor {\n  readonly hasInstance: symbol;\n  readonly isConcatSpreadable: symbol;\n  readonly isRegExp: symbol;\n  readonly iterator: symbol;\n  readonly match: symbol;\n  readonly replace: symbol;\n  readonly search: symbol;\n  readonly species: symbol;\n  readonly split: symbol;\n  readonly toPrimitive: symbol;\n  readonly toStringTag: symbol;\n  readonly unscopables: symbol;\n  (description?: string | null): symbol;\n  for(key: string): symbol;\n  keyFor(sym: symbol): string | null;\n}\ndeclare const Symbol: SymbolConstructor;\n\ninterface Iterable<T> {\n  [Symbol.iterator](): Iterator<T>;\n}\n\ninterface Iterator<T> {}\n\ninterface IMath {\n  readonly E: f64;\n  readonly LN2: f64;\n  readonly LN10: f64;\n  readonly LOG2E: f64;\n  readonly LOG10E: f64;\n  readonly PI: f64;\n  readonly SQRT1_2: f64;\n  readonly SQRT2: f64;\n\n  sincos_sin: f64;\n  sincos_cos: f64;\n\n  abs(x: f64): f64;\n  acos(x: f64): f64;\n  acosh(x: f64): f64;\n  asin(x: f64): f64;\n  asinh(x: f64): f64;\n  atan(x: f64): f64;\n  atan2(y: f64, x: f64): f64;\n  atanh(x: f64): f64;\n  cbrt(x: f64): f64;\n  ceil(x: f64): f64;\n  clz32(x: f64): i32;\n  cos(x: f64): f64;\n  cosh(x: f64): f64;\n  exp(x: f64): f64;\n  expm1(x: f64): f64;\n  floor(x: f64): f64;\n  fround(x: f64): f32;\n  hypot(value1: f64, value2: f64): f64; // TODO: see std/math\n  imul(a: f64, b: f64): i32;\n  log(x: f64): f64;\n  log10(x: f64): f64;\n  log1p(x: f64): f64;\n  log2(x: f64): f64;\n  max(value1: f64, value2: f64): f64; // TODO: see std/math\n  min(value1: f64, value2: f64): f64; // TODO: see std/math\n  pow(base: f64, exponent: f64): f64;\n  random(): f64;\n  round(x: f64): f64;\n  sign(x: f64): f64;\n  signbit(x: f64): bool;\n  sin(x: f64): f64;\n  sincos(x: f64): f64;\n  sinh(x: f64): f64;\n  sqrt(x: f64): f64;\n  tan(x: f64): f64;\n  tanh(x: f64): f64;\n  trunc(x: f64): f64;\n}\n\ndeclare const Math: IMath;\ndeclare const Mathf: IMath;\ndeclare const JSMath: IMath;\n\ndeclare class Date {\n  /** Returns the UTC timestamp in milliseconds of the specified date. */\n  static UTC(\n    year: i32,\n    month: i32,\n    day: i32,\n    hour: i32,\n    minute: i32,\n    second: i32,\n    millisecond: i32\n  ): number;\n  /** Returns the current UTC timestamp in milliseconds. */\n  static now(): number;\n  /** Constructs a new date object from an UTC timestamp in milliseconds. */\n  constructor(value: number);\n  /** Returns the UTC timestamp of this date in milliseconds. */\n  getTime(): number;\n  /** Sets the UTC timestamp of this date in milliseconds. */\n  setTime(value: number): number;\n}\n\ndeclare namespace console {\n  /** @deprecated */\n  function log(message: string): void;\n}\n"}):(()=>{const e=path.join(".","..","std");return{assembly:fs.readFileSync(path.join(e,"assembly","index.d.ts"),"utf8"),portable:fs.readFileSync(path.join(e,"portable","index.d.ts"),"utf8")}})(),exports.compileString=((e,n)=>{"string"==typeof e&&(e={"input.ts":e});const t=Object.create({stdout:createMemoryStream(),stderr:createMemoryStream()});var i=["--binaryFile","binary","--textFile","text"];return Object.keys(n||{}).forEach(e=>{var t=n[e];Array.isArray(t)?t.forEach(n=>i.push("--"+e,String(n))):i.push("--"+e,String(t))}),exports.main(i.concat(Object.keys(e)),{stdout:t.stdout,stderr:t.stderr,readFile:n=>e.hasOwnProperty(n)?e[n]:null,writeFile:(e,n)=>t[e]=n,listFiles:()=>[]}),t}),exports.main=function(e,n,t){"function"==typeof n?(t=n,n={}):n||(n={});const i=n.stdout||process.stdout,r=n.stderr||process.stderr,a=n.readFile||F,o=n.writeFile||z,s=n.listFiles||I,l=n.stats||createStats();if(!i)throw Error("'options.stdout' must be specified");if(!r)throw Error("'options.stderr' must be specified");const f=optionsUtil.parse(e,exports.options),u=f.options;if(e=f.arguments,u.noColors?colorsUtil.stdout.supported=colorsUtil.stderr.supported=!1:(colorsUtil.stdout=colorsUtil.from(i),colorsUtil.stderr=colorsUtil.from(r)),f.unknown.length&&f.unknown.forEach(e=>{r.write(colorsUtil.stderr.yellow("WARN: ")+"Unknown option '"+e+"'"+EOL)}),f.trailing.length&&r.write(colorsUtil.stderr.yellow("WARN: ")+"Unsupported trailing arguments: "+f.trailing.join(" ")+EOL),t||(t=function(e){var n=0;return e&&(r.write(colorsUtil.stderr.red("ERROR: ")+e.stack.replace(/^ERROR: /i,"")+EOL),n=1),n}),u.version)return i.write("Version "+exports.version+(isDev?"-dev":"")+EOL),t(null);if(u.help||!e.length){var c=u.help?i:r,p=u.help?colorsUtil.stdout:colorsUtil.stderr;return c.write([p.white("SYNTAX"),"  "+p.cyan("asc")+" [entryFile ...] [options]","",p.white("EXAMPLES"),"  "+p.cyan("asc")+" hello.ts","  "+p.cyan("asc")+" hello.ts -b hello.wasm -t hello.wat","  "+p.cyan("asc")+" hello1.ts hello2.ts -b -O > hello.wasm","",p.white("OPTIONS")].concat(optionsUtil.help(exports.options,24,EOL)).join(EOL)+EOL),t(null)}if(!fs.readFileSync){if(a===F)throw Error("'options.readFile' must be specified");if(o===z)throw Error("'options.writeFile' must be specified");if(s===I)throw Error("'options.listFiles' must be specified")}const d=u.baseDir?path.resolve(u.baseDir):".",h=[];u.transform&&u.transform.forEach(e=>h.push(__webpack_require__(12)(path.isAbsolute(e=e.trim())?e:path.join(process.cwd(),e))));var x=null;u.noLib?(l.parseCount++,l.parseTime+=measure(()=>{x=assemblyscript.parseFile(exports.libraryFiles.builtins,exports.libraryPrefix+"builtins.ts",!1,x)})):Object.keys(exports.libraryFiles).forEach(e=>{e.indexOf("/")>=0||(l.parseCount++,l.parseTime+=measure(()=>{x=assemblyscript.parseFile(exports.libraryFiles[e],exports.libraryPrefix+e+".ts",!1,x)}))});const b=[];if(u.lib){let e=u.lib;"string"==typeof e&&(e=e.split(",")),Array.prototype.push.apply(b,e.map(e=>e.trim()));for(let e=0,n=b.length;e<n;++e){let n,i=b[e];i.endsWith(".ts")?(n=[path.basename(i)],i=path.dirname(i)):n=s(i);for(let e=0,r=n.length;e<r;++e){let r=n[e],o=a(r,i);if(null===o)return t(Error("Library file '"+r+"' not found."));l.parseCount++,l.parseTime+=measure(()=>{x=assemblyscript.parseFile(o,exports.libraryPrefix+r,!1,x)})}}}function g(){for(var e,n;null!=(e=x.nextFile());){if(e.startsWith(exports.libraryPrefix)){const t=e.substring(exports.libraryPrefix.length),i=e.substring(exports.libraryPrefix.length)+"/index";if(exports.libraryFiles.hasOwnProperty(t))n=exports.libraryFiles[t],e=exports.libraryPrefix+t+".ts";else if(exports.libraryFiles.hasOwnProperty(i))n=exports.libraryFiles[i],e=exports.libraryPrefix+i+".ts";else for(let r=0,o=b.length;r<o;++r){if(null!==(n=a(t+".ts",b[r]))){e=exports.libraryPrefix+t+".ts";break}if(null!==(n=a(i+".ts",b[r]))){e=exports.libraryPrefix+i+".ts";break}}}else{const t=e,i=e+"/index";if(null!==(n=a(t+".ts",d)))e=t+".ts";else if(null!==(n=a(i+".ts",d)))e=i+".ts";else if(!t.startsWith("."))if(exports.libraryFiles.hasOwnProperty(t))n=exports.libraryFiles[t],e=exports.libraryPrefix+t+".ts";else if(exports.libraryFiles.hasOwnProperty(i))n=exports.libraryFiles[i],e=exports.libraryPrefix+i+".ts";else for(let r=0,o=b.length;r<o;++r){b[r];if(null!==(n=a(t+".ts",b[r]))){e=exports.libraryPrefix+t+".ts";break}if(null!==(n=a(i+".ts",b[r]))){e=exports.libraryPrefix+i+".ts";break}}}if(null==n)return t(Error("Import file '"+e+".ts' not found."));l.parseCount++,l.parseTime+=measure(()=>{assemblyscript.parseFile(n,e,!1,x)})}if(checkDiagnostics(x,r))return t(Error("Parse error"))}for(let n=0,i=e.length;n<i;++n){const i=e[n];let r=String(i).replace(/\\/g,"/").replace(/(\.ts|\/)$/,""),o=a(r+".ts",d);if(null===o){if(null===(o=a(r+"/index.ts",d)))return t(Error("Entry file '"+r+".ts' not found."));r+="/index.ts"}else r+=".ts";l.parseCount++,l.parseTime+=measure(()=>{x=assemblyscript.parseFile(o,r,!0,x)});let s=g();if(s)return s}!function(e,...n){h.forEach(t=>{"function"==typeof t[e]&&t[e](...n)})}("afterParse",x);{let e=g();if(e)return e}const v=assemblyscript.finishParsing(x);var m=0,y=0;u.optimize&&(m=exports.defaultOptimizeLevel,y=exports.defaultShrinkLevel),"number"==typeof u.optimizeLevel&&(m=u.optimizeLevel),"number"==typeof u.shrinkLevel&&(y=u.shrinkLevel),m=Math.min(Math.max(m,0),3),y=Math.min(Math.max(y,0),2);const _=assemblyscript.createOptions();if(assemblyscript.setTarget(_,0),assemblyscript.setNoAssert(_,u.noAssert),assemblyscript.setImportMemory(_,u.importMemory),assemblyscript.setSharedMemory(_,u.sharedMemory),assemblyscript.setImportTable(_,u.importTable),assemblyscript.setMemoryBase(_,u.memoryBase>>>0),assemblyscript.setSourceMap(_,null!=u.sourceMap),assemblyscript.setOptimizeLevelHints(_,m,y),u.noLib||(assemblyscript.setGlobalAlias(_,"Math","NativeMath"),assemblyscript.setGlobalAlias(_,"Mathf","NativeMathf"),assemblyscript.setGlobalAlias(_,"abort","~lib/env/abort"),assemblyscript.setGlobalAlias(_,"trace","~lib/env/trace")),u.use){let e=u.use;for(let n=0,i=e.length;n<i;++n){let i=e[n],r=i.indexOf("=");if(r<0)return t(Error("Global alias '"+i+"' is invalid."));let a=i.substring(0,r).trim(),o=i.substring(r+1).trim();if(!a.length)return t(Error("Global alias '"+i+"' is invalid."));assemblyscript.setGlobalAlias(_,a,o)}}var E,T=u.enable;if(null!=T){"string"==typeof T&&(T=T.split(","));for(let e=0,n=T.length;e<n;++e){let n=T[e].trim(),i=assemblyscript["FEATURE_"+n.replace(/\-/g,"_").toUpperCase()];if(!i)return t(Error("Feature '"+n+"' is unknown."));assemblyscript.enableFeature(_,i)}}if(l.compileCount++,(()=>{try{l.compileTime+=measure(()=>{E=assemblyscript.compileProgram(v,_)})}catch(e){return t(e)}})(),checkDiagnostics(x,r))return E&&E.dispose(),t(Error("Compile error"));if(u.validate&&(l.validateCount++,l.validateTime+=measure(()=>{if(!E.validate())return E.dispose(),t(Error("Validate error"))})),"clamp"===u.trapMode)l.optimizeCount++,l.optimizeTime+=measure(()=>{E.runPasses(["trap-mode-clamp"])});else if("js"===u.trapMode)l.optimizeCount++,l.optimizeTime+=measure(()=>{E.runPasses(["trap-mode-js"])});else if("allow"!==u.trapMode)return E.dispose(),t(Error("Unsupported trap mode"));(m>=3||y>=2)&&(m=4),E.setOptimizeLevel(m),E.setShrinkLevel(y),E.setDebugInfo(u.debug);var A=[];if(u.runPasses&&("string"==typeof u.runPasses&&(u.runPasses=u.runPasses.split(",")),u.runPasses.length&&u.runPasses.forEach(e=>{A.indexOf(e)<0&&A.push(e)})),(m>0||y>0)&&(l.optimizeCount++,l.optimizeTime+=measure(()=>{E.optimize()})),A.length&&(l.optimizeCount++,l.optimizeTime+=measure(()=>{E.runPasses(A.map(e=>e.trim()))})),!u.noEmit){let e=!1,n=!1;if(null!=u.outFile&&(/\.was?t$/.test(u.outFile)&&null==u.textFile?u.textFile=u.outFile:/\.js$/.test(u.outFile)&&null==u.asmjsFile?u.asmjsFile=u.outFile:null==u.binaryFile&&(u.binaryFile=u.outFile)),null!=u.binaryFile){let i,s=null!=u.sourceMap?u.sourceMap.length?u.sourceMap:path.basename(u.binaryFile)+".map":null;if(l.emitCount++,l.emitTime+=measure(()=>{i=E.toBinary(s)}),u.binaryFile.length?o(u.binaryFile,i.output,d):(S(i.output),e=!0),n=!0,null!=i.sourceMap)if(u.binaryFile.length){let e=JSON.parse(i.sourceMap);e.sourceRoot=exports.sourceMapRoot,e.sources.forEach((n,i)=>{let r=null;if(n.startsWith(exports.libraryPrefix)){let e=n.substring(exports.libraryPrefix.length).replace(/\.ts$/,"");if(exports.libraryFiles.hasOwnProperty(e))r=exports.libraryFiles[e];else for(let e=0,t=b.length;e<t&&null===(r=a(n.substring(exports.libraryPrefix.length),b[e]));++e);}else r=a(n,d);if(null===r)return t(Error("Source file '"+n+"' not found."));e.sourceContents||(e.sourceContents=[]),e.sourceContents[i]=r}),o(path.join(path.dirname(u.binaryFile),path.basename(s)).replace(/^\.\//,""),JSON.stringify(e),d)}else r.write("Skipped source map (stdout already occupied)"+EOL)}if(null!=u.asmjsFile){let t;u.asmjsFile.length?(l.emitCount++,l.emitTime+=measure(()=>{t=E.toAsmjs()}),o(u.asmjsFile,t,d)):e||(l.emitCount++,l.emitTime+=measure(()=>{t=E.toAsmjs()}),S(t),e=!0),n=!0}if(null!=u.idlFile){let t;u.idlFile.length?(l.emitCount++,l.emitTime+=measure(()=>{t=assemblyscript.buildIDL(v)}),o(u.idlFile,t,d)):e||(l.emitCount++,l.emitTime+=measure(()=>{t=assemblyscript.buildIDL(v)}),S(t),e=!0),n=!0}if(null!=u.tsdFile){let t;u.tsdFile.length?(l.emitCount++,l.emitTime+=measure(()=>{t=assemblyscript.buildTSD(v)}),o(u.tsdFile,t,d)):e||(l.emitCount++,l.emitTime+=measure(()=>{t=assemblyscript.buildTSD(v)}),S(t),e=!0),n=!0}if(null!=u.textFile||!n){let n;u.textFile&&u.textFile.length?(l.emitCount++,l.emitTime+=measure(()=>{n=E.toText()}),o(u.textFile,n,d)):e||(l.emitCount++,l.emitTime+=measure(()=>{n=E.toText()}),S(n))}}return E.dispose(),u.measure&&printStats(l,r),t(null);function F(e,n){try{let t;return l.readCount++,l.readTime+=measure(()=>{t=fs.readFileSync(path.join(n,e),{encoding:"utf8"})}),t}catch(e){return null}}function z(e,n,t){try{return l.writeCount++,l.writeTime+=measure(()=>{mkdirp(path.join(t,path.dirname(e))),"string"==typeof n?fs.writeFileSync(path.join(t,e),n,{encoding:"utf8"}):fs.writeFileSync(path.join(t,e),n)}),!0}catch(e){return!1}}function I(e,n){var t;try{return l.readTime+=measure(()=>{t=fs.readdirSync(path.join(n,e)).filter(e=>/^(?!.*\.d\.ts$).*\.ts$/.test(e))}),t}catch(e){return[]}}function S(e){S.used||(l.writeCount++,S.used=!0),l.writeTime+=measure(()=>{"string"==typeof e?i.write(e,{encoding:"utf8"}):i.write(e)})}},exports.checkDiagnostics=checkDiagnostics,exports.createStats=createStats,process.hrtime||(process.hrtime=__webpack_require__(13)),exports.measure=measure,exports.formatTime=formatTime,exports.printStats=printStats;var allocBuffer=void 0!==global&&global.Buffer?global.Buffer.allocUnsafe||function(e){return new global.Buffer(e)}:function(e){return new Uint8Array(e)};function createMemoryStream(e){var n=[];return n.write=function(n){if(e&&e(n),"string"==typeof n){let e=allocBuffer(utf8.length(n));utf8.write(n,e,0),n=e}this.push(n)},n.reset=function(){n.length=0},n.toBuffer=function(){for(var e=0,n=0,t=this.length;n<t;)e+=this[n++].length;var i=allocBuffer(e);for(e=n=0;n<t;)i.set(this[n],e),e+=this[n].length,++n;return i},n.toString=function(){var e=this.toBuffer();return utf8.read(e,0,e.length)},n}exports.createMemoryStream=createMemoryStream,exports.tscOptions={alwaysStrict:!0,noImplicitAny:!0,noImplicitReturns:!0,noImplicitThis:!0,noEmitOnError:!0,strictNullChecks:!0,experimentalDecorators:!0,target:"esnext",module:"commonjs",noLib:!0,types:[],allowJs:!1}}).call(this,__webpack_require__(0),__webpack_require__(2))},function(e,n,t){"use strict";var i=n;i.length=function(e){for(var n=0,t=0,i=0;i<e.length;++i)(t=e.charCodeAt(i))<128?n+=1:t<2048?n+=2:55296==(64512&t)&&56320==(64512&e.charCodeAt(i+1))?(++i,n+=4):n+=3;return n},i.read=function(e,n,t){if(t-n<1)return"";for(var i,r=null,a=[],o=0;n<t;)(i=e[n++])<128?a[o++]=i:i>191&&i<224?a[o++]=(31&i)<<6|63&e[n++]:i>239&&i<365?(i=((7&i)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,a[o++]=55296+(i>>10),a[o++]=56320+(1023&i)):a[o++]=(15&i)<<12|(63&e[n++])<<6|63&e[n++],o>8191&&((r||(r=[])).push(String.fromCharCode.apply(String,a)),o=0);return r?(o&&r.push(String.fromCharCode.apply(String,a.slice(0,o))),r.join("")):String.fromCharCode.apply(String,a.slice(0,o))},i.write=function(e,n,t){for(var i,r,a=t,o=0;o<e.length;++o)(i=e.charCodeAt(o))<128?n[t++]=i:i<2048?(n[t++]=i>>6|192,n[t++]=63&i|128):55296==(64512&i)&&56320==(64512&(r=e.charCodeAt(o+1)))?(i=65536+((1023&i)<<10)+(1023&r),++o,n[t++]=i>>18|240,n[t++]=i>>12&63|128,n[t++]=i>>6&63|128,n[t++]=63&i|128):(n[t++]=i>>12|224,n[t++]=i>>6&63|128,n[t++]=63&i|128);return t-a}},function(e,n,t){(function(e){var t=void 0!==e&&e||{},i=t.env&&"CI"in t.env;function r(e,t){var r=t||{};return r.supported=e&&!!e.isTTY||i,r.gray=(e=>r.supported?n.GRAY+e+n.RESET:e),r.red=(e=>r.supported?n.RED+e+n.RESET:e),r.green=(e=>r.supported?n.GREEN+e+n.RESET:e),r.yellow=(e=>r.supported?n.YELLOW+e+n.RESET:e),r.blue=(e=>r.supported?n.BLUE+e+n.RESET:e),r.magenta=(e=>r.supported?n.MAGENTA+e+n.RESET:e),r.cyan=(e=>r.supported?n.CYAN+e+n.RESET:e),r.white=(e=>r.supported?n.WHITE+e+n.RESET:e),r}n.stdout=r(t.stdout,n),n.stderr=r(t.stderr),n.from=r,n.GRAY="[90m",n.RED="[91m",n.GREEN="[92m",n.YELLOW="[93m",n.BLUE="[94m",n.MAGENTA="[95m",n.CYAN="[96m",n.WHITE="[97m",n.RESET="[0m"}).call(this,t(0))},function(e,n){n.parse=function(e,n){var t={},i=[],arguments=[],r=[],a={};Object.keys(n).forEach(e=>{if(!e.startsWith(" ")){var i=n[e];null!=i.alias&&("string"==typeof i.alias?a[i.alias]=e:Array.isArray(i.alias)&&i.alias.forEach(n=>a[n]=e)),null!=i.default&&(t[e]=i.default)}});for(var o=0,s=(e=e.slice()).length;o<s;++o){let r=e[o];if("--"==r){++o;break}let s,l,f=/^(?:(\-\w)(?:=(.*))?|(\-\-\w{2,})(?:=(.*))?)$/.exec(r);if(f)n[r]?s=n[l=r]:null!=f[1]?(s=n[l=a[f[1].substring(1)]])&&null!=f[2]&&(e[o--]=f[2]):null!=f[3]&&(s=n[l=f[3].substring(2)])&&null!=f[4]&&(e[o--]=f[4]);else{if(45!=r.charCodeAt(0)){arguments.push(r);continue}s=n[l=r]}if(s){if(null==s.type||"b"===s.type)t[l]=!0;else if(o+1<e.length&&45!=e[o+1].charCodeAt(0))switch(s.type){case"i":t[l]=parseInt(e[++o],10);break;case"I":t[l]=(t[l]||[]).concat(parseInt(e[++o],10));break;case"f":t[l]=parseFloat(e[++o]);break;case"F":t[l]=(t[l]||[]).concat(parseFloat(e[++o]));break;case"s":t[l]=String(e[++o]);break;case"S":t[l]=(t[l]||[]).concat(e[++o].split(","));break;default:i.push(r),--o}else switch(s.type){case"i":case"f":t[l]=s.default||0;break;case"s":t[l]=s.default||"";break;case"I":case"F":case"S":t[l]=t.default||[];break;default:i.push(r)}s.value&&Object.keys(s.value).forEach(e=>t[e]=s.value[e])}else i.push(r)}for(;o<s;)r.push(e[o++]);return{options:t,unknown:i,arguments:arguments,trailing:r}},n.help=function(e,n){n||(n={});var t=n.indent||2,i=n.padding||24,r=n.eol||"\n",a=[];return Object.keys(e).forEach(n=>{var o=e[n];if(null!=o.description){for(var s="";s.length<t;)s+=" ";for(s+="--"+n,o.alias&&(s+=", -"+o.alias);s.length<i;)s+=" ";Array.isArray(o.description)?a.push(s+o.description[0]+o.description.slice(1).map(e=>{for(let n=0;n<i;++n)e=" "+e;return r+e}).join("")):a.push(s+o.description)}}),a.join(r)}},function(e,n,t){(function(n){var i=t(1),r=t(3),a=parseInt("0777",8);e.exports=function e(t,o,s){o&&"object"==typeof o||(o={mode:o});var l=o.mode;void 0===l&&(l=a&~n.umask()),s||(s=null),t=i.resolve(t);try{r.mkdirSync(t,l),s=s||t}catch(n){switch(n.code){case"ENOENT":s=e(i.dirname(t),o,s),e(t,o,s);break;default:var f;try{f=r.statSync(t)}catch(e){throw n}if(!f.isDirectory())throw n}}return s}}).call(this,t(0))},function(e,n){if(void 0===__WEBPACK_EXTERNAL_MODULE__10__){var t=new Error("Cannot find module 'assemblyscript'");throw t.code="MODULE_NOT_FOUND",t}e.exports=__WEBPACK_EXTERNAL_MODULE__10__},function(e){e.exports={version:{description:"Prints just the compiler's version and exits.",type:"b",alias:"v"},help:{description:"Prints this message and exits.",type:"b",alias:"h"},optimize:{description:["Optimizes the module. Also has the usual shorthands:",""," -O     Uses defaults. Equivalent to -O2s"," -O0    Equivalent to --optimizeLevel 0"," -O1    Equivalent to --optimizeLevel 1"," -O2    Equivalent to --optimizeLevel 2"," -O3    Equivalent to --optimizeLevel 3"," -Oz    Equivalent to -O but with --shrinkLevel 2"," -O3s   Equivalent to -O3 with --shrinkLevel 1 etc.",""],type:"b",alias:"O"},optimizeLevel:{description:"How much to focus on optimizing code. [0-3]",type:"i"},shrinkLevel:{description:"How much to focus on shrinking code size. [0-2, s=1, z=2]",type:"i"},validate:{description:"Validates the module using Binaryen. Exits if invalid.",type:"b",alias:"c",default:!1},baseDir:{description:"Specifies the base directory of input and output files.",type:"s",default:"."},outFile:{description:"Specifies the output file. File extension indicates format.",type:"s",alias:"o"},binaryFile:{description:"Specifies the binary output file (.wasm).",type:"s",alias:"b"},textFile:{description:"Specifies the text output file (.wat).",type:"s",alias:"t"},asmjsFile:{description:"Specifies the asm.js output file (.js).",type:"s",alias:"a"},idlFile:{description:"Specifies the WebIDL output file (.webidl).",type:"s",alias:"i"},tsdFile:{description:"Specifies the TypeScript definition output file (.d.ts).",type:"s",alias:"d"},sourceMap:{description:["Enables source map generation. Optionally takes the URL","used to reference the source map from the binary file."],type:"s"},debug:{description:"Enables debug information in emitted binaries.",type:"b",default:!1},noAssert:{description:"Replaces assertions with just their value without trapping.",type:"b",default:!1},noEmit:{description:"Performs compilation as usual but does not emit code.",type:"b",default:!1},importMemory:{description:"Imports the memory instance provided by the embedder.",type:"b",default:!1},sharedMemory:{description:"Declare memory as shared by settings the max shared memory.",type:"i",default:0},memoryBase:{description:"Sets the start offset of compiler-generated static memory.",type:"i",default:0},importTable:{description:"Imports the function table instance provided by the embedder.",type:"b",default:!1},noLib:{description:"Does not include the shipped standard library.",type:"b",default:!1},lib:{description:["Adds one or multiple paths to custom library components and","uses exports of all top-level files at this path as globals."],type:"s"},use:{description:["Aliases a global object under another name, e.g., to switch","the default 'Math' implementation used: --use Math=JSMath"],type:"S",alias:"u"},trapMode:{description:["Sets the trap mode to use.",""," allow  Allow trapping operations. This is the default."," clamp  Replace trapping operations with clamping semantics."," js     Replace trapping operations with JS semantics.",""],type:"s",default:"allow"},runPasses:{description:["Specifies additional Binaryen passes to run after other","optimizations, if any. See: Binaryen/src/passes/pass.cpp"],type:"s"},enable:{description:["Enables additional (experimental) WebAssembly features.",""," sign-extension  Enables sign-extension operations"," mutable-global  Enables mutable global imports and exports"," bulk-memory     Enables bulk memory operations"," simd            Enables SIMD types and operations."," threads         Enables threading and atomic operations.",""],type:"s"},transform:{description:"Specifies the path to a custom transform to 'require'.",type:"S"},measure:{description:"Prints measuring information on I/O and compile times.",type:"b",default:!1},noColors:{description:"Disables terminal colors.",type:"b",default:!1}," ...":{description:"Specifies node.js options (CLI only). See: node --help"},"-Os":{value:{optimize:!0,shrinkLevel:1}},"-Oz":{value:{optimize:!0,shrinkLevel:2}},"-O0":{value:{optimizeLevel:0,shrinkLevel:0}},"-O1":{value:{optimizeLevel:1,shrinkLevel:0}},"-O2":{value:{optimizeLevel:2,shrinkLevel:0}},"-O3":{value:{optimizeLevel:3,shrinkLevel:0}},"-O0s":{value:{optimizeLevel:0,shrinkLevel:1}},"-O1s":{value:{optimizeLevel:1,shrinkLevel:1}},"-O2s":{value:{optimizeLevel:2,shrinkLevel:1}},"-O3s":{value:{optimizeLevel:3,shrinkLevel:1}},"-O0z":{value:{optimizeLevel:0,shrinkLevel:2}},"-O1z":{value:{optimizeLevel:1,shrinkLevel:2}},"-O2z":{value:{optimizeLevel:2,shrinkLevel:2}},"-O3z":{value:{optimizeLevel:3,shrinkLevel:2}}}},function(e,n){function t(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}t.keys=function(){return[]},t.resolve=t,e.exports=t,t.id=12},function(e,n,t){(function(n,t){e.exports=n.hrtime||function(e){var n=.001*r.call(i),t=Math.floor(n),a=Math.floor(n%1*1e9);e&&(t-=e[0],(a-=e[1])<0&&(t--,a+=1e9));return[t,a]};var i=t.performance||{},r=i.now||i.mozNow||i.msNow||i.oNow||i.webkitNow||function(){return(new Date).getTime()}}).call(this,t(0),t(2))}])});
//# sourceMappingURL=asc.js.map