{"version":3,"sources":["webpack://asc/webpack/universalModuleDefinition","webpack://asc/webpack/bootstrap","webpack://asc/../node_modules/node-libs-browser/mock/process.js","webpack://asc/../node_modules/path-browserify/index.js","webpack://asc/../node_modules/webpack/buildin/global.js","webpack://asc/./asc.js","webpack://asc/../node_modules/@protobufjs/utf8/index.js","webpack://asc/./util/colors.js","webpack://asc/./util/options.js","webpack://asc/./util/mkdirp.js","webpack://asc/external \"assemblyscript\"","webpack://asc/. sync","webpack://asc/../node_modules/browser-process-hrtime/index.js"],"names":["root","factory","exports","module","require","e","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__10__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","path","cwd","nextTick","fn","setTimeout","platform","arch","execPath","title","pid","browser","env","argv","binding","Error","chdir","dir","resolve","exit","kill","umask","dlopen","uptime","memoryUsage","uvCounters","features","process","normalizeArray","parts","allowAboveRoot","up","length","last","splice","unshift","splitPathRe","splitPath","filename","exec","slice","filter","xs","f","res","push","resolvedPath","resolvedAbsolute","arguments","TypeError","charAt","split","join","normalize","isAbsolute","trailingSlash","substr","paths","Array","index","relative","from","to","trim","arr","start","end","fromParts","toParts","Math","min","samePartsLength","outputParts","concat","sep","delimiter","dirname","result","basename","ext","extname","str","len","g","Function","window","global","fs","utf8","colorsUtil","optionsUtil","mkdirp","EOL","removeAllListeners","assemblyscript","isDev","checkDiagnostics","emitter","stderr","diagnostic","hasErrors","nextDiagnostic","write","formatDiagnostic","isTTY","isError","createStats","readTime","readCount","writeTime","writeCount","parseTime","parseCount","compileTime","compileCount","emitTime","emitCount","validateTime","validateCount","optimizeTime","optimizeCount","measure","hrtime","times","formatTime","time","toFixed","printStats","stats","output","format","count","stdout","printRTTI","program","buildRTTI","code","register","project","e_ts","eval","stack","isBundle","version","options","sourceMapRoot","libraryPrefix","LIBRARY_PREFIX","defaultOptimizeLevel","defaultShrinkLevel","libraryFiles","array","arraybuffer","bindings/Date","bindings/Math","bindings/wasi_unstable","bindings/wasi","builtins","dataview","date","diagnostics","error","fixedarray","heap","iterator","map","math","memory","number","polyfills","regexp","rt","rt/common","rt/index-full","rt/index-half","rt/index-none","rt/index-stub","rt/pure","rt/rtrace","rt/stub","rt/tlsf","set","shared/feature","shared/target","shared/typeinfo","string","symbol","table","typedarray","util/error","util/hash","util/memory","util/number","util/sort","util/string","vector","libDir","libFiles","sync","bundled","forEach","file","replace","readFileSync","definitionFiles","assembly","portable","stdDir","compileString","sources","input.ts","createMemoryStream","keys","val","isArray","String","main","readFile","writeFile","contents","listFiles","callback","readFileNode","writeFileNode","listFilesNode","opts","parse","args","noColors","supported","unknown","arg","yellow","trailing","err","red","help","out","color","white","cyan","baseDir","transforms","transform","parser","packages","Map","libPath","indexOf","parseFile","customLibDirs","lib","apply","k","endsWith","j","libText","parseBacklog","sourcePath","sourceText","nextFile","startsWith","plainName","substring","indexName","_path","_package","traceResolution","writeStdout","ascMain","has","mainFile","JSON","newPackage","realPath","_p","newPath","includes","runtimeName","runtime","runtimePath","runtimeText","applyTransform","finishParsing","writeStdOut","seenLog","optimizeLevel","shrinkLevel","optimize","max","compilerOptions","createOptions","setTarget","setNoAssert","noAssert","setImportMemory","importMemory","setSharedMemory","sharedMemory","setImportTable","importTable","setExplicitStart","explicitStart","setMemoryBase","memoryBase","setSourceMap","sourceMap","setOptimizeLevelHints","setGlobalAlias","use","aliases","part","alias","enable","flag","toUpperCase","enableFeature","compileProgram","dispose","validate","trapMode","runPasses","setOptimizeLevel","setShrinkLevel","setDebugInfo","debug","pass","noEmit","hasStdout","hasOutput","outFile","test","textFile","asmjsFile","binaryFile","wasm","sourceMapURL","toBinary","sourceRoot","text","stdName","sourceContents","stringify","asm","toAsmjs","idlFile","idl","buildIDL","tsdFile","tsd","buildTSD","wat","toText","printrtti","encoding","writeFileSync","files","readdirSync","used","allocBuffer","Buffer","allocUnsafe","Uint8Array","stream","chunk","buffer","reset","toBuffer","offset","toString","read","tscOptions","alwaysStrict","noImplicitAny","noImplicitReturns","noImplicitThis","noEmitOnError","strictNullChecks","experimentalDecorators","target","noLib","types","allowJs","charCodeAt","fromCharCode","c1","c2","proc","isCI","base","colors","gray","GRAY","RESET","RED","green","GREEN","YELLOW","blue","BLUE","magenta","MAGENTA","CYAN","WHITE","config","option","default","match","type","parseInt","parseFloat","indent","padding","eol","sb","description","line","_0777","made","undefined","mkdirSync","err0","stat","statSync","err1","isDirectory","webpackEmptyContext","req","id","previousTimestamp","clocktime","performanceNow","performance","seconds","floor","nanoseconds","now","mozNow","msNow","oNow","webkitNow","Date","getTime"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,EAAA,WAA0E,IAAM,OAAAG,QAAA,kBAAoC,MAAAC,KAApH,IACA,mBAAAC,eAAAC,IACAD,OAAA,mBAAAL,GACA,iBAAAC,QACAA,QAAA,IAAAD,EAAA,WAA0E,IAAM,OAAAG,QAAA,kBAAoC,MAAAC,KAApH,IAEAL,EAAA,IAAAC,EAAAD,EAAA,gBARA,CASC,oBAAAQ,UAAAC,KAAA,SAAAC,iCACD,mBCTA,IAAAC,EAAA,GAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAX,QAGA,IAAAC,EAAAQ,EAAAE,GAAA,CACAC,EAAAD,EACAE,GAAA,EACAb,QAAA,IAUA,OANAc,EAAAH,GAAAI,KAAAd,EAAAD,QAAAC,IAAAD,QAAAU,GAGAT,EAAAY,GAAA,EAGAZ,EAAAD,QA0DA,OArDAU,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAlB,EAAAmB,EAAAC,GACAV,EAAAW,EAAArB,EAAAmB,IACAG,OAAAC,eAAAvB,EAAAmB,EAAA,CAA0CK,YAAA,EAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAA1B,GACA,oBAAA2B,eAAAC,aACAN,OAAAC,eAAAvB,EAAA2B,OAAAC,YAAA,CAAwDC,MAAA,WAExDP,OAAAC,eAAAvB,EAAA,cAAiD6B,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAQ,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAApC,GACA,IAAAmB,EAAAnB,KAAA+B,WACA,WAA2B,OAAA/B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAS,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,GAIAhC,IAAAiC,EAAA,qBCnEA,IAEAC,EADAC,EAhBA7C,EAAA8C,SAAA,SAAAC,GACAC,WAAAD,EAAA,IAGA/C,EAAAiD,SAAAjD,EAAAkD,KACAlD,EAAAmD,SAAAnD,EAAAoD,MAAA,UACApD,EAAAqD,IAAA,EACArD,EAAAsD,SAAA,EACAtD,EAAAuD,IAAA,GACAvD,EAAAwD,KAAA,GAEAxD,EAAAyD,QAAA,SAAAtC,GACA,UAAAuC,MAAA,8CAIAb,EAAA,IAEA7C,EAAA6C,IAAA,WAA+B,OAAAA,GAC/B7C,EAAA2D,MAAA,SAAAC,GACAhB,MAA0BlC,EAAQ,IAClCmC,EAAAD,EAAAiB,QAAAD,EAAAf,IAIA7C,EAAA8D,KAAA9D,EAAA+D,KACA/D,EAAAgE,MAAAhE,EAAAiE,OACAjE,EAAAkE,OAAAlE,EAAAmE,YACAnE,EAAAoE,WAAA,aACApE,EAAAqE,SAAA,qBC7BA,SAAAC,GAyBA,SAAAC,EAAAC,EAAAC,GAGA,IADA,IAAAC,EAAA,EACA9D,EAAA4D,EAAAG,OAAA,EAAgC/D,GAAA,EAAQA,IAAA,CACxC,IAAAgE,EAAAJ,EAAA5D,GACA,MAAAgE,EACAJ,EAAAK,OAAAjE,EAAA,GACK,OAAAgE,GACLJ,EAAAK,OAAAjE,EAAA,GACA8D,KACKA,IACLF,EAAAK,OAAAjE,EAAA,GACA8D,KAKA,GAAAD,EACA,KAAUC,IAAMA,EAChBF,EAAAM,QAAA,MAIA,OAAAN,EAKA,IAAAO,EACA,gEACAC,EAAA,SAAAC,GACA,OAAAF,EAAAG,KAAAD,GAAAE,MAAA,IAuJA,SAAAC,EAAAC,EAAAC,GACA,GAAAD,EAAAD,OAAA,OAAAC,EAAAD,OAAAE,GAEA,IADA,IAAAC,EAAA,GACA3E,EAAA,EAAmBA,EAAAyE,EAAAV,OAAe/D,IAClC0E,EAAAD,EAAAzE,KAAAyE,IAAAE,EAAAC,KAAAH,EAAAzE,IAEA,OAAA2E,EAxJAvF,EAAA6D,QAAA,WAIA,IAHA,IAAA4B,EAAA,GACAC,GAAA,EAEA9E,EAAA+E,UAAAhB,OAAA,EAAoC/D,IAAA,IAAA8E,EAA8B9E,IAAA,CAClE,IAAAgC,EAAAhC,GAAA,EAAA+E,UAAA/E,GAAA0D,EAAAzB,MAGA,oBAAAD,EACA,UAAAgD,UAAA,6CACKhD,IAIL6C,EAAA7C,EAAA,IAAA6C,EACAC,EAAA,MAAA9C,EAAAiD,OAAA,IAWA,OAAAH,EAAA,SAJAD,EAAAlB,EAAAa,EAAAK,EAAAK,MAAA,cAAApD,GACA,QAAAA,KACGgD,GAAAK,KAAA,OAEH,KAKA/F,EAAAgG,UAAA,SAAApD,GACA,IAAAqD,EAAAjG,EAAAiG,WAAArD,GACAsD,EAAA,MAAAC,EAAAvD,GAAA,GAcA,OAXAA,EAAA2B,EAAAa,EAAAxC,EAAAkD,MAAA,cAAApD,GACA,QAAAA,KACGuD,GAAAF,KAAA,OAEHE,IACArD,EAAA,KAEAA,GAAAsD,IACAtD,GAAA,MAGAqD,EAAA,QAAArD,GAIA5C,EAAAiG,WAAA,SAAArD,GACA,YAAAA,EAAAiD,OAAA,IAIA7F,EAAA+F,KAAA,WACA,IAAAK,EAAAC,MAAA7D,UAAA2C,MAAApE,KAAA4E,UAAA,GACA,OAAA3F,EAAAgG,UAAAZ,EAAAgB,EAAA,SAAA1D,EAAA4D,GACA,oBAAA5D,EACA,UAAAkD,UAAA,0CAEA,OAAAlD,IACGqD,KAAA,OAMH/F,EAAAuG,SAAA,SAAAC,EAAAC,GAIA,SAAAC,EAAAC,GAEA,IADA,IAAAC,EAAA,EACUA,EAAAD,EAAAhC,QACV,KAAAgC,EAAAC,GAD8BA,KAK9B,IADA,IAAAC,EAAAF,EAAAhC,OAAA,EACUkC,GAAA,GACV,KAAAF,EAAAE,GADoBA,KAIpB,OAAAD,EAAAC,EAAA,GACAF,EAAAxB,MAAAyB,EAAAC,EAAAD,EAAA,GAfAJ,EAAAxG,EAAA6D,QAAA2C,GAAAL,OAAA,GACAM,EAAAzG,EAAA6D,QAAA4C,GAAAN,OAAA,GAsBA,IALA,IAAAW,EAAAJ,EAAAF,EAAAV,MAAA,MACAiB,EAAAL,EAAAD,EAAAX,MAAA,MAEAnB,EAAAqC,KAAAC,IAAAH,EAAAnC,OAAAoC,EAAApC,QACAuC,EAAAvC,EACA/D,EAAA,EAAiBA,EAAA+D,EAAY/D,IAC7B,GAAAkG,EAAAlG,KAAAmG,EAAAnG,GAAA,CACAsG,EAAAtG,EACA,MAIA,IAAAuG,EAAA,GACA,IAAAvG,EAAAsG,EAA+BtG,EAAAkG,EAAAnC,OAAsB/D,IACrDuG,EAAA3B,KAAA,MAKA,OAFA2B,IAAAC,OAAAL,EAAA5B,MAAA+B,KAEAnB,KAAA,MAGA/F,EAAAqH,IAAA,IACArH,EAAAsH,UAAA,IAEAtH,EAAAuH,QAAA,SAAA3E,GACA,IAAA4E,EAAAxC,EAAApC,GACA9C,EAAA0H,EAAA,GACA5D,EAAA4D,EAAA,GAEA,OAAA1H,GAAA8D,GAKAA,IAEAA,IAAAuC,OAAA,EAAAvC,EAAAe,OAAA,IAGA7E,EAAA8D,GARA,KAYA5D,EAAAyH,SAAA,SAAA7E,EAAA8E,GACA,IAAApC,EAAAN,EAAApC,GAAA,GAKA,OAHA8E,GAAApC,EAAAa,QAAA,EAAAuB,EAAA/C,UAAA+C,IACApC,IAAAa,OAAA,EAAAb,EAAAX,OAAA+C,EAAA/C,SAEAW,GAIAtF,EAAA2H,QAAA,SAAA/E,GACA,OAAAoC,EAAApC,GAAA,IAaA,IAAAuD,EAAA,WAAAA,QAAA,GACA,SAAAyB,EAAAhB,EAAAiB,GAAkC,OAAAD,EAAAzB,OAAAS,EAAAiB,IAClC,SAAAD,EAAAhB,EAAAiB,GAEA,OADAjB,EAAA,IAAAA,EAAAgB,EAAAjD,OAAAiC,GACAgB,EAAAzB,OAAAS,EAAAiB,qCC7NA,IAAAC,EAGAA,EAAA,WACA,OAAAvH,KADA,GAIA,IAEAuH,KAAA,IAAAC,SAAA,iBACC,MAAA5H,GAED,iBAAA6H,SAAAF,EAAAE,QAOA/H,EAAAD,QAAA8H,iGCnBA,SAAAxD,QAAA2D,QAcA3D,QAAAhB,UAAAgB,QAAAzB,IAAA,WAA+C,YAE/C,MAAAqF,GAAWxH,oBAAQ,GACnBkC,KAAalC,oBAAQ,GACrByH,KAAazH,oBAAQ,GACrB0H,WAAmB1H,oBAAQ,GAC3B2H,YAAoB3H,oBAAQ,GAC5B4H,OAAe5H,oBAAQ,GACvB6H,IAAA,UAAAjE,QAAArB,SAAA,YAMAqB,QAAAkE,oBAAAlE,QAAAkE,mBAAA,qBAGA,IAAAC,eAAAC,OAAA,EAyyBA,SAAAC,iBAAAC,EAAAC,GAGA,IAFA,IAAAC,EACAC,GAAA,EACA,OAAAD,EAAAL,eAAAO,eAAAJ,KACAC,GACAA,EAAAI,MACAR,eAAAS,iBAAAJ,EAAAD,EAAAM,OAAA,GACAZ,SAGAE,eAAAW,QAAAN,KAAAC,GAAA,GAEA,OAAAA,EAMA,SAAAM,cACA,OACAC,SAAA,EACAC,UAAA,EACAC,UAAA,EACAC,WAAA,EACAC,UAAA,EACAC,WAAA,EACAC,YAAA,EACAC,aAAA,EACAC,SAAA,EACAC,UAAA,EACAC,aAAA,EACAC,cAAA,EACAC,aAAA,EACAC,cAAA,GASA,SAAAC,QAAArH,GACA,MAAA6D,EAAAtC,QAAA+F,SACAtH,IACA,MAAAuH,EAAAhG,QAAA+F,OAAAzD,GACA,WAAA0D,EAAA,GAAAA,EAAA,GAMA,SAAAC,WAAAC,GACA,OAAAA,KAAA,KAAAC,QAAA,eAMA,SAAAC,WAAAC,EAAAC,GACA,SAAAC,EAAAL,EAAAM,GACA,OAAAP,WAAAC,IAEAI,GAAAtG,QAAAyG,QAAA9B,MAAA,CACA,eAAA4B,EAAAF,EAAArB,SAAAqB,EAAApB,WACA,eAAAsB,EAAAF,EAAAnB,UAAAmB,EAAAlB,YACA,eAAAoB,EAAAF,EAAAjB,UAAAiB,EAAAhB,YACA,eAAAkB,EAAAF,EAAAf,YAAAe,EAAAd,cACA,eAAAgB,EAAAF,EAAAb,SAAAa,EAAAZ,WACA,eAAAc,EAAAF,EAAAX,aAAAW,EAAAV,eACA,eAAAY,EAAAF,EAAAT,aAAAS,EAAAR,gBACApE,KAAAwC,UAMA,SAAAyC,UAAAC,EAAAL,GACAA,MAAAtG,QAAAuE,QACA+B,EAAA3B,MAAA,uCACA2B,EAAA3B,MAAAR,eAAAyC,UAAAD,IAx3BA,MACA,IACAxC,eAAqB/H,oBAAQ,IAC1B,MAAAP,GACH,IACMO,qBAAQ,eAAAP,EAAA,IAAAuD,MAAA,sCAAAvD,EAAAgL,KAAA,mBAAAhL,EAAA,IAASiL,SAAA,CAAYC,QAAAzI,KAAAmD,KAAoB,IAAS,8BAC1DrF,qBAAQ,eAAAP,EAAA,IAAAuD,MAAA,6CAAAvD,EAAAgL,KAAA,mBAAAhL,EAAA,IACdsI,eAAuB/H,qBAAQ,eAAAP,EAAA,IAAAuD,MAAA,qCAAAvD,EAAAgL,KAAA,mBAAAhL,EAAA,IAC/BuI,OAAA,EACK,MAAA4C,MACL,IACA7C,eAAA8C,KAAA,+BACO,MAAApL,GAGP,MADAA,EAAAqL,MAAAF,KAAAE,MAAA,UAAArL,EAAAqL,MACArL,MAfA,GAsBAH,QAAAyL,UAAmB,EAGnBzL,QAAA0I,YAGA1I,QAAA0L,QAAA1L,QAAAyL,SAAqC,QAAiB/K,qBAAQ,eAAAP,EAAA,IAAAuD,MAAA,8CAAAvD,EAAAgL,KAAA,mBAAAhL,EAAA,IAAiBuL,QAG/E1L,QAAA2L,QAAkBjL,oBAAQ,IAG1BV,QAAA4L,cAAA,qBAGA5L,QAAA6L,cAAApD,eAAAqD,eAGA9L,QAAA+L,qBAAA,EAGA/L,QAAAgM,mBAAA,EAGAhM,QAAAiM,aAAAjM,QAAAyL,SAA0CnK,OAAA,CAAA4K,MAAA,o3zBAAAC,YAAA,6pFAAAC,gBAAA,iVAAAC,gBAAA,q5DAAAC,yBAAA,ko+CAAAC,gBAAA,qCAAAC,SAAA,8j3CAAAC,SAAA,k2OAAAC,KAAA,upBAAAC,YAAA,4RAAAC,MAAA,itBAAAC,WAAA,88EAAAC,KAAA,iFAAAC,SAAA,ukCAAAC,IAAA,ipQAAAC,KAAA,qm6FAAAC,OAAA,q7DAAAC,OAAA,+hQAAAC,UAAA,ilCAAAC,OAAA,2YAAAC,GAAA,6mFAAAC,YAAA,qtDAAAC,gBAAA,qIAAAC,gBAAA,4BAAAC,gBAAA,4BAAAC,gBAAA,0GAAAC,UAAA,0rRAAAC,YAAA,uPAAAC,UAAA,86DAAAC,UAAA,onpBAAAC,IAAA,qoNAAAC,iBAAA,6wBAAAC,gBAAA,wTAAAC,kBAAA,khFAAAC,OAAA,q+rBAAAC,OAAA,yyGAAAC,MAAA,2aAAAC,WAAA,ig/BAAAC,aAAA,2sBAAAC,YAAA,0qEAAAC,cAAA,y5PAAAC,cAAA,mrpBAAAC,YAAA,8iJAAAC,cAAA,85IAAAC,OAAA,sFAAc,MACxD,MAAAC,EAAAnM,KAAAmD,KAA2B,IAAS,uBACpCiJ,EAAmBtO,qBAAQ,eAAAP,EAAA,IAAAuD,MAAA,mCAAAvD,EAAAgL,KAAA,mBAAAhL,EAAA,IAAM8O,KAAA,gBAAwBpM,IAAAkM,IACzDG,EAAA,GAEA,OADAF,EAAAG,QAAAC,GAAAF,EAAAE,EAAAC,QAAA,aAAAnH,GAAAoH,aAAA1M,KAAAmD,KAAAgJ,EAAAK,GAAA,SACAF,GALwD,GASxDlP,QAAAuP,gBAAAvP,QAAAyL,SAA6CnK,OAAA,CAAAkO,SAAA,q+sFAAAC,SAAA,qw3BAAkB,MAC/D,MAAAC,EAAA9M,KAAAmD,KAA2B,IAAS,YACpC,OACAyJ,SAAAtH,GAAAoH,aAAA1M,KAAAmD,KAAA2J,EAAA,iCACAD,SAAAvH,GAAAoH,aAAA1M,KAAAmD,KAAA2J,EAAA,mCAJ+D,GAS/D1P,QAAA2P,cAAA,EAAAC,EAAAjE,KACA,iBAAAiE,MAAA,CAA8CC,WAAAD,IAC9C,MAAAhF,EAAAtJ,OAAAY,OAAA,CACA6I,OAAA+E,qBACAjH,OAAAiH,uBAEA,IAAAtM,EAAA,CACA,wBACA,qBAcA,OAZAlC,OAAAyO,KAAApE,GAAA,IAA2BwD,QAAAhN,IAC3B,IAAA6N,EAAArE,EAAAxJ,GACAkE,MAAA4J,QAAAD,KAAAb,QAAAa,GAAAxM,EAAAgC,KAAA,KAAArD,EAAA+N,OAAAF,KACAxM,EAAAgC,KAAA,KAAArD,EAAA+N,OAAAF,MAEAhQ,QAAAmQ,KAAA3M,EAAA4D,OAAA9F,OAAAyO,KAAAH,IAAA,CACA7E,OAAAH,EAAAG,OACAlC,OAAA+B,EAAA/B,OACAuH,SAAAjP,GAAAyO,EAAAnN,eAAAtB,GAAAyO,EAAAzO,GAAA,KACAkP,UAAA,CAAAlP,EAAAmP,IAAA1F,EAAAzJ,GAAAmP,EACAC,UAAA,SAEA3F,IAIA5K,QAAAmQ,KAAA,SAAA3M,EAAAmI,EAAA6E,GACA,mBAAA7E,GACA6E,EAAA7E,EACAA,EAAA,IACGA,IACHA,EAAA,IAGA,MAAAZ,EAAAY,EAAAZ,QAAAzG,QAAAyG,OACAlC,EAAA8C,EAAA9C,QAAAvE,QAAAuE,OACAuH,EAAAzE,EAAAyE,UAAAK,EACAJ,EAAA1E,EAAA0E,WAAAK,EACAH,EAAA5E,EAAA4E,WAAAI,EACAhG,EAAAgB,EAAAhB,OAAAtB,cAGA,IAAA0B,EAAA,MAAArH,MAAA,sCACA,IAAAmF,EAAA,MAAAnF,MAAA,sCAEA,MAAAkN,EAAAvI,YAAAwI,MAAArN,EAAAxD,QAAA2L,SACAmF,EAAAF,EAAAjF,QAiCA,GAhCAnI,EAAAoN,EAAAjL,UACAmL,EAAAC,SACA3I,WAAA2C,OAAAiG,UACA5I,WAAAS,OAAAmI,WAAA,GAEA5I,WAAA2C,OAAA3C,WAAA5B,KAAAuE,GACA3C,WAAAS,OAAAT,WAAA5B,KAAAqC,IAIA+H,EAAAK,QAAAtM,QACAiM,EAAAK,QAAA9B,QAAA+B,IACArI,EAAAI,MAAAb,WAAAS,OAAAsI,OAAA,6BAAAD,EAAA,IAAA3I,OAKAqI,EAAAQ,SAAAzM,QACAkE,EAAAI,MAAAb,WAAAS,OAAAsI,OAAA,6CAAAP,EAAAQ,SAAArL,KAAA,KAAAwC,KAIAiI,MAAA,SAAAa,GACA,IAAAlG,EAAA,EAKA,OAJAkG,IACAxI,EAAAI,MAAAb,WAAAS,OAAAyI,IAAA,WAAAD,EAAA7F,MAAA6D,QAAA,gBAAA9G,KACA4C,EAAA,GAEAA,IAIA2F,EAAApF,QAEA,OADAX,EAAA9B,MAAA,WAAAjJ,QAAA0L,SAAAhD,MAAA,WAAAH,KACAiI,EAAA,MAGA,GAAAM,EAAAS,OAAA/N,EAAAmB,OAAA,CACA,IAAA6M,EAAAV,EAAAS,KAAAxG,EAAAlC,EACA4I,EAAAX,EAAAS,KAAAnJ,WAAA2C,OAAA3C,WAAAS,OAcA,OAbA2I,EAAAvI,MAAA,CACAwI,EAAAC,MAAA,UACA,KAAAD,EAAAE,KAAA,oCACA,GACAF,EAAAC,MAAA,YACA,KAAAD,EAAAE,KAAA,mBACA,KAAAF,EAAAE,KAAA,8CACA,KAAAF,EAAAE,KAAA,iDACA,GACAF,EAAAC,MAAA,YACAtK,OACAiB,YAAAkJ,KAAAvR,QAAA2L,QAAA,GAAApD,MACAxC,KAAAwC,UACAiI,EAAA,MAIA,IAAAtI,GAAAoH,aAAA,CACA,GAAAc,IAAAK,EAAA,MAAA/M,MAAA,wCACA,GAAA2M,IAAAK,EAAA,MAAAhN,MAAA,yCACA,GAAA6M,IAAAI,EAAA,MAAAjN,MAAA,yCAIA,MAAAkO,EAAAd,EAAAc,QAAAhP,KAAAiB,QAAAiN,EAAAc,SAAA,IAGAC,EAAA,GACAf,EAAAgB,WACAhB,EAAAgB,UAAA3C,QAAA2C,GACAD,EAAArM,KACQ9E,oBAAA,GAAAA,CACEkC,KAAAqD,WAAA6L,IAAApL,QACVoL,EACAlP,KAAAmD,KAAAzB,QAAAzB,MAAAiP,MAYA,IAAAC,EAAA,KAGA,IAAAC,EAAA,IAAAC,IAGA3Q,OAAAyO,KAAA/P,QAAAiM,cAAAkD,QAAA+C,IACAA,EAAAC,QAAA,UACAxH,EAAAhB,aACAgB,EAAAjB,WAAAU,QAAA,KACA2H,EAAAtJ,eAAA2J,UACApS,QAAAiM,aAAAiG,GACAlS,QAAA6L,cAAAqG,EAAA,OACA,EACAH,QAIA,MAAAM,EAAA,GACA,GAAAvB,EAAAwB,IAAA,CACA,IAAAA,EAAAxB,EAAAwB,IACA,iBAAAA,QAAAxM,MAAA,MACAO,MAAA7D,UAAAgD,KAAA+M,MAAAF,EAAAC,EAAAtF,IAAAsF,KAAA5L,SACA,QAAA9F,EAAA,EAAA4R,EAAAH,EAAA1N,OAA6C/D,EAAA4R,IAAO5R,EAAA,CACpD,IACAoO,EADAD,EAAAsD,EAAAzR,GAEAmO,EAAA0D,SAAA,QACAzD,EAAA,CAAApM,KAAA6E,SAAAsH,IACAA,EAAAnM,KAAA2E,QAAAwH,IAEAC,EAAAuB,EAAAxB,GAEA,QAAA2D,EAAA,EAAA7R,EAAAmO,EAAArK,OAA0C+N,EAAA7R,IAAO6R,EAAA,CACjD,IAAAR,EAAAlD,EAAA0D,GACAC,EAAAvC,EAAA8B,EAAAnD,GACA,UAAA4D,EAAA,OAAAnC,EAAA9M,MAAA,iBAAAwO,EAAA,iBACAvH,EAAAhB,aACA3J,QAAAiM,aAAAiG,EAAA7C,QAAA,aAAAsD,EACAhI,EAAAjB,WAAAU,QAAA,KACA2H,EAAAtJ,eAAA2J,UACAO,EACA3S,QAAA6L,cAAAqG,GACA,EACAH,OAQA,SAAAa,IAEA,IADA,IAAAC,EAAAC,EACA,OAAAD,EAAAd,EAAAgB,aAAA,CAIA,GAHAD,EAAA,KAGAD,EAAAG,WAAAhT,QAAA6L,eAAA,CACA,MAAAoH,EAAAJ,EAAAK,UAAAlT,QAAA6L,cAAAlH,QACAwO,EAAAN,EAAAK,UAAAlT,QAAA6L,cAAAlH,QAAA,SACA,GAAA3E,QAAAiM,aAAAxJ,eAAAwQ,GACAH,EAAA9S,QAAAiM,aAAAgH,GACAJ,EAAA7S,QAAA6L,cAAAoH,EAAA,WACS,GAAAjT,QAAAiM,aAAAxJ,eAAA0Q,GACTL,EAAA9S,QAAAiM,aAAAkH,GACAN,EAAA7S,QAAA6L,cAAAsH,EAAA,WAEA,QAAAvS,EAAA,EAAA4R,EAAAH,EAAA1N,OAAmD/D,EAAA4R,IAAO5R,EAAA,CAE1D,WADAkS,EAAA1C,EAAA6C,EAAA,MAAAZ,EAAAzR,KACA,CACAiS,EAAA7S,QAAA6L,cAAAoH,EAAA,MACA,MAGA,WADAH,EAAA1C,EAAA+C,EAAA,MAAAd,EAAAzR,KACA,CACAiS,EAAA7S,QAAA6L,cAAAsH,EAAA,MACA,YAOO,CACP,MAAAF,EAAAJ,EACAM,EAAAN,EAAA,SAEA,WADAC,EAAA1C,EAAA6C,EAAA,MAAArB,IAEAiB,EAAAI,EAAA,WAGA,WADAH,EAAA1C,EAAA+C,EAAA,MAAAvB,IAEAiB,EAAAM,EAAA,WACW,IAAAF,EAAAD,WAAA,KACX,GAAAhT,QAAAiM,aAAAxJ,eAAAwQ,GACAH,EAAA9S,QAAAiM,aAAAgH,GACAJ,EAAA7S,QAAA6L,cAAAoH,EAAA,WACa,GAAAjT,QAAAiM,aAAAxJ,eAAA0Q,GACbL,EAAA9S,QAAAiM,aAAAkH,GACAN,EAAA7S,QAAA6L,cAAAsH,EAAA,WAEA,QAAAvS,EAAA,EAAA4R,EAAAH,EAAA1N,OAAuD/D,EAAA4R,IAAO5R,EAAA,CAC9D,MAAAgD,EAAAyO,EAAAzR,GAEA,WADAkS,EAAA1C,EAAA6C,EAAA,MAAArP,IACA,CACAiP,EAAA7S,QAAA6L,cAAAoH,EAAA,MACA,MAGA,WADAH,EAAA1C,EAAA+C,EAAA,MAAAvP,IACA,CACAiP,EAAA7S,QAAA6L,cAAAsH,EAAA,MACA,QAWA,SAAAL,GAAAhC,EAAAlO,KACA,QAAAwQ,KAAAtC,EAAAlO,KAAA,CACA,IAAAyQ,EAAAR,EAAAxD,QAAA,0BACAyB,EAAAwC,iBACAC,iBAAuCV,QAAiBO,KAExD,IAAAI,EAAA,MACA,GAAAxB,EAAAyB,IAAAJ,GACA,OAAArB,EAAAvQ,IAAA4R,GAEA,IAAA3Q,EAAAE,KAAAmD,KAAAqN,EAAAC,EAAA,gBACA9N,EAAA6K,EAAA1N,EAAAkP,GACA,GAAArM,EAAA,CACA,IAAAmO,EAAAC,KAAA9C,MAAAtL,GAAAiO,QACA,GAAAE,EAAA,CACA,IAAAE,EAAAF,EAAArE,QAAA,wBAEA,OADA2C,EAAAhE,IAAAqF,EAAAO,GACAA,GAGA,kBAdA,GAgBAC,EAAAC,GACAA,EAAAzE,QAAA,2BAAyD+D,QAAYI,QAErE,MAAAP,EAAAJ,EACAM,EAAAN,EAAA,SAUA,GARA,QADAC,EAAA1C,EAAAyD,EAAAZ,GAAA,MAAArB,IAEAiB,EAAAI,EAAA,MAGA,QADAH,EAAA1C,EAAAyD,EAAAV,GAAA,MAAAvB,MAEAiB,EAAAM,EAAA,OAGA,OAAAL,EAAA,CACAhC,EAAAwC,iBACAC,WAAmCV,QAAiBgB,EAAAhB,MAEpD,IAAAkB,EAAAnR,KAAAmD,KAAAqN,EAAAC,EAAA,gBACAvC,EAAAlO,KAAAoR,SAAAD,IACAjD,EAAAlO,KAAA4C,KAAAuO,GAEA,OAIA,SAAAjB,EACA,OAAAtC,EAAA9M,MAAA,gBAAAmP,EAAA,oBAEAlI,EAAAhB,aACAgB,EAAAjB,WAAAU,QAAA,KACA3B,eAAA2J,UAAAU,EAAAD,GAAA,EAAAd,KAGA,GAAApJ,iBAAAoJ,EAAAlJ,GACA,OAAA2H,EAAA9M,MAAA,gBAKA,CACA,IAAAuQ,EAAA/D,OAAAY,EAAAoD,SACAC,EAAA,YAAAF,EACAG,EAAApU,QAAAiM,aAAAkI,GACA,SAAAC,GAGA,UADAA,EAAAhE,GADA+D,EAAAF,GACA,MAAArC,IAEA,OAAApB,EAAA9M,MAAA,YAAAuQ,EAAA,sBAGAE,EAAA,QAAAA,EAEAxJ,EAAAhB,aACAgB,EAAAjB,WAAAU,QAAA,KACA2H,EAAAtJ,eAAA2J,UAAAgC,EAAAD,GAAA,EAAApC,KAKA,QAAAnR,EAAA,EAAA4R,EAAAhP,EAAAmB,OAAkC/D,EAAA4R,IAAO5R,EAAA,CACzC,MAAAqE,EAAAzB,EAAA5C,GAEA,IAAAiS,EAAA3C,OAAAjL,GAAAoK,QAAA,WAAAA,QAAA,iBAGAyD,EAAA1C,EAAAyC,EAAA,MAAAjB,GACA,UAAAkB,EAAA,CAEA,WADAA,EAAA1C,EAAAyC,EAAA,YAAAjB,IAEA,OAAApB,EAAA9M,MAAA,eAAAmP,EAAA,oBAEAA,GAAA,iBAGAA,GAAA,MAGAlI,EAAAhB,aACAgB,EAAAjB,WAAAU,QAAA,KACA2H,EAAAtJ,eAAA2J,UAAAU,EAAAD,GAAA,EAAAd,KAKA,CACA,IAAA5G,EAAAyH,IACA,GAAAzH,EAAA,OAAAA,GA9OA,SAAAhK,KAAA2P,GACAe,EAAA1C,QAAA2C,IACA,mBAAAA,EAAA3Q,IAAA2Q,EAAA3Q,MAAA2P,KAgPAuD,CAAA,aAAAtC,GAGA,CACA,IAAA5G,EAAAyH,IACA,GAAAzH,EAAA,OAAAA,EAIA,MAAAF,EAAAxC,eAAA6L,cAAAvC,GAGAjB,EAAAP,YACAgE,YAAAxC,EAAAyC,QAAAzO,KAAA,OACAyK,EAAA,OAIA,IAAAiE,EAAA,EACAC,EAAA,EACA5D,EAAA6D,WACAF,EAAAzU,QAAA+L,qBACA2I,EAAA1U,QAAAgM,oBAEA,iBAAA8E,EAAA2D,gBACAA,EAAA3D,EAAA2D,eAEA,iBAAA3D,EAAA4D,cACAA,EAAA5D,EAAA4D,aAEAD,EAAAzN,KAAAC,IAAAD,KAAA4N,IAAAH,EAAA,MACAC,EAAA1N,KAAAC,IAAAD,KAAA4N,IAAAF,EAAA,MAGA,MAAAG,EAAApM,eAAAqM,gBAkBA,GAjBArM,eAAAsM,UAAAF,EAAA,GACApM,eAAAuM,YAAAH,EAAA/D,EAAAmE,UACAxM,eAAAyM,gBAAAL,EAAA/D,EAAAqE,cACA1M,eAAA2M,gBAAAP,EAAA/D,EAAAuE,cACA5M,eAAA6M,eAAAT,EAAA/D,EAAAyE,aACA9M,eAAA+M,iBAAAX,EAAA/D,EAAA2E,eACAhN,eAAAiN,cAAAb,EAAA/D,EAAA6E,aAAA,GACAlN,eAAAmN,aAAAf,EAAA,MAAA/D,EAAA+E,WACApN,eAAAqN,sBAAAjB,EAAAJ,EAAAC,GAGAjM,eAAAsN,eAAAlB,EAAA,qBACApM,eAAAsN,eAAAlB,EAAA,uBACApM,eAAAsN,eAAAlB,EAAA,+BACApM,eAAAsN,eAAAlB,EAAA,+BAGA/D,EAAAkF,IAAA,CACA,IAAAC,EAAAnF,EAAAkF,IACA,QAAApV,EAAA,EAAA4R,EAAAyD,EAAAtR,OAAuC/D,EAAA4R,IAAO5R,EAAA,CAC9C,IAAAsV,EAAAD,EAAArV,GACA8B,EAAAwT,EAAA/D,QAAA,KACA,GAAAzP,EAAA,SAAA8N,EAAA9M,MAAA,iBAAAwS,EAAA,kBACA,IAAA/U,EAAA+U,EAAAhD,UAAA,EAAAxQ,GAAAgE,OACAyP,EAAAD,EAAAhD,UAAAxQ,EAAA,GAAAgE,OACA,IAAAvF,EAAAwD,OAAA,OAAA6L,EAAA9M,MAAA,iBAAAwS,EAAA,kBACAzN,eAAAsN,eAAAlB,EAAA1T,EAAAgV,IAKA,IAWAlW,EAXAoE,EAAAyM,EAAAsF,OACA,SAAA/R,EAAA,CACA,iBAAAA,QAAAyB,MAAA,MACA,QAAAlF,EAAA,EAAA4R,EAAAnO,EAAAM,OAAwC/D,EAAA4R,IAAO5R,EAAA,CAC/C,IAAAO,EAAAkD,EAAAzD,GAAA8F,OACA2P,EAAA5N,eAAA,WAAAtH,EAAAkO,QAAA,WAAAiH,eACA,IAAAD,EAAA,OAAA7F,EAAA9M,MAAA,YAAAvC,EAAA,kBACAsH,eAAA8N,cAAA1B,EAAAwB,IAKA1L,EAAAd,eACA,IACAc,EAAAf,aAAAQ,QAAA,KACAnK,EAAAwI,eAAA+N,eAAAvL,EAAA4J,KAEG,MAAA1U,GACH,OAAAqQ,EAAArQ,GAEA,GAAAwI,iBAAAoJ,EAAAlJ,GAEA,OADA5I,KAAAwW,UACAjG,EAAA9M,MAAA,kBAeA,GAXAoN,EAAA4F,WACA/L,EAAAV,gBACAU,EAAAX,cAAAI,QAAA,KACA,IAAAnK,EAAAyW,WAEA,OADAzW,EAAAwW,UACAjG,EAAA9M,MAAA,sBAMA,UAAAoN,EAAA6F,SACAhM,EAAAR,gBACAQ,EAAAT,cAAAE,QAAA,KACAnK,EAAA2W,UAAA,4BAEG,UAAA9F,EAAA6F,SACHhM,EAAAR,gBACAQ,EAAAT,cAAAE,QAAA,KACAnK,EAAA2W,UAAA,yBAEG,aAAA9F,EAAA6F,SAEH,OADA1W,EAAAwW,UACAjG,EAAA9M,MAAA,2BAKA+Q,GAAA,GAAAC,GAAA,KAAAD,EAAA,GAEAxU,EAAA4W,iBAAApC,GACAxU,EAAA6W,eAAApC,GACAzU,EAAA8W,aAAAjG,EAAAkG,OAEA,IAAAJ,EAAA,GA8BA,GA7BA9F,EAAA8F,YACA,iBAAA9F,EAAA8F,YACA9F,EAAA8F,UAAA9F,EAAA8F,UAAA9Q,MAAA,MAEAgL,EAAA8F,UAAAjS,QACAmM,EAAA8F,UAAAzH,QAAA8H,IACAL,EAAAzE,QAAA8E,GAAA,GACAL,EAAApR,KAAAyR,OAMAxC,EAAA,GAAAC,EAAA,KACA/J,EAAAR,gBACAQ,EAAAT,cAAAE,QAAA,KACAnK,EAAA0U,cAKAiC,EAAAjS,SACAgG,EAAAR,gBACAQ,EAAAT,cAAAE,QAAA,KACAnK,EAAA2W,YAAA5J,IAAAiK,KAAAvQ,aAKAoK,EAAAoG,OAAA,CACA,IAAAC,GAAA,EACAC,GAAA,EAaA,GAXA,MAAAtG,EAAAuG,UACA,WAAAC,KAAAxG,EAAAuG,UAAA,MAAAvG,EAAAyG,SACAzG,EAAAyG,SAAAzG,EAAAuG,QACO,QAAAC,KAAAxG,EAAAuG,UAAA,MAAAvG,EAAA0G,UACP1G,EAAA0G,UAAA1G,EAAAuG,QACO,MAAAvG,EAAA2G,aACP3G,EAAA2G,WAAA3G,EAAAuG,UAKA,MAAAvG,EAAA2G,WAAA,CACA,IAMAC,EANAC,EAAA,MAAA7G,EAAA+E,UACA/E,EAAA+E,UAAAlR,OACAmM,EAAA+E,UACAjT,KAAA6E,SAAAqJ,EAAA2G,YAAA,OACA,KAiBA,GAdA9M,EAAAZ,YACAY,EAAAb,UAAAM,QAAA,KACAsN,EAAAzX,EAAA2X,SAAAD,KAGA7G,EAAA2G,WAAA9S,OACA0L,EAAAS,EAAA2G,WAAAC,EAAA9M,OAAAgH,IAEA2B,EAAAmE,EAAA9M,QACAuM,GAAA,GAEAC,GAAA,EAGA,MAAAM,EAAA7B,UACA,GAAA/E,EAAA2G,WAAA9S,OAAA,CACA,IAAAkR,EAAAlC,KAAA9C,MAAA6G,EAAA7B,WACAA,EAAAgC,WAAA7X,QAAA4L,cACAiK,EAAAjG,QAAAT,QAAA,CAAAhO,EAAAmF,KACA,IAAAwR,EAAA,KACA,GAAA3W,EAAA6R,WAAAhT,QAAA6L,eAAA,CACA,IAAAkM,EAAA5W,EAAA+R,UAAAlT,QAAA6L,cAAAlH,QAAA0K,QAAA,YACA,GAAArP,QAAAiM,aAAAxJ,eAAAsV,GACAD,EAAA9X,QAAAiM,aAAA8L,QAEA,QAAAnX,EAAA,EAAA4R,EAAAH,EAAA1N,OAAyD/D,EAAA4R,GAEzD,QADAsF,EAAA1H,EAAAjP,EAAA+R,UAAAlT,QAAA6L,cAAAlH,QAAA0N,EAAAzR,OADgEA,SAMhEkX,EAAA1H,EAAAjP,EAAAyQ,GAEA,UAAAkG,EACA,OAAAtH,EAAA9M,MAAA,gBAAAvC,EAAA,iBAEA0U,EAAAmC,iBAAAnC,EAAAmC,eAAA,IACAnC,EAAAmC,eAAA1R,GAAAwR,IAEAzH,EAAAzN,KAAAmD,KACAnD,KAAA2E,QAAAuJ,EAAA2G,YACA7U,KAAA6E,SAAAkQ,IACAtI,QAAA,YAAAsE,KAAAsE,UAAApC,GAAAjE,QAEA/I,EAAAI,MAAA,+CAAAV,KAMA,SAAAuI,EAAA0G,UAAA,CACA,IAAAU,EACApH,EAAA0G,UAAA7S,QACAgG,EAAAZ,YACAY,EAAAb,UAAAM,QAAA,KACA8N,EAAAjY,EAAAkY,YAEA9H,EAAAS,EAAA0G,UAAAU,EAAAtG,IACOuF,IACPxM,EAAAZ,YACAY,EAAAb,UAAAM,QAAA,KACA8N,EAAAjY,EAAAkY,YAEA5E,EAAA2E,GACAf,GAAA,GAEAC,GAAA,EAIA,SAAAtG,EAAAsH,QAAA,CACA,IAAAC,EACAvH,EAAAsH,QAAAzT,QACAgG,EAAAZ,YACAY,EAAAb,UAAAM,QAAA,KACAiO,EAAA5P,eAAA6P,SAAArN,KAEAoF,EAAAS,EAAAsH,QAAAC,EAAAzG,IACOuF,IACPxM,EAAAZ,YACAY,EAAAb,UAAAM,QAAA,KACAiO,EAAA5P,eAAA6P,SAAArN,KAEAsI,EAAA8E,GACAlB,GAAA,GAEAC,GAAA,EAIA,SAAAtG,EAAAyH,QAAA,CACA,IAAAC,EACA1H,EAAAyH,QAAA5T,QACAgG,EAAAZ,YACAY,EAAAb,UAAAM,QAAA,KACAoO,EAAA/P,eAAAgQ,SAAAxN,KAEAoF,EAAAS,EAAAyH,QAAAC,EAAA5G,IACOuF,IACPxM,EAAAZ,YACAY,EAAAb,UAAAM,QAAA,KACAoO,EAAA/P,eAAAgQ,SAAAxN,KAEAsI,EAAAiF,GACArB,GAAA,GAEAC,GAAA,EAIA,SAAAtG,EAAAyG,WAAAH,EAAA,CACA,IAAAsB,EACA5H,EAAAyG,UAAAzG,EAAAyG,SAAA5S,QACAgG,EAAAZ,YACAY,EAAAb,UAAAM,QAAA,KACAsO,EAAAzY,EAAA0Y,WAEAtI,EAAAS,EAAAyG,SAAAmB,EAAA9G,IACOuF,IACPxM,EAAAZ,YACAY,EAAAb,UAAAM,QAAA,KACAsO,EAAAzY,EAAA0Y,WAEApF,EAAAmF,KAYA,OAPAzY,EAAAwW,UACA3F,EAAA1G,SACAM,WAAAC,EAAA9B,GAEAiI,EAAA8H,WACA5N,UAAAC,EAAApC,GAEA2H,EAAA,MAEA,SAAAC,EAAAxL,EAAA2M,GACA,IAAAhO,EAAAgO,GAAA,IACAzQ,EAAAyB,KAAAiB,QAAAjB,KAAAmD,KAAAnC,EAAAqB,IACA,IACA,IAAA6S,EAKA,OAJAnN,EAAApB,YACAoB,EAAArB,UAAAc,QAAA,KACA0N,EAAA5P,GAAAoH,aAAAnO,EAAA,CAAsC0X,SAAA,WAEtCf,EACK,MAAA3X,GACL,aAIA,SAAAuQ,EAAAzL,EAAAqL,EAAAsB,GACA,IAUA,OATAjH,EAAAlB,aACAkB,EAAAnB,WAAAY,QAAA,KACA9B,OAAA1F,KAAAmD,KAAA6L,EAAAhP,KAAA2E,QAAAtC,KACA,iBAAAqL,EACApI,GAAA4Q,cAAAlW,KAAAmD,KAAA6L,EAAA3M,GAAAqL,EAAA,CAAoEuI,SAAA,SAEpE3Q,GAAA4Q,cAAAlW,KAAAmD,KAAA6L,EAAA3M,GAAAqL,MAGA,EACK,MAAAnQ,GACL,UAIA,SAAAwQ,EAAApJ,EAAAqK,GACA,IAAAmH,EACA,IAIA,OAHApO,EAAArB,UAAAc,QAAA,KACA2O,EAAA7Q,GAAA8Q,YAAApW,KAAAmD,KAAA6L,EAAArK,IAAAnC,OAAAgK,GAAA,yBAAAkI,KAAAlI,MAEA2J,EACK,MAAA5Y,GACL,UAIA,SAAAoT,EAAAjD,GACAiD,EAAA0F,OACAtO,EAAAlB,aACA8J,EAAA0F,MAAA,GAEAtO,EAAAnB,WAAAY,QAAA,KACA,iBAAAkG,EACAvF,EAAA9B,MAAAqH,EAAA,CAAgCuI,SAAA,SAEhC9N,EAAA9B,MAAAqH,OAsBAtQ,QAAA2I,kCAsBA3I,QAAAqJ,wBAEA/E,QAAA+F,SAAA/F,QAAA+F,OAAsC3J,oBAAQ,KAU9CV,QAAAoK,gBAOApK,QAAAuK,sBAkBAvK,QAAA0K,sBASA1K,QAAAgL,oBAEA,IAAAkO,iBAAA,IAAAjR,eAAAkR,OACAlR,OAAAkR,OAAAC,aAAA,SAAAvR,GAAgD,WAAAI,OAAAkR,OAAAtR,IAChD,SAAAA,GAAmB,WAAAwR,WAAAxR,IAGnB,SAAAiI,mBAAA/M,GACA,IAAAuW,EAAA,GA6BA,OA5BAA,EAAArQ,MAAA,SAAAsQ,GAEA,GADAxW,KAAAwW,GACA,iBAAAA,EAAA,CACA,IAAAC,EAAAN,YAAA/Q,KAAAxD,OAAA4U,IACApR,KAAAc,MAAAsQ,EAAAC,EAAA,GACAD,EAAAC,EAEAjZ,KAAAiF,KAAA+T,IAEAD,EAAAG,MAAA,WACAH,EAAA3U,OAAA,GAEA2U,EAAAI,SAAA,WAEA,IADA,IAAAC,EAAA,EAAA/Y,EAAA,EAAA4R,EAAAjS,KAAAoE,OACA/D,EAAA4R,GAAAmH,GAAApZ,KAAAK,KAAA+D,OACA,IAAA6U,EAAAN,YAAAS,GAEA,IADAA,EAAA/Y,EAAA,EACAA,EAAA4R,GACAgH,EAAAxL,IAAAzN,KAAAK,GAAA+Y,GACAA,GAAApZ,KAAAK,GAAA+D,SACA/D,EAEA,OAAA4Y,GAEAF,EAAAM,SAAA,WACA,IAAAJ,EAAAjZ,KAAAmZ,WACA,OAAAvR,KAAA0R,KAAAL,EAAA,EAAAA,EAAA7U,SAEA2U,EAGAtZ,QAAA8P,sCAGA9P,QAAA8Z,WAAA,CACAC,cAAA,EACAC,eAAA,EACAC,mBAAA,EACAC,gBAAA,EACAC,eAAA,EACAC,kBAAA,EACAC,wBAAA,EACAC,OAAA,SACAra,OAAA,WACAsa,OAAA,EACAC,MAAA,GACAC,SAAA,4FC38BA,IAAAtS,EAAAnI,EAOAmI,EAAAxD,OAAA,SAAAyJ,GAGA,IAFA,IAAAvG,EAAA,EACA5G,EAAA,EACAL,EAAA,EAAmBA,EAAAwN,EAAAzJ,SAAmB/D,GACtCK,EAAAmN,EAAAsM,WAAA9Z,IACA,IACAiH,GAAA,EACA5G,EAAA,KACA4G,GAAA,EACA,cAAA5G,IAAA,cAAAmN,EAAAsM,WAAA9Z,EAAA,OACAA,EACAiH,GAAA,GAEAA,GAAA,EAEA,OAAAA,GAUAM,EAAA0R,KAAA,SAAAL,EAAA5S,EAAAC,GAEA,GADAA,EAAAD,EACA,EACA,SAKA,IAJA,IAGA9E,EAHA0C,EAAA,KACA+U,EAAA,GACA3Y,EAAA,EAEAgG,EAAAC,IACA/E,EAAA0X,EAAA5S,MACA,IACA2S,EAAA3Y,KAAAkB,EACAA,EAAA,KAAAA,EAAA,IACAyX,EAAA3Y,MAAA,GAAAkB,IAAA,KAAA0X,EAAA5S,KACA9E,EAAA,KAAAA,EAAA,KACAA,IAAA,EAAAA,IAAA,OAAA0X,EAAA5S,OAAA,OAAA4S,EAAA5S,OAAA,KAAA4S,EAAA5S,MAAA,MACA2S,EAAA3Y,KAAA,OAAAkB,GAAA,IACAyX,EAAA3Y,KAAA,YAAAkB,IAEAyX,EAAA3Y,MAAA,GAAAkB,IAAA,OAAA0X,EAAA5S,OAAA,KAAA4S,EAAA5S,KACAhG,EAAA,QACA4D,MAAA,KAAAgB,KAAA0K,OAAAyK,aAAApI,MAAArC,OAAAqJ,IACA3Y,EAAA,GAGA,OAAA4D,GACA5D,GACA4D,EAAAgB,KAAA0K,OAAAyK,aAAApI,MAAArC,OAAAqJ,EAAApU,MAAA,EAAAvE,KACA4D,EAAAuB,KAAA,KAEAmK,OAAAyK,aAAApI,MAAArC,OAAAqJ,EAAApU,MAAA,EAAAvE,KAUAuH,EAAAc,MAAA,SAAAmF,EAAAoL,EAAAG,GAIA,IAHA,IACAiB,EACAC,EAFAjU,EAAA+S,EAGA/Y,EAAA,EAAmBA,EAAAwN,EAAAzJ,SAAmB/D,GACtCga,EAAAxM,EAAAsM,WAAA9Z,IACA,IACA4Y,EAAAG,KAAAiB,EACSA,EAAA,MACTpB,EAAAG,KAAAiB,GAAA,MACApB,EAAAG,KAAA,GAAAiB,EAAA,KACS,cAAAA,IAAA,eAAAC,EAAAzM,EAAAsM,WAAA9Z,EAAA,MACTga,EAAA,aAAAA,IAAA,UAAAC,KACAja,EACA4Y,EAAAG,KAAAiB,GAAA,OACApB,EAAAG,KAAAiB,GAAA,UACApB,EAAAG,KAAAiB,GAAA,SACApB,EAAAG,KAAA,GAAAiB,EAAA,MAEApB,EAAAG,KAAAiB,GAAA,OACApB,EAAAG,KAAAiB,GAAA,SACApB,EAAAG,KAAA,GAAAiB,EAAA,KAGA,OAAAjB,EAAA/S,qBCvGA,SAAAtC,GAAA,IAAAwW,OAAA,IAAAxW,MAAA,GACAyW,EAAAD,EAAAvX,KAAA,OAAAuX,EAAAvX,IAEA,SAAAiD,EAAA8S,EAAA0B,GACA,IAAAC,EAAAD,GAAA,GAUA,OATAC,EAAAjK,UAAAsI,OAAAnQ,OAAA4R,EACAE,EAAAC,KAAApD,IAAAmD,EAAAjK,UAAAhR,EAAAmb,KAAArD,EAAA9X,EAAAob,MAAAtD,GACAmD,EAAA3J,IAAAwG,IAAAmD,EAAAjK,UAAAhR,EAAAqb,IAAAvD,EAAA9X,EAAAob,MAAAtD,GACAmD,EAAAK,MAAAxD,IAAAmD,EAAAjK,UAAAhR,EAAAub,MAAAzD,EAAA9X,EAAAob,MAAAtD,GACAmD,EAAA9J,OAAA2G,IAAAmD,EAAAjK,UAAAhR,EAAAwb,OAAA1D,EAAA9X,EAAAob,MAAAtD,GACAmD,EAAAQ,KAAA3D,IAAAmD,EAAAjK,UAAAhR,EAAA0b,KAAA5D,EAAA9X,EAAAob,MAAAtD,GACAmD,EAAAU,QAAA7D,IAAAmD,EAAAjK,UAAAhR,EAAA4b,QAAA9D,EAAA9X,EAAAob,MAAAtD,GACAmD,EAAAtJ,KAAAmG,IAAAmD,EAAAjK,UAAAhR,EAAA6b,KAAA/D,EAAA9X,EAAAob,MAAAtD,GACAmD,EAAAvJ,MAAAoG,IAAAmD,EAAAjK,UAAAhR,EAAA8b,MAAAhE,EAAA9X,EAAAob,MAAAtD,GACAmD,EAGAjb,EAAA+K,OAAAvE,EAAAsU,EAAA/P,OAAA/K,GACAA,EAAA6I,OAAArC,EAAAsU,EAAAjS,QACA7I,EAAAwG,OAEAxG,EAAAmb,KAAA,QACAnb,EAAAqb,IAAA,QACArb,EAAAub,MAAA,QACAvb,EAAAwb,OAAA,QACAxb,EAAA0b,KAAA,QACA1b,EAAA4b,QAAA,QACA5b,EAAA6b,KAAA,QACA7b,EAAA8b,MAAA,QACA9b,EAAAob,MAAA,wCCmDApb,EAAA6Q,MArEA,SAAArN,EAAAuY,GACA,IAAApQ,EAAA,GACAsF,EAAA,GACAtL,UAAA,GACAyL,EAAA,GAGA6E,EAAA,GACA3U,OAAAyO,KAAAgM,GAAA5M,QAAAhN,IACA,IAAAA,EAAA6Q,WAAA,MACA,IAAAgJ,EAAAD,EAAA5Z,GACA,MAAA6Z,EAAA7F,QACA,iBAAA6F,EAAA7F,MAAAF,EAAA+F,EAAA7F,OAAAhU,EACAkE,MAAA4J,QAAA+L,EAAA7F,QAAA6F,EAAA7F,MAAAhH,QAAAgH,GAAAF,EAAAE,GAAAhU,IAEA,MAAA6Z,EAAAC,UAAAtQ,EAAAxJ,GAAA6Z,EAAAC,YAIA,QAAArb,EAAA,EAAA4R,GAAAhP,IAAA2B,SAAAR,OAAmD/D,EAAA4R,IAAO5R,EAAA,CAC1D,IAAAsQ,EAAA1N,EAAA5C,GACA,SAAAsQ,EAAA,GAAsBtQ,EAAK,MAC3B,IAAiDob,EAAA7Z,EAAjD+Z,EAAA,gDAAiDhX,KAAAgM,GACjD,GAAAgL,EACAH,EAAA7K,GAAA8K,EAAAD,EAAA5Z,EAAA+O,GACA,MAAAgL,EAAA,IACAF,EAAAD,EAAA5Z,EAAA8T,EAAAiG,EAAA,GAAAhJ,UAAA,OACA,MAAAgJ,EAAA,KAAA1Y,EAAA5C,KAAAsb,EAAA,IACO,MAAAA,EAAA,KACPF,EAAAD,EAAA5Z,EAAA+Z,EAAA,GAAAhJ,UAAA,MACA,MAAAgJ,EAAA,KAAA1Y,EAAA5C,KAAAsb,EAAA,QAEK,CACL,OAAAhL,EAAAwJ,WAAA,GACA,CAAY/U,UAAAH,KAAA0L,GAAqB,SADjC8K,EAAAD,EAAA5Z,EAAA+O,GAGA,GAAA8K,EAAA,CACA,SAAAA,EAAAG,MAAA,MAAAH,EAAAG,KAAAxQ,EAAAxJ,IAAA,OAEA,GAAAvB,EAAA,EAAA4C,EAAAmB,QAAA,IAAAnB,EAAA5C,EAAA,GAAA8Z,WAAA,GACA,OAAAsB,EAAAG,MACA,QAAAxQ,EAAAxJ,GAAAia,SAAA5Y,IAAA5C,GAAA,IAA6D,MAC7D,QAAA+K,EAAAxJ,IAAAwJ,EAAAxJ,IAAA,IAAAiF,OAAAgV,SAAA5Y,IAAA5C,GAAA,KAA0F,MAC1F,QAAA+K,EAAAxJ,GAAAka,WAAA7Y,IAAA5C,IAA2D,MAC3D,QAAA+K,EAAAxJ,IAAAwJ,EAAAxJ,IAAA,IAAAiF,OAAAiV,WAAA7Y,IAAA5C,KAAwF,MACxF,QAAA+K,EAAAxJ,GAAA+N,OAAA1M,IAAA5C,IAAuD,MACvD,QAAA+K,EAAAxJ,IAAAwJ,EAAAxJ,IAAA,IAAAiF,OAAA5D,IAAA5C,GAAAkF,MAAA,MAAuF,MACvF,QAAAmL,EAAAzL,KAAA0L,KAAuCtQ,OAGvC,OAAAob,EAAAG,MACA,QACA,QAAAxQ,EAAAxJ,GAAA6Z,EAAAC,SAAA,EAAyD,MACzD,QAAAtQ,EAAAxJ,GAAA6Z,EAAAC,SAAA,GAA0D,MAC1D,QACA,QACA,QAAAtQ,EAAAxJ,GAAAwJ,EAAAsQ,SAAA,GAA2D,MAC3D,QAAAhL,EAAAzL,KAAA0L,GAIA8K,EAAAna,OAAAP,OAAAyO,KAAAiM,EAAAna,OAAAsN,QAAAqD,GAAA7G,EAAA6G,GAAAwJ,EAAAna,MAAA2Q,SACKvB,EAAAzL,KAAA0L,GAEL,KAAAtQ,EAAA4R,GAAApB,EAAA5L,KAAAhC,EAAA5C,MAEA,OAAU+K,UAAAsF,UAAAtL,oBAAAyL,aA8BVpR,EAAAuR,KAxBA,SAAAwK,EAAApQ,GACAA,MAAA,IACA,IAAA2Q,EAAA3Q,EAAA2Q,QAAA,EACAC,EAAA5Q,EAAA4Q,SAAA,GACAC,EAAA7Q,EAAA6Q,KAAA,KACAC,EAAA,GAgBA,OAfAnb,OAAAyO,KAAAgM,GAAA5M,QAAAhN,IACA,IAAA6Z,EAAAD,EAAA5Z,GACA,SAAA6Z,EAAAU,YAAA,CAEA,IADA,IAAA5E,EAAA,GACAA,EAAAnT,OAAA2X,GAAAxE,GAAA,IAGA,IAFAA,GAAA,KAAA3V,EACA6Z,EAAA7F,QAAA2B,GAAA,MAAAkE,EAAA7F,OACA2B,EAAAnT,OAAA4X,GAAAzE,GAAA,IACAzR,MAAA4J,QAAA+L,EAAAU,aACAD,EAAAjX,KAAAsS,EAAAkE,EAAAU,YAAA,GAAAV,EAAAU,YAAAvX,MAAA,GAAA6H,IAAA2P,IACA,QAAA/b,EAAA,EAAuBA,EAAA2b,IAAa3b,EAAA+b,EAAA,IAAAA,EACpC,OAAAH,EAAAG,IACO5W,KAAA,KACF0W,EAAAjX,KAAAsS,EAAAkE,EAAAU,gBAELD,EAAA1W,KAAAyW,sBCxGA,SAAAlY,GAwBA,IAAA1B,EAAWlC,EAAQ,GACnBwH,EAASxH,EAAQ,GACjBkc,EAAAR,SAAA,UAEAnc,EAAAD,QAAA,SAAAsI,EAAA5F,EAAAkO,EAAAiM,GACAjM,GAAA,iBAAAA,IACAA,EAAA,CAAY7O,KAAA6O,IAEZ,IAAA7O,EAAA6O,EAAA7O,UACA+a,IAAA/a,IACAA,EAAA6a,GAAAtY,EAAAN,SAEA6Y,MAAA,MACAna,EAAAE,EAAAiB,QAAAnB,GACA,IACAwF,EAAA6U,UAAAra,EAAAX,GACA8a,KAAAna,EACG,MAAAsa,GACH,OAAAA,EAAA7R,MACA,aACA0R,EAAAvU,EAAA1F,EAAA2E,QAAA7E,GAAAkO,EAAAiM,GACAvU,EAAA5F,EAAAkO,EAAAiM,GACA,MACA,QACA,IAAAI,EACA,IACAA,EAAA/U,EAAAgV,SAAAxa,GACS,MAAAya,GACT,MAAAH,EAEA,IAAAC,EAAAG,cAAA,MAAAJ,GAIA,OAAAH,oCC1DA,YAAArc,gCAAA,CAA4D,IAAAL,EAAA,IAAAuD,MAAA,uCAAsF,MAA7BvD,EAAAgL,KAAA,mBAA6BhL,EAClJF,EAAAD,QAAAQ,41KCDA,SAAA6c,EAAAC,GACA,IAAAnd,EAAA,IAAAuD,MAAA,uBAAA4Z,EAAA,KAEA,MADAnd,EAAAgL,KAAA,mBACAhL,EAEAkd,EAAAtN,KAAA,WAAuC,UACvCsN,EAAAxZ,QAAAwZ,EACApd,EAAAD,QAAAqd,EACAA,EAAAE,GAAA,qBCRA,SAAAjZ,EAAA2D,GAAAhI,EAAAD,QAAAsE,EAAA+F,QAcA,SAAAmT,GACA,IAAAC,EAAA,KAAAC,EAAA3c,KAAA4c,GACAC,EAAA5W,KAAA6W,MAAAJ,GACAK,EAAA9W,KAAA6W,MAAAJ,EAAA,OACAD,IACAI,GAAAJ,EAAA,IACAM,GAAAN,EAAA,IACA,IACAI,IACAE,GAAA,MAGA,OAAAF,EAAAE,IAvBA,IAAAH,EAAA1V,EAAA0V,aAAA,GACAD,EACAC,EAAAI,KACAJ,EAAAK,QACAL,EAAAM,OACAN,EAAAO,MACAP,EAAAQ,WACA,WAAa,WAAAC,MAAAC","file":"asc.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory((function webpackLoadOptionalExternalModule() { try { return require(\"assemblyscript\"); } catch(e) {} }()));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"assemblyscript\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"asc\"] = factory((function webpackLoadOptionalExternalModule() { try { return require(\"assemblyscript\"); } catch(e) {} }()));\n\telse\n\t\troot[\"asc\"] = factory(root[\"assemblyscript\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE__10__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","exports.nextTick = function nextTick(fn) {\n\tsetTimeout(fn, 0);\n};\n\nexports.platform = exports.arch = \nexports.execPath = exports.title = 'browser';\nexports.pid = 1;\nexports.browser = true;\nexports.env = {};\nexports.argv = [];\n\nexports.binding = function (name) {\n\tthrow new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    exports.cwd = function () { return cwd };\n    exports.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\nexports.exit = exports.kill = \nexports.umask = exports.dlopen = \nexports.uptime = exports.memoryUsage = \nexports.uvCounters = function() {};\nexports.features = {};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/**\n * Compiler frontend for node.js\n *\n * Uses the low-level API exported from src/index.ts so it works with the compiler compiled to\n * JavaScript as well as the compiler compiled to WebAssembly (eventually). Runs the sources\n * directly through ts-node if distribution files are not present (indicated by a `-dev` version).\n *\n * Can also be packaged as a bundle suitable for in-browser use with the standard library injected\n * in the build step. See dist/asc.js for the bundle and webpack.config.js for building details.\n *\n * @module cli/asc\n */\n\n// Use \".\" instead of \"/\" as cwd in browsers\nif (process.browser) process.cwd = function() { return \".\"; };\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst utf8 = require(\"@protobufjs/utf8\");\nconst colorsUtil = require(\"./util/colors\");\nconst optionsUtil = require(\"./util/options\");\nconst mkdirp = require(\"./util/mkdirp\");\nconst EOL = process.platform === \"win32\" ? \"\\r\\n\" : \"\\n\";\n\n// global.Binaryen = require(\"../lib/binaryen\");\n\n// Emscripten adds an `uncaughtException` listener to Binaryen that results in an additional\n// useless code fragment on top of an actual error. suppress this:\nif (process.removeAllListeners) process.removeAllListeners(\"uncaughtException\");\n\n// Use distribution files if present, otherwise run the sources directly\nvar assemblyscript, isDev = false;\n(() => {\n  try { // `asc` on the command line\n    assemblyscript = require(\"../dist/assemblyscript.js\");\n  } catch (e) {\n    try { // `asc` on the command line without dist files\n      require(\"ts-node\").register({ project: path.join(__dirname, \"..\", \"src\", \"tsconfig.json\") });\n      require(\"../src/glue/js\");\n      assemblyscript = require(\"../src\");\n      isDev = true;\n    } catch (e_ts) {\n      try { // `require(\"dist/asc.js\")` in explicit browser tests\n        assemblyscript = eval(\"require('./assemblyscript')\");\n      } catch (e) {\n        // combine both errors that lead us here\n        e.stack = e_ts.stack + \"\\n---\\n\" + e.stack;\n        throw e;\n      }\n    }\n  }\n})();\n\n/** Whether this is a webpack bundle or not. */\nexports.isBundle = typeof BUNDLE_VERSION === \"string\";\n\n/** Whether asc runs the sources directly or not. */\nexports.isDev = isDev;\n\n/** AssemblyScript version. */\nexports.version = exports.isBundle ? BUNDLE_VERSION : require(\"../package.json\").version;\n\n/** Available CLI options. */\nexports.options = require(\"./asc.json\");\n\n/** Common root used in source maps. */\nexports.sourceMapRoot = \"assemblyscript:///\";\n\n/** Prefix used for library files. */\nexports.libraryPrefix = assemblyscript.LIBRARY_PREFIX;\n\n/** Default Binaryen optimization level. */\nexports.defaultOptimizeLevel = 3;\n\n/** Default Binaryen shrink level. */\nexports.defaultShrinkLevel = 1;\n\n/** Bundled library files. */\nexports.libraryFiles = exports.isBundle ? BUNDLE_LIBRARY : (() => { // set up if not a bundle\n  const libDir = path.join(__dirname, \"..\", \"std\", \"assembly\");\n  const libFiles = require(\"glob\").sync(\"**/!(*.d).ts\", { cwd: libDir });\n  const bundled = {};\n  libFiles.forEach(file => bundled[file.replace(/\\.ts$/, \"\")] = fs.readFileSync(path.join(libDir, file), \"utf8\" ));\n  return bundled;\n})();\n\n/** Bundled definition files. */\nexports.definitionFiles = exports.isBundle ? BUNDLE_DEFINITIONS : (() => { // set up if not a bundle\n  const stdDir = path.join(__dirname, \"..\", \"std\");\n  return {\n    \"assembly\": fs.readFileSync(path.join(stdDir, \"assembly\", \"index.d.ts\"), \"utf8\"),\n    \"portable\": fs.readFileSync(path.join(stdDir, \"portable\", \"index.d.ts\"), \"utf8\")\n  };\n})();\n\n/** Convenience function that parses and compiles source strings directly. */\nexports.compileString = (sources, options) => {\n  if (typeof sources === \"string\") sources = { \"input.ts\": sources };\n  const output = Object.create({\n    stdout: createMemoryStream(),\n    stderr: createMemoryStream()\n  });\n  var argv = [\n    \"--binaryFile\", \"binary\",\n    \"--textFile\", \"text\",\n  ];\n  Object.keys(options || {}).forEach(key => {\n    var val = options[key];\n    if (Array.isArray(val)) val.forEach(val => argv.push(\"--\" + key, String(val)));\n    else argv.push(\"--\" + key, String(val));\n  });\n  exports.main(argv.concat(Object.keys(sources)), {\n    stdout: output.stdout,\n    stderr: output.stderr,\n    readFile: name => sources.hasOwnProperty(name) ? sources[name] : null,\n    writeFile: (name, contents) => output[name] = contents,\n    listFiles: () => []\n  });\n  return output;\n}\n\n/** Runs the command line utility using the specified arguments array. */\nexports.main = function main(argv, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  } else if (!options) {\n    options = {};\n  }\n\n  const stdout = options.stdout || process.stdout;\n  const stderr = options.stderr || process.stderr;\n  const readFile = options.readFile || readFileNode;\n  const writeFile = options.writeFile || writeFileNode;\n  const listFiles = options.listFiles || listFilesNode;\n  const stats = options.stats || createStats();\n\n  // Output must be specified if not present in the environment\n  if (!stdout) throw Error(\"'options.stdout' must be specified\");\n  if (!stderr) throw Error(\"'options.stderr' must be specified\");\n\n  const opts = optionsUtil.parse(argv, exports.options);\n  const args = opts.options;\n  argv = opts.arguments;\n  if (args.noColors) {\n    colorsUtil.stdout.supported =\n    colorsUtil.stderr.supported = false;\n  } else {\n    colorsUtil.stdout = colorsUtil.from(stdout);\n    colorsUtil.stderr = colorsUtil.from(stderr);\n  }\n\n  // Check for unknown arguments\n  if (opts.unknown.length) {\n    opts.unknown.forEach(arg => {\n      stderr.write(colorsUtil.stderr.yellow(\"WARN: \") + \"Unknown option '\" + arg + \"'\" + EOL);\n    });\n  }\n\n  // Check for trailing arguments\n  if (opts.trailing.length) {\n    stderr.write(colorsUtil.stderr.yellow(\"WARN: \") + \"Unsupported trailing arguments: \" + opts.trailing.join(\" \") + EOL);\n  }\n\n  // Use default callback if none is provided\n  if (!callback) callback = function defaultCallback(err) {\n    var code = 0;\n    if (err) {\n      stderr.write(colorsUtil.stderr.red(\"ERROR: \") + err.stack.replace(/^ERROR: /i, \"\") + EOL);\n      code = 1;\n    }\n    return code;\n  };\n\n  // Just print the version if requested\n  if (args.version) {\n    stdout.write(\"Version \" + exports.version + (isDev ? \"-dev\" : \"\") + EOL);\n    return callback(null);\n  }\n  // Print the help message if requested or no source files are provided\n  if (args.help || !argv.length) {\n    var out = args.help ? stdout : stderr;\n    var color = args.help ? colorsUtil.stdout : colorsUtil.stderr;\n    out.write([\n      color.white(\"SYNTAX\"),\n      \"  \" + color.cyan(\"asc\") + \" [entryFile ...] [options]\",\n      \"\",\n      color.white(\"EXAMPLES\"),\n      \"  \" + color.cyan(\"asc\") + \" hello.ts\",\n      \"  \" + color.cyan(\"asc\") + \" hello.ts -b hello.wasm -t hello.wat\",\n      \"  \" + color.cyan(\"asc\") + \" hello1.ts hello2.ts -b -O > hello.wasm\",\n      \"\",\n      color.white(\"OPTIONS\"),\n    ].concat(\n      optionsUtil.help(exports.options, 24, EOL)\n    ).join(EOL) + EOL);\n    return callback(null);\n  }\n\n  // I/O must be specified if not present in the environment\n  if (!fs.readFileSync) {\n    if (readFile === readFileNode) throw Error(\"'options.readFile' must be specified\");\n    if (writeFile === writeFileNode) throw Error(\"'options.writeFile' must be specified\");\n    if (listFiles === listFilesNode) throw Error(\"'options.listFiles' must be specified\");\n  }\n\n  // Set up base directory\n  const baseDir = args.baseDir ? path.resolve(args.baseDir) : \".\";\n\n  // Set up transforms\n  const transforms = [];\n  if (args.transform) {\n    args.transform.forEach(transform =>\n      transforms.push(\n        require(\n          path.isAbsolute(transform = transform.trim())\n            ? transform\n            : path.join(process.cwd(), transform)\n        )\n      )\n    );\n  }\n  function applyTransform(name, ...args) {\n    transforms.forEach(transform => {\n      if (typeof transform[name] === \"function\") transform[name](...args);\n    });\n  }\n\n  // Begin parsing\n  var parser = null;\n  \n  //maps package names to parent directory\n  let packages = new Map();\n\n  // Include library files\n  Object.keys(exports.libraryFiles).forEach(libPath => {\n    if (libPath.indexOf(\"/\") >= 0) return; // in sub-directory: imported on demand\n    stats.parseCount++;\n    stats.parseTime += measure(() => {\n      parser = assemblyscript.parseFile(\n        exports.libraryFiles[libPath],\n        exports.libraryPrefix + libPath + \".ts\",\n        false,\n        parser\n      );\n    });\n  });\n  const customLibDirs = [];\n  if (args.lib) {\n    let lib = args.lib;\n    if (typeof lib === \"string\") lib = lib.split(\",\");\n    Array.prototype.push.apply(customLibDirs, lib.map(lib => lib.trim()));\n    for (let i = 0, k = customLibDirs.length; i < k; ++i) { // custom\n      let libDir = customLibDirs[i];\n      let libFiles;\n      if (libDir.endsWith(\".ts\")) {\n        libFiles = [ path.basename(libDir) ];\n        libDir = path.dirname(libDir);\n      } else {\n        libFiles = listFiles(libDir);\n      }\n      for (let j = 0, l = libFiles.length; j < l; ++j) {\n        let libPath = libFiles[j];\n        let libText = readFile(libPath, libDir);\n        if (libText === null) return callback(Error(\"Library file '\" + libPath + \"' not found.\"));\n        stats.parseCount++;\n        exports.libraryFiles[libPath.replace(/\\.ts$/, \"\")] = libText\n        stats.parseTime += measure(() => {\n          parser = assemblyscript.parseFile(\n            libText,\n            exports.libraryPrefix + libPath,\n            false,\n            parser\n          );\n        });\n      }\n    }\n  }\n\n  // Parses the backlog of imported files after including entry files\n  function parseBacklog() {\n    var sourcePath, sourceText;\n    while ((sourcePath = parser.nextFile()) != null) {\n      sourceText = null;\n\n      // Load library file if explicitly requested\n      if (sourcePath.startsWith(exports.libraryPrefix)) {\n        const plainName = sourcePath.substring(exports.libraryPrefix.length);\n        const indexName = sourcePath.substring(exports.libraryPrefix.length) + \"/index\";\n        if (exports.libraryFiles.hasOwnProperty(plainName)) {\n          sourceText = exports.libraryFiles[plainName];\n          sourcePath = exports.libraryPrefix + plainName + \".ts\";\n        } else if (exports.libraryFiles.hasOwnProperty(indexName)) {\n          sourceText = exports.libraryFiles[indexName];\n          sourcePath = exports.libraryPrefix + indexName + \".ts\";\n        } else {\n          for (let i = 0, k = customLibDirs.length; i < k; ++i) {\n            sourceText = readFile(plainName + \".ts\", customLibDirs[i]);\n            if (sourceText !== null) {\n              sourcePath = exports.libraryPrefix + plainName + \".ts\";\n              break;\n            } else {\n              sourceText = readFile(indexName + \".ts\", customLibDirs[i]);\n              if (sourceText !== null) {\n                sourcePath = exports.libraryPrefix + indexName + \".ts\";\n                break;\n              }\n            }\n          }\n        }\n\n      // Otherwise try nextFile.ts, nextFile/index.ts, ~lib/nextFile.ts, ~lib/nextFile/index.ts\n      } else {\n        const plainName = sourcePath;\n        const indexName = sourcePath + \"/index\";\n        sourceText = readFile(plainName + \".ts\", baseDir);\n        if (sourceText !== null) {\n          sourcePath = plainName + \".ts\";\n        } else {\n          sourceText = readFile(indexName + \".ts\", baseDir);\n          if (sourceText !== null) {\n            sourcePath = indexName + \".ts\";\n          } else if (!plainName.startsWith(\".\")) {\n            if (exports.libraryFiles.hasOwnProperty(plainName)) {\n              sourceText = exports.libraryFiles[plainName];\n              sourcePath = exports.libraryPrefix + plainName + \".ts\";\n            } else if (exports.libraryFiles.hasOwnProperty(indexName)) {\n              sourceText = exports.libraryFiles[indexName];\n              sourcePath = exports.libraryPrefix + indexName + \".ts\";\n            } else {\n              for (let i = 0, k = customLibDirs.length; i < k; ++i) {\n                const dir = customLibDirs[i];\n                sourceText = readFile(plainName + \".ts\", dir);\n                if (sourceText !== null) {\n                  sourcePath = exports.libraryPrefix + plainName + \".ts\";\n                  break;\n                } else {\n                  sourceText = readFile(indexName + \".ts\", dir);\n                  if (sourceText !== null) {\n                    sourcePath = exports.libraryPrefix + indexName + \".ts\";\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      /*\n      In this case the library wasn't found so we check paths\n      */\n      if (sourceText == null && args.path) {\n        for (let _path of args.path) {\n          let _package = sourcePath.replace(/\\~lib\\/([^\\/]*).*/, `$1`);\n          if (args.traceResolution) {\n            writeStdout(`Looking for ${sourcePath} in ${_path}`);\n          }\n          let ascMain = (() => {\n            if (packages.has(_package)){\n              return packages.get(_package);\n            }\n            let p = path.join(_path, _package, \"package.json\");\n            let res = readFile(p, baseDir);\n            if (res){\n              let mainFile = JSON.parse(res).ascMain\n              if (mainFile){\n                let newPackage = mainFile.replace(/(.*)\\/index\\.ts/, '$1');\n                packages.set(_package, newPackage);\n                return newPackage;\n              }\n            }\n            return \"assembly\";\n          })()\n          let realPath = (_p) => {\n            return _p.replace(/\\~lib\\/([^/]*)\\/(.*)/, `${_path}/$1/${ascMain}/$2`);\n          }\n          const plainName = sourcePath;\n          const indexName = sourcePath + \"/index\";\n          sourceText = readFile(realPath(plainName) + \".ts\", baseDir);\n          if (sourceText !== null) {\n            sourcePath = plainName + \".ts\";\n          } else {\n            sourceText = readFile(realPath(indexName) + \".ts\", baseDir);\n            if (sourceText !== null) {\n              sourcePath = indexName + \".ts\";\n            }\n          }\n          if (sourceText !== null) {\n            if (args.traceResolution) {\n              writeStdout(`Found ${sourcePath} at ${realPath(sourcePath)}`);\n            }\n            let newPath = path.join(_path, _package, \"node_modules\");\n            if (!args.path.includes(newPath)){\n              args.path.push(newPath);\n            }\n            break;\n          }\n        }\n      }\n      if (sourceText == null){\n        return callback(Error(\"Import file '\" + sourcePath + \".ts' not found.\"));\n      }\n      stats.parseCount++;\n      stats.parseTime += measure(() => {\n        assemblyscript.parseFile(sourceText, sourcePath, false, parser);\n      });\n    }\n    if (checkDiagnostics(parser, stderr)) {\n      return callback(Error(\"Parse error\"));\n    }\n  }\n\n  // Include runtime template before entry files so its setup runs first\n  {\n    let runtimeName = String(args.runtime);\n    let runtimePath = \"rt/index-\" + runtimeName;\n    let runtimeText = exports.libraryFiles[runtimePath];\n    if (runtimeText == null) {\n      runtimePath = runtimeName;\n      runtimeText = readFile(runtimePath + \".ts\", baseDir);\n      if (runtimeText == null) {\n        return callback(Error(\"Runtime '\" + runtimeName + \"' not found.\"));\n      }\n    } else {\n      runtimePath = \"~lib/\" + runtimePath;\n    }\n    stats.parseCount++;\n    stats.parseTime += measure(() => {\n      parser = assemblyscript.parseFile(runtimeText, runtimePath, true, parser);\n    });\n  }\n\n  // Include entry files\n  for (let i = 0, k = argv.length; i < k; ++i) {\n    const filename = argv[i];\n\n    let sourcePath = String(filename).replace(/\\\\/g, \"/\").replace(/(\\.ts|\\/)$/, \"\");\n\n    // Try entryPath.ts, then entryPath/index.ts\n    let sourceText = readFile(sourcePath + \".ts\", baseDir);\n    if (sourceText === null) {\n      sourceText = readFile(sourcePath + \"/index.ts\", baseDir);\n      if (sourceText === null) {\n        return callback(Error(\"Entry file '\" + sourcePath + \".ts' not found.\"));\n      } else {\n        sourcePath += \"/index.ts\";\n      }\n    } else {\n      sourcePath += \".ts\";\n    }\n\n    stats.parseCount++;\n    stats.parseTime += measure(() => {\n      parser = assemblyscript.parseFile(sourceText, sourcePath, true, parser);\n    });\n  }\n\n  // Parse entry files\n  {\n    let code = parseBacklog();\n    if (code) return code;\n  }\n\n  // Call afterParse transform hook\n  applyTransform(\"afterParse\", parser);\n\n  // Parse additional files, if any\n  {\n    let code = parseBacklog();\n    if (code) return code;\n  }\n\n  // Finish parsing\n  const program = assemblyscript.finishParsing(parser);\n\n  // Print files and exit if listFiles\n  if (args.listFiles) {\n    writeStdOut(parser.seenLog.join(\"\\n\"));\n    callback(null);\n  }\n\n  // Set up optimization levels\n  var optimizeLevel = 0;\n  var shrinkLevel = 0;\n  if (args.optimize) {\n    optimizeLevel = exports.defaultOptimizeLevel;\n    shrinkLevel = exports.defaultShrinkLevel;\n  }\n  if (typeof args.optimizeLevel === \"number\") {\n    optimizeLevel = args.optimizeLevel;\n  }\n  if (typeof args.shrinkLevel === \"number\") {\n    shrinkLevel = args.shrinkLevel;\n  }\n  optimizeLevel = Math.min(Math.max(optimizeLevel, 0), 3);\n  shrinkLevel = Math.min(Math.max(shrinkLevel, 0), 2);\n\n  // Begin compilation\n  const compilerOptions = assemblyscript.createOptions();\n  assemblyscript.setTarget(compilerOptions, 0);\n  assemblyscript.setNoAssert(compilerOptions, args.noAssert);\n  assemblyscript.setImportMemory(compilerOptions, args.importMemory);\n  assemblyscript.setSharedMemory(compilerOptions, args.sharedMemory);\n  assemblyscript.setImportTable(compilerOptions, args.importTable);\n  assemblyscript.setExplicitStart(compilerOptions, args.explicitStart);\n  assemblyscript.setMemoryBase(compilerOptions, args.memoryBase >>> 0);\n  assemblyscript.setSourceMap(compilerOptions, args.sourceMap != null);\n  assemblyscript.setOptimizeLevelHints(compilerOptions, optimizeLevel, shrinkLevel);\n\n  // Initialize default aliases\n  assemblyscript.setGlobalAlias(compilerOptions, \"Math\", \"NativeMath\");\n  assemblyscript.setGlobalAlias(compilerOptions, \"Mathf\", \"NativeMathf\");\n  assemblyscript.setGlobalAlias(compilerOptions, \"abort\", \"~lib/builtins/abort\");\n  assemblyscript.setGlobalAlias(compilerOptions, \"trace\", \"~lib/builtins/trace\");\n\n  // Add or override aliases if specified\n  if (args.use) {\n    let aliases = args.use;\n    for (let i = 0, k = aliases.length; i < k; ++i) {\n      let part = aliases[i];\n      let p = part.indexOf(\"=\");\n      if (p < 0) return callback(Error(\"Global alias '\" + part + \"' is invalid.\"));\n      let name = part.substring(0, p).trim();\n      let alias = part.substring(p + 1).trim();\n      if (!name.length) return callback(Error(\"Global alias '\" + part + \"' is invalid.\"));\n      assemblyscript.setGlobalAlias(compilerOptions, name, alias);\n    }\n  }\n\n  // Enable additional features if specified\n  var features = args.enable;\n  if (features != null) {\n    if (typeof features === \"string\") features = features.split(\",\");\n    for (let i = 0, k = features.length; i < k; ++i) {\n      let name = features[i].trim();\n      let flag = assemblyscript[\"FEATURE_\" + name.replace(/\\-/g, \"_\").toUpperCase()];\n      if (!flag) return callback(Error(\"Feature '\" + name + \"' is unknown.\"));\n      assemblyscript.enableFeature(compilerOptions, flag);\n    }\n  }\n\n  var module;\n  stats.compileCount++;\n  try {\n    stats.compileTime += measure(() => {\n      module = assemblyscript.compileProgram(program, compilerOptions);\n    });\n  } catch (e) {\n    return callback(e);\n  }\n  if (checkDiagnostics(parser, stderr)) {\n    if (module) module.dispose();\n    return callback(Error(\"Compile error\"));\n  }\n\n  // Validate the module if requested\n  if (args.validate) {\n    stats.validateCount++;\n    stats.validateTime += measure(() => {\n      if (!module.validate()) {\n        module.dispose();\n        return callback(Error(\"Validate error\"));\n      }\n    });\n  }\n\n  // Set Binaryen-specific options\n  if (args.trapMode === \"clamp\") {\n    stats.optimizeCount++;\n    stats.optimizeTime += measure(() => {\n      module.runPasses([ \"trap-mode-clamp\" ]);\n    });\n  } else if (args.trapMode === \"js\") {\n    stats.optimizeCount++;\n    stats.optimizeTime += measure(() => {\n      module.runPasses([ \"trap-mode-js\" ]);\n    });\n  } else if (args.trapMode !== \"allow\") {\n    module.dispose();\n    return callback(Error(\"Unsupported trap mode\"));\n  }\n\n  // Implicitly run costly non-LLVM optimizations on -O3 or -Oz\n  // see: https://github.com/WebAssembly/binaryen/pull/1596\n  if (optimizeLevel >= 3 || shrinkLevel >= 2) optimizeLevel = 4;\n\n  module.setOptimizeLevel(optimizeLevel);\n  module.setShrinkLevel(shrinkLevel);\n  module.setDebugInfo(args.debug);\n\n  var runPasses = [];\n  if (args.runPasses) {\n    if (typeof args.runPasses === \"string\") {\n      args.runPasses = args.runPasses.split(\",\");\n    }\n    if (args.runPasses.length) {\n      args.runPasses.forEach(pass => {\n        if (runPasses.indexOf(pass) < 0)\n          runPasses.push(pass);\n      });\n    }\n  }\n\n  // Optimize the module if requested\n  if (optimizeLevel > 0 || shrinkLevel > 0) {\n    stats.optimizeCount++;\n    stats.optimizeTime += measure(() => {\n      module.optimize();\n    });\n  }\n\n  // Run additional passes if requested\n  if (runPasses.length) {\n    stats.optimizeCount++;\n    stats.optimizeTime += measure(() => {\n      module.runPasses(runPasses.map(pass => pass.trim()));\n    });\n  }\n\n  // Prepare output\n  if (!args.noEmit) {\n    let hasStdout = false;\n    let hasOutput = false;\n\n    if (args.outFile != null) {\n      if (/\\.was?t$/.test(args.outFile) && args.textFile == null) {\n        args.textFile = args.outFile;\n      } else if (/\\.js$/.test(args.outFile) && args.asmjsFile == null) {\n        args.asmjsFile = args.outFile;\n      } else if (args.binaryFile == null) {\n        args.binaryFile = args.outFile;\n      }\n    }\n\n    // Write binary\n    if (args.binaryFile != null) {\n      let sourceMapURL = args.sourceMap != null\n        ? args.sourceMap.length\n          ? args.sourceMap\n          : path.basename(args.binaryFile) + \".map\"\n        : null;\n\n      let wasm;\n      stats.emitCount++;\n      stats.emitTime += measure(() => {\n        wasm = module.toBinary(sourceMapURL)\n      });\n\n      if (args.binaryFile.length) {\n        writeFile(args.binaryFile, wasm.output, baseDir);\n      } else {\n        writeStdout(wasm.output);\n        hasStdout = true;\n      }\n      hasOutput = true;\n\n      // Post-process source map\n      if (wasm.sourceMap != null) {\n        if (args.binaryFile.length) {\n          let sourceMap = JSON.parse(wasm.sourceMap);\n          sourceMap.sourceRoot = exports.sourceMapRoot;\n          sourceMap.sources.forEach((name, index) => {\n            let text = null;\n            if (name.startsWith(exports.libraryPrefix)) {\n              let stdName = name.substring(exports.libraryPrefix.length).replace(/\\.ts$/, \"\");\n              if (exports.libraryFiles.hasOwnProperty(stdName)) {\n                text = exports.libraryFiles[stdName];\n              } else {\n                for (let i = 0, k = customLibDirs.length; i < k; ++i) {\n                  text = readFile(name.substring(exports.libraryPrefix.length), customLibDirs[i]);\n                  if (text !== null) break;\n                }\n              }\n            } else {\n              text = readFile(name, baseDir);\n            }\n            if (text === null) {\n              return callback(Error(\"Source file '\" + name + \"' not found.\"));\n            }\n            if (!sourceMap.sourceContents) sourceMap.sourceContents = [];\n            sourceMap.sourceContents[index] = text;\n          });\n          writeFile(path.join(\n            path.dirname(args.binaryFile),\n            path.basename(sourceMapURL)\n          ).replace(/^\\.\\//, \"\"), JSON.stringify(sourceMap), baseDir);\n        } else {\n          stderr.write(\"Skipped source map (stdout already occupied)\" + EOL);\n        }\n      }\n    }\n\n    // Write asm.js\n    if (args.asmjsFile != null) {\n      let asm;\n      if (args.asmjsFile.length) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          asm = module.toAsmjs();\n        });\n        writeFile(args.asmjsFile, asm, baseDir);\n      } else if (!hasStdout) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          asm = module.toAsmjs();\n        });\n        writeStdout(asm);\n        hasStdout = true;\n      }\n      hasOutput = true;\n    }\n\n    // Write WebIDL\n    if (args.idlFile != null) {\n      let idl;\n      if (args.idlFile.length) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          idl = assemblyscript.buildIDL(program);\n        });\n        writeFile(args.idlFile, idl, baseDir);\n      } else if (!hasStdout) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          idl = assemblyscript.buildIDL(program);\n        });\n        writeStdout(idl);\n        hasStdout = true;\n      }\n      hasOutput = true;\n    }\n\n    // Write TypeScript definition\n    if (args.tsdFile != null) {\n      let tsd;\n      if (args.tsdFile.length) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          tsd = assemblyscript.buildTSD(program);\n        });\n        writeFile(args.tsdFile, tsd, baseDir);\n      } else if (!hasStdout) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          tsd = assemblyscript.buildTSD(program);\n        });\n        writeStdout(tsd);\n        hasStdout = true;\n      }\n      hasOutput = true;\n    }\n\n    // Write text (must be last)\n    if (args.textFile != null || !hasOutput) {\n      let wat;\n      if (args.textFile && args.textFile.length) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          wat = module.toText();\n        });\n        writeFile(args.textFile, wat, baseDir);\n      } else if (!hasStdout) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          wat = module.toText()\n        });\n        writeStdout(wat);\n      }\n    }\n  }\n\n  module.dispose();\n  if (args.measure) {\n    printStats(stats, stderr);\n  }\n  if (args.printrtti) {\n    printRTTI(program, stderr);\n  }\n  return callback(null);\n\n  function readFileNode(filename, baseDir) {\n    let dir = baseDir || \"/\"\n    let name = path.resolve(path.join(dir, filename));\n    try {\n      let text;\n      stats.readCount++;\n      stats.readTime += measure(() => {\n        text = fs.readFileSync(name, { encoding: \"utf8\" });\n      });\n      return text;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function writeFileNode(filename, contents, baseDir) {\n    try {\n      stats.writeCount++;\n      stats.writeTime += measure(() => {\n        mkdirp(path.join(baseDir, path.dirname(filename)));\n        if (typeof contents === \"string\") {\n          fs.writeFileSync(path.join(baseDir, filename), contents, { encoding: \"utf8\" } );\n        } else {\n          fs.writeFileSync(path.join(baseDir, filename), contents);\n        }\n      });\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function listFilesNode(dirname, baseDir) {\n    var files;\n    try {\n      stats.readTime += measure(() => {\n        files = fs.readdirSync(path.join(baseDir, dirname)).filter(file => /^(?!.*\\.d\\.ts$).*\\.ts$/.test(file));\n      });\n      return files;\n    } catch (e) {\n      return [];\n    }\n  }\n\n  function writeStdout(contents) {\n    if (!writeStdout.used) {\n      stats.writeCount++;\n      writeStdout.used = true;\n    }\n    stats.writeTime += measure(() => {\n      if (typeof contents === \"string\") {\n        stdout.write(contents, { encoding: \"utf8\" });\n      } else {\n        stdout.write(contents);\n      }\n    });\n  }\n}\n\n/** Checks diagnostics emitted so far for errors. */\nfunction checkDiagnostics(emitter, stderr) {\n  var diagnostic;\n  var hasErrors = false;\n  while ((diagnostic = assemblyscript.nextDiagnostic(emitter)) != null) {\n    if (stderr) {\n      stderr.write(\n        assemblyscript.formatDiagnostic(diagnostic, stderr.isTTY, true) +\n        EOL + EOL\n      );\n    }\n    if (assemblyscript.isError(diagnostic)) hasErrors = true;\n  }\n  return hasErrors;\n}\n\nexports.checkDiagnostics = checkDiagnostics;\n\n/** Creates an empty set of stats. */\nfunction createStats() {\n  return {\n    readTime: 0,\n    readCount: 0,\n    writeTime: 0,\n    writeCount: 0,\n    parseTime: 0,\n    parseCount: 0,\n    compileTime: 0,\n    compileCount: 0,\n    emitTime: 0,\n    emitCount: 0,\n    validateTime: 0,\n    validateCount: 0,\n    optimizeTime: 0,\n    optimizeCount: 0\n  };\n}\n\nexports.createStats = createStats;\n\nif (!process.hrtime) process.hrtime = require(\"browser-process-hrtime\");\n\n/** Measures the execution time of the specified function.  */\nfunction measure(fn) {\n  const start = process.hrtime();\n  fn();\n  const times = process.hrtime(start);\n  return times[0] * 1e9 + times[1];\n}\n\nexports.measure = measure;\n\n/** Formats a high resolution time to a human readable string. */\nfunction formatTime(time) {\n  return time ? (time / 1e6).toFixed(3) + \" ms\" : \"N/A\";\n}\n\nexports.formatTime = formatTime;\n\n/** Formats and prints out the contents of a set of stats. */\nfunction printStats(stats, output) {\n  function format(time, count) {\n    return formatTime(time);\n  }\n  (output || process.stdout).write([\n    \"I/O Read  : \" + format(stats.readTime, stats.readCount),\n    \"I/O Write : \" + format(stats.writeTime, stats.writeCount),\n    \"Parse     : \" + format(stats.parseTime, stats.parseCount),\n    \"Compile   : \" + format(stats.compileTime, stats.compileCount),\n    \"Emit      : \" + format(stats.emitTime, stats.emitCount),\n    \"Validate  : \" + format(stats.validateTime, stats.validateCount),\n    \"Optimize  : \" + format(stats.optimizeTime, stats.optimizeCount)\n  ].join(EOL) + EOL);\n}\n\nexports.printStats = printStats;\n\n/** Prints runtime type information. */\nfunction printRTTI(program, output) {\n  if (!output) output = process.stderr;\n  output.write(\"# Runtime type information (RTTI)\\n\");\n  output.write(assemblyscript.buildRTTI(program));\n}\n\nexports.printRTTI = printRTTI;\n\nvar allocBuffer = typeof global !== \"undefined\" && global.Buffer\n  ? global.Buffer.allocUnsafe || function(len) { return new global.Buffer(len); }\n  : function(len) { return new Uint8Array(len) };\n\n/** Creates a memory stream that can be used in place of stdout/stderr. */\nfunction createMemoryStream(fn) {\n  var stream = [];\n  stream.write = function(chunk) {\n    if (fn) fn(chunk);\n    if (typeof chunk === \"string\") {\n      let buffer = allocBuffer(utf8.length(chunk));\n      utf8.write(chunk, buffer, 0);\n      chunk = buffer;\n    }\n    this.push(chunk);\n  };\n  stream.reset = function() {\n    stream.length = 0;\n  };\n  stream.toBuffer = function() {\n    var offset = 0, i = 0, k = this.length;\n    while (i < k) offset += this[i++].length;\n    var buffer = allocBuffer(offset);\n    offset = i = 0;\n    while (i < k) {\n      buffer.set(this[i], offset);\n      offset += this[i].length;\n      ++i;\n    }\n    return buffer;\n  };\n  stream.toString = function() {\n    var buffer = this.toBuffer();\n    return utf8.read(buffer, 0, buffer.length);\n  };\n  return stream;\n}\n\nexports.createMemoryStream = createMemoryStream;\n\n/** Compatible TypeScript compiler options for syntax highlighting etc. */\nexports.tscOptions = {\n  alwaysStrict: true,\n  noImplicitAny: true,\n  noImplicitReturns: true,\n  noImplicitThis: true,\n  noEmitOnError: true,\n  strictNullChecks: true,\n  experimentalDecorators: true,\n  target: \"esnext\",\n  module: \"commonjs\",\n  noLib: true,\n  types: [],\n  allowJs: false\n};\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","var proc = typeof process !== \"undefined\" && process || {};\nvar isCI = proc.env && \"CI\" in proc.env; // doesn't work when bundled because 'process' is a mock\n\nfunction from(stream, base) {\n  var colors = base || {};\n  colors.supported = (stream && !!stream.isTTY) || isCI;\n  colors.gray = text => colors.supported ? exports.GRAY + text + exports.RESET : text;\n  colors.red = text => colors.supported ? exports.RED + text + exports.RESET : text;\n  colors.green = text => colors.supported ? exports.GREEN + text + exports.RESET : text;\n  colors.yellow = text => colors.supported ? exports.YELLOW + text + exports.RESET : text;\n  colors.blue = text => colors.supported ? exports.BLUE + text + exports.RESET : text;\n  colors.magenta = text => colors.supported ? exports.MAGENTA + text + exports.RESET : text;\n  colors.cyan = text => colors.supported ? exports.CYAN + text + exports.RESET : text;\n  colors.white = text => colors.supported ? exports.WHITE + text + exports.RESET : text;\n  return colors;\n}\n\nexports.stdout = from(proc.stdout, exports);\nexports.stderr = from(proc.stderr);\nexports.from = from;\n\nexports.GRAY = \"\\u001b[90m\";\nexports.RED = \"\\u001b[91m\";\nexports.GREEN = \"\\u001b[92m\";\nexports.YELLOW = \"\\u001b[93m\";\nexports.BLUE = \"\\u001b[94m\";\nexports.MAGENTA = \"\\u001b[95m\";\nexports.CYAN = \"\\u001b[96m\";\nexports.WHITE = \"\\u001b[97m\";\nexports.RESET = \"\\u001b[0m\";\n","// type | meaning\n// -----|---------------\n// b    | boolean\n// i    | integer\n// f    | float\n// s    | string\n// I    | integer array\n// F    | float array\n// S    | string array\n\n/** Parses the specified command line arguments according to the given configuration. */\nfunction parse(argv, config) {\n  var options = {};\n  var unknown = [];\n  var arguments = [];\n  var trailing = [];\n\n  // make an alias map and initialize defaults\n  var aliases = {};\n  Object.keys(config).forEach(key => {\n    if (key.startsWith(\" \")) return;\n    var option = config[key];\n    if (option.alias != null) {\n      if (typeof option.alias === \"string\") aliases[option.alias] = key;\n      else if (Array.isArray(option.alias)) option.alias.forEach(alias => aliases[alias] = key);\n    }\n    if (option.default != null) options[key] = option.default;\n  });\n\n  // iterate over argv\n  for (var i = 0, k = (argv = argv.slice()).length; i < k; ++i) {\n    let arg = argv[i];\n    if (arg == \"--\") { ++i; break; }\n    let match = /^(?:(\\-\\w)(?:=(.*))?|(\\-\\-\\w{2,})(?:=(.*))?)$/.exec(arg), option, key;\n    if (match) {\n      if (config[arg]) option = config[key = arg]; // exact\n      else if (match[1] != null) { // alias\n        option = config[key = aliases[match[1].substring(1)]];\n        if (option && match[2] != null) argv[i--] = match[2];\n      } else if (match[3] != null) { // full\n        option = config[key = match[3].substring(2)];\n        if (option && match[4] != null) argv[i--] = match[4];\n      }\n    } else {\n      if (arg.charCodeAt(0) == 45) option = config[key = arg]; // exact\n      else { arguments.push(arg); continue; } // argument\n    }\n    if (option) {\n      if (option.type == null || option.type === \"b\") options[key] = true; // flag\n      else {\n        if (i + 1 < argv.length && argv[i + 1].charCodeAt(0) != 45) { // present\n          switch (option.type) {\n            case \"i\": options[key] = parseInt(argv[++i], 10); break;\n            case \"I\": options[key] = (options[key] || []).concat(parseInt(argv[++i], 10)); break;\n            case \"f\": options[key] = parseFloat(argv[++i]); break;\n            case \"F\": options[key] = (options[key] || []).concat(parseFloat(argv[++i])); break;\n            case \"s\": options[key] = String(argv[++i]); break;\n            case \"S\": options[key] = (options[key] || []).concat(argv[++i].split(\",\")); break;\n            default: unknown.push(arg); --i;\n          }\n        } else { // omitted\n          switch (option.type) {\n            case \"i\":\n            case \"f\": options[key] = option.default || 0; break;\n            case \"s\": options[key] = option.default || \"\"; break;\n            case \"I\":\n            case \"F\":\n            case \"S\": options[key] = options.default || []; break;\n            default: unknown.push(arg);\n          }\n        }\n      }\n      if (option.value) Object.keys(option.value).forEach(k => options[k] = option.value[k]);\n    } else unknown.push(arg);\n  }\n  while (i < k) trailing.push(argv[i++]); // trailing\n\n  return { options, unknown, arguments, trailing };\n}\n\nexports.parse = parse;\n\n/** Generates the help text for the specified configuration. */\nfunction help(config, options) {\n  if (!options) options = {};\n  var indent = options.indent || 2;\n  var padding = options.padding || 24;\n  var eol = options.eol || \"\\n\";\n  var sb = [];\n  Object.keys(config).forEach(key => {\n    var option = config[key];\n    if (option.description == null) return;\n    var text = \"\";\n    while (text.length < indent) text += \" \";\n    text += \"--\" + key;\n    if (option.alias) text += \", -\" + option.alias;\n    while (text.length < padding) text += \" \";\n    if (Array.isArray(option.description)) {\n      sb.push(text + option.description[0] + option.description.slice(1).map(line => {\n        for (let i = 0; i < padding; ++i) line = \" \" + line;\n        return eol + line;\n      }).join(\"\"));\n    } else sb.push(text + option.description);\n  });\n  return sb.join(eol);\n}\n\nexports.help = help;\n","/*\nCopyright 2010 James Halliday (mail@substack.net)\n\nThis project is free software released under the MIT/X11 license:\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nvar path = require(\"path\");\nvar fs = require(\"fs\");\nvar _0777 = parseInt(\"0777\", 8);\n\nmodule.exports = function mkdirp(p, opts, made) {\n  if (!opts || typeof opts !== \"object\") {\n    opts = { mode: opts };\n  }\n  var mode = opts.mode;\n  if (mode === undefined) {\n    mode = _0777 & (~process.umask());\n  }\n  if (!made) made = null;\n  p = path.resolve(p);\n  try {\n    fs.mkdirSync(p, mode);\n    made = made || p;\n  } catch (err0) {\n    switch (err0.code) {\n      case \"ENOENT\":\n        made = mkdirp(path.dirname(p), opts, made);\n        mkdirp(p, opts, made);\n        break;\n      default:\n        var stat;\n        try {\n          stat = fs.statSync(p);\n        } catch (err1) {\n          throw err0;\n        }\n        if (!stat.isDirectory()) throw err0;\n        break;\n    }\n  }\n  return made;\n};\n","if(typeof __WEBPACK_EXTERNAL_MODULE__10__ === 'undefined') {var e = new Error(\"Cannot find module 'assemblyscript'\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__10__;","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 12;","module.exports = process.hrtime || hrtime\n\n// polyfil for window.performance.now\nvar performance = global.performance || {}\nvar performanceNow =\n  performance.now        ||\n  performance.mozNow     ||\n  performance.msNow      ||\n  performance.oNow       ||\n  performance.webkitNow  ||\n  function(){ return (new Date()).getTime() }\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nfunction hrtime(previousTimestamp){\n  var clocktime = performanceNow.call(performance)*1e-3\n  var seconds = Math.floor(clocktime)\n  var nanoseconds = Math.floor((clocktime%1)*1e9)\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0]\n    nanoseconds = nanoseconds - previousTimestamp[1]\n    if (nanoseconds<0) {\n      seconds--\n      nanoseconds += 1e9\n    }\n  }\n  return [seconds,nanoseconds]\n}"],"sourceRoot":""}